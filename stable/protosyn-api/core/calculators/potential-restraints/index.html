<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Potential Restraints · ProtoSyn.jl</title><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.png" alt="ProtoSyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../../">ProtoSyn.jl</a></span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../../../getting-started/installation/">Installation</a></li><li><a class="tocitem" href="../../../../getting-started/first-steps/">First steps</a></li><li><a class="tocitem" href="../../../../getting-started/examples/">Examples</a></li></ul></li><li><span class="tocitem">ProtoSyn API</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Core</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-1-2" type="checkbox"/><label class="tocitem" for="menuitem-3-1-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../methods/graph/">Graph</a></li><li><a class="tocitem" href="../../methods/state/">State</a></li><li><a class="tocitem" href="../../methods/pose/">Pose</a></li><li><a class="tocitem" href="../../methods/io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../../methods/aux/">Auxiliary methods</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1-3"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../calculators-section/">Calculators Section</a></li><li><a class="tocitem" href="../torchani/">TorchANI</a></li><li><a class="tocitem" href="../bond-distance-restraint/">Bond distance Restraint</a></li><li class="is-active"><a class="tocitem" href>Potential Restraints</a><ul class="internal"><li><a class="tocitem" href="#Available-potentials"><span>Available potentials</span></a></li><li><a class="tocitem" href="#Creating-custom-potential-functions"><span>Creating custom potential functions</span></a></li><li><a class="tocitem" href="#Available-masks"><span>Available masks</span></a></li><li><a class="tocitem" href="#Creating-custom-masks"><span>Creating custom masks</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-4" type="checkbox"/><label class="tocitem" for="menuitem-3-1-4"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../mutators/mutators-section/">Mutators Section</a></li><li><a class="tocitem" href="../../mutators/mutators-dihedral/">Dihedral Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-crankshaft/">Crankshaft Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-rigid-body/">Rigid Body Mutators</a></li><li><a class="tocitem" href="../../mutators/mutators-compound/">Compound Mutators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-5" type="checkbox"/><label class="tocitem" for="menuitem-3-1-5"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../drivers/drivers-section/">Drivers Section</a></li><li><a class="tocitem" href="../../drivers/drivers-monte-carlo/">Monte Carlo</a></li><li><a class="tocitem" href="../../drivers/drivers-steepest-descent/">Steepest Descent</a></li><li><a class="tocitem" href="../../drivers/drivers-ils/">ILS</a></li><li><a class="tocitem" href="../../drivers/drivers-compound/">Compound Driver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-6" type="checkbox"/><label class="tocitem" for="menuitem-3-1-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/selections/">Selections</a></li><li><a class="tocitem" href="../../submodules/builder/">Builder</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Peptides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../peptides/types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-2-3" type="checkbox"/><label class="tocitem" for="menuitem-3-2-3"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/methods/io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../../../peptides/methods/graph/">Graph</a></li><li><a class="tocitem" href="../../../peptides/methods/state/">State</a></li><li><a class="tocitem" href="../../../peptides/methods/pose/">Pose</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-4" type="checkbox"/><label class="tocitem" for="menuitem-3-2-4"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/calculators/sidechain-clash-restraint/">Sidechain Clash Restraint</a></li><li><a class="tocitem" href="../../../peptides/calculators/contact-restraint/">Contact Restraint</a></li><li><a class="tocitem" href="../../../peptides/calculators/ca-ca-clash-restraint/">Cα-Cα Clash Restraint</a></li><li><a class="tocitem" href="../../../peptides/calculators/caterpillar-solvation/">Caterpillar Solvation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-5" type="checkbox"/><label class="tocitem" for="menuitem-3-2-5"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/mutators/rotamer/">Rotamer Mutator</a></li><li><a class="tocitem" href="../../../peptides/mutators/design/">Design Mutator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-6" type="checkbox"/><label class="tocitem" for="menuitem-3-2-6"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/drivers/rotamer-blitz-driver/">Rotamer Blitz</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-7" type="checkbox"/><label class="tocitem" for="menuitem-3-2-7"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/submodules/selections/">Selections</a></li><li><a class="tocitem" href="../../../peptides/submodules/builder/">Builder</a></li><li><a class="tocitem" href="../../../peptides/submodules/rotamers/">Rotamers</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Materials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-3-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/methods/lattices/">Lattices</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Sugars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-4-2" type="checkbox"/><label class="tocitem" for="menuitem-3-4-2"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/submodules/builder/">Builder</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../common/introduction/">Introduction</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ProtoSyn API</a></li><li><a class="is-disabled">Core</a></li><li><a class="is-disabled">Calculators</a></li><li class="is-active"><a href>Potential Restraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Potential Restraints</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/master/docs/src/protosyn-api/core/calculators/potential-restraints.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="calculators-potential-restraints"><a class="docs-heading-anchor" href="#calculators-potential-restraints">Potential restraints</a><a id="calculators-potential-restraints-1"></a><a class="docs-heading-anchor-permalink" href="#calculators-potential-restraints" title="Permalink"></a></h1><p><a href="#calculators-potential-restraints">Potential restraints</a> are a family of <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances that apply any given potential to a selection of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances, optionally further masked or mapped. In other words, the application of a potential restraint to a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> is characterized by a series of fully customizable steps to generate new and/or improved <a href="#calculators-potential-restraints">Potential restraints</a>:</p><ol><li>(Optional) Select a subset of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances to apply the potential;</li><li>Define the potential function to be applied (See <a href="#Available-potentials">Available potentials</a>);</li><li>Apply the potential mask to the selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances;</li><li>(Optional) Multiply a mask/map to the calculated energy and forces matrices;</li><li>Sum the calculated energy and forces matrices.</li></ol><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>As of ProtoSyn 1.0, no <code>Core</code> potential restraint is available, as most of these <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances are specific for a certain type of molecules (such as <a href="../../../peptides/introduction/#Peptides">Peptides</a>). The following types and methods constitute the backbone for all <a href="#calculators-potential-restraints">Potential restraints</a>. Specific applications can be found in other modules of ProtoSyn.</p></div></div><p><img src="../../../../assets/ProtoSyn-potential-restraint.png" alt="ProtoSyn Potential Restraint"/></p><p><strong>Figure 1 |</strong> A diagram representation of the application of a potential restraint, in ProtoSyn. A given potential function (See <a href="#Available-potentials">Available potentials</a>) is applied to a distance matrix (See <a href="../calculators-section/#Distance-matrix-calculation">Distance matrix calculation</a>) calculated from the distances between all selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances. The resulting 2D energy matrix includes the energy values for each pair of interacting <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances. An optional secondary output from the application of the potential function is a 3D forces matrix, with the forces felt on each atom from the interaction with its pair. Both these matrices can optionally suffer another step: the application of a mask or map. On one hand, a <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a>, similarly to its application in <code>AbstractSelection</code>s, turns <em>on</em> and <em>off</em> certain pairs of interacting atoms. As an example, a mask allows the user to ignore same-atom energy artifacts using a <a href="#ProtoSyn.Calculators.diagonal_mask"><code>diagonal_mask</code></a> or ignore interaction between atoms of the same residue using an <a href="#ProtoSyn.Calculators.intra_residue_mask"><code>intra_residue_mask</code></a>. On the other hand, a map in a 2D matrix (with the same size as the 2D energy matrix) with weights and biases. When the two matrices are multiplied together, certain interaction strengths are increased while others are reduced. An example would be the application of a contact map, where each weight corresponds to the certainty factor for the distance between each of the considered <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> pairs. As a final step both the 2D energy matrix and the 3D forces matrix (optionally after the application of the mask/map) are summed (in both axis, in the case of energy calculation, and in one axis, in the case of forces calculation).</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>The above paradigm for application of potential restraints requires, for the correct calculation of forces, the <a href="../calculators-section/#ProtoSyn.Calculators.full_distance_matrix"><code>full_distance_matrix</code></a> to be considered. This causes the energy value calculated to be double the expected (not considering the application on any non diagonally symmetrical mask), as both the top and bottom triagonal matrices are considered. In most cases this is not an issue, as the energy values are compared between simulation frames in relation to eachother and therefore the scale of the value is not important. However, in specific applications, further adjustment of the potential and/or mask applied may be necessary.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.apply_potential" href="#ProtoSyn.Calculators.apply_potential"><code>ProtoSyn.Calculators.apply_potential</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">apply_potential([::Type{A}], coords::Vector{T}, potential::Function) where {A &lt;: ProtoSyn.AbstractAccelerationType, &lt;: AbstractFloat}
apply_potential([::Type{A}], coords::Vector{T}, potential::Function, mask::Union{ProtoSyn.Mask{C}, Matrix{T}}) where {A &lt;: ProtoSyn.AbstractAccelerationType, T &lt;: AbstractFloat, C &lt;: ProtoSyn.AbstractContainer}</code></pre><p>Apply the given <code>potential</code> to the provided <code>coords</code>, return the total energy of the system and matrix of forces felt on each atom (forces are always calculated). If a <code>mask</code> is provided, the resulting energy and force matrix are multiplied by this <code>mask</code> (See <a href="#Available-masks">Available masks</a> for a list of default masks is provided in <code>ProtoSyn.Calculators</code> module). The <code>potential</code> function should receive a <code>distance::T</code> and return an energy value <code>e::T</code>. If it receives an optional tuple <code>v::Tuple{T, T, T}</code>, it should also return the forces <code>f1::Tuple{T, T, T}</code> and <code>f2::Tuple{T, T, T}</code> felt on both ends of the vector, based on the given <code>distance::T</code> (See <a href="#Available-potentials">Available potentials</a> for a list of default potential functions available in <code>ProtoSyn.Calculators</code> module and <a href="#Creating-custom-potential-functions">Creating custom potential functions</a> for the correct function signatures of new potentials). An optional parameter <code>Type{&lt;: AbstractAccelerationType}</code> can be provided, stating the acceleration type used to calculate this energetic contribution (See <a href="../calculators-section/#ProtoSyn-acceleration-types">ProtoSyn acceleration types</a>). Note that this function is usually called by giving a full <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code>, using the function signatures bellow:</p><p><em>Selection | Mask</em></p><pre><code class="nohighlight">apply_potential([::Type{A}], pose::Pose, potential::Function, mask::Union{ProtoSyn.Mask{C}, Matrix{T}}, selection::AbstractSelection) where {A &lt;: ProtoSyn.AbstractAccelerationType, T &lt;: AbstractFloat, C &lt;: ProtoSyn.AbstractContainer}
apply_potential([::Type{A}], pose::Pose, potential::Function, mask::Function, selection::AbstractSelection) where {A &lt;: ProtoSyn.AbstractAccelerationType}</code></pre><p><em>Selection | No Mask</em></p><pre><code class="nohighlight">apply_potential([::Type{A}], pose::Pose, potential::Function, mask::Nothing, selection::AbstractSelection) where {A &lt;: ProtoSyn.AbstractAccelerationType}
apply_potential([::Type{A}], pose::Pose, potential::Function, selection::AbstractSelection) where {A &lt;: ProtoSyn.AbstractAccelerationType}</code></pre><p>Apply the given <code>potential</code> to the selected atoms of <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> via the provided <code>selection</code>, return the total energy of the system and matrix of forces felt on each atom. Optionally, multiply the results by a <code>mask</code> (See <a href="#Available-masks">Available masks</a>). If given (and not equal to <code>nothing</code>), the <code>mask</code> size must match the <code>N</code> selected atoms. Alternatively, the given <code>mask</code> can be a <code>Function</code>, in which case it receives a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> as input (For the correct signature of this <code>Function</code> <code>mask</code>, see <a href="#Creating-custom-masks">Creating custom masks</a>).</p><p><em>No Selection | Mask</em></p><pre><code class="nohighlight">apply_potential([::Type{A}], pose::Pose, potential::Function, mask::Union{ProtoSyn.Mask{C}, Matrix{T}}) where {A &lt;: ProtoSyn.AbstractAccelerationType, T &lt;: AbstractFloat, C &lt;: ProtoSyn.AbstractContainer}
apply_potential([::Type{A}], pose::Pose, potential::Function, mask::Function) where {A &lt;: ProtoSyn.AbstractAccelerationType}
apply_potential([::Type{A}], pose::Pose, potential::Function, selection::Nothing, mask::Union{ProtoSyn.Mask{C}, Matrix{T}}) where {A &lt;: ProtoSyn.AbstractAccelerationType, T &lt;: AbstractFloat, C &lt;: ProtoSyn.AbstractContainer}
apply_potential([::Type{A}], pose::Pose, potential::Function, selection::Nothing, mask::Function) where {A &lt;: ProtoSyn.AbstractAccelerationType}</code></pre><p><em>No Selection | No Mask</em></p><pre><code class="nohighlight">apply_potential([::Type{A}], pose::Pose, potential::Function, mask::Nothing) where {A &lt;: ProtoSyn.AbstractAccelerationType}
apply_potential([::Type{A}], pose::Pose, potential::Function) where {A &lt;: ProtoSyn.AbstractAccelerationType}
apply_potential([::Type{A}], pose::Pose, potential::Function, selection::Nothing, mask::Nothing) where {A &lt;: ProtoSyn.AbstractAccelerationType}
apply_potential([::Type{A}], pose::Pose, potential::Function, selection::Nothing) where {A &lt;: ProtoSyn.AbstractAccelerationType}</code></pre><p>Apply the given <code>potential</code> to the all atoms of <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code>, return the total energy of the system and matrix of forces felt on each <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>. If given (and not equal to <code>nothing</code>), the <code>mask</code> size must match the total number of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in the pose. Alternatively, the given <code>mask</code> can be a<code>Function</code>, in which case it receives a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> as input (For the correct signature of this <code>Function</code> <code>mask</code>, see <a href="#Creating-custom-masks">Creating custom masks</a>).</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>As of ProtoSyn 1.0, this function&#39;s acceleration type must be <code>CUDA_2</code>. Providing any other acceleration type will result in an error. This may be changed in future iterations.</p></div></div><p><strong>Examples</strong></p><pre><code class="nohighlight">julia&gt; fbr = ProtoSyn.Calculators.get_flat_bottom_potential(d1 = 2.0, d2 = 5.0)
 ...

julia&gt; sidechain = !an&quot;^CA$|^N$|^C$|^H$|^O$&quot;r
UnarySelection ❯ ! &quot;not&quot; (Atom)
 └── FieldSelection › Atom.name = r&quot;^CA$|^N$|^C$|^H$|^O$&quot;

julia&gt; mask = ProtoSyn.Calculators.intra_residue_mask(pose, sidechain)
 ...

julia&gt; e, f = ProtoSyn.Calculators.apply_potential(ProtoSyn.CUDA_2, pose, fbr, mask, sidechain)
(2.1792609341377363, [11.380 … -74.232])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Calculators/potential.jl#L41-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint" href="#ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint"><code>ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calc_flat_bottom_restraint([::Type{A}], pose::Pose, update_forces::Bool; d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf, selection::Opt{AbstractSelection} = nothing, mask::MaskMap = nothing) where {A &lt;: ProtoSyn.AbstractAccelerationType, T &lt;: AbstractFloat}</code></pre><p>Apply a flat bottom potential to a given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code>. The potential is iteratively obtained each call using the <a href="#ProtoSyn.Calculators.get_flat_bottom_potential"><code>get_flat_bottom_potential</code></a> method (See <a href="#Available-potentials">Available potentials</a>), by providing the given <code>d1::T</code> (default: 0.0), <code>d2::T</code> (default = 0.0), <code>d3::T</code> (default = Inf) and <code>d4::T</code> (default = Inf) settings as the flat bottom potential distances. This potential then applied to the <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> (via the <a href="#ProtoSyn.Calculators.apply_potential"><code>apply_potential</code></a> method), optionally on a subset of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances given by the <code>AbstractSelection</code> <code>selection</code> and optionally multiplied by a <code>mask</code>. This <code>mask</code> can be a <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a>, a <code>Matrix{T}</code> or a <code>Function</code>, in which case it should be a functor (return a <code>Function</code>) (For the correct signature of this <code>Function</code> <code>mask</code>, see <a href="#Creating-custom-masks">Creating custom masks</a>). These 3 options are named <code>MaskMap</code> for a simplicity of organization only. Return the total energy of the system and matrix of forces felt on each atom. Note that the calculation acceleration type can be set by providing an option parameter <code>Type{&lt;: ProtoSyn.AbstractAccelerationType}</code>. If not provided, the default <code>ProtoSyn.acceleration.active</code> will be used instead.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>As of ProtoSyn 1.0, the <a href="#ProtoSyn.Calculators.apply_potential"><code>apply_potential</code></a> acceleration type defaults to <code>CUDA_2</code> regardless of the requested acceleration type. This may be changed in future iterations.</p></div></div><p><strong>Examples</strong></p><p>```jldoctest julia&gt; ProtoSyn.Calculators.Restraints.calc<em>flat</em>bottom_restraint(pose, true) (0.0, [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0])</p><p>julia&gt; ProtoSyn.Calculators.Restraints.calc<em>flat</em>bottom_restraint(pose, false, d1 = 10.0, d2 = 12.0) (556449.1936070402, [-711.7603616347209 -630.2662235401388 … 995.0284325254745 1153.572133762037; -419.1275359380875 -548.0506257124055 … 286.5285847489888 92.16862928705675; 6.007398880372552 8.2409631821887 … -99.38257889245355 -92.37110004070036])    ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Calculators/restraints.jl#L141-L176">source</a></section></article><h2 id="Available-potentials"><a class="docs-heading-anchor" href="#Available-potentials">Available potentials</a><a id="Available-potentials-1"></a><a class="docs-heading-anchor-permalink" href="#Available-potentials" title="Permalink"></a></h2><p>A list of available potentials in ProtoSyn is described bellow. See <a href="#Creating-custom-potential-functions">Creating custom potential functions</a> for the required signature of new potential functions.</p><ul><li><a href="#ProtoSyn.Calculators.get_flat_bottom_potential"><code>get_flat_bottom_potential</code></a></li></ul><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>As of ProtoSyn 1.0, only the <a href="#ProtoSyn.Calculators.get_flat_bottom_potential"><code>get_flat_bottom_potential</code></a> method is available. In future iterations new potentials (such as <code>linear</code> or <code>quadratic</code> potentials) will be added. </p></div></div><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_flat_bottom_potential" href="#ProtoSyn.Calculators.get_flat_bottom_potential"><code>ProtoSyn.Calculators.get_flat_bottom_potential</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_flat_bottom_potential(;d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf) where {T &lt;: AbstractFloat}</code></pre><p>Return a flat-bottom potential function, using the specified distances. The potential is made up of 5 different sectors, each with the following functions:</p><p class="math-container">\[f_{1}) \;\;\;\;\;\; e = m_{1} \cdot d + b_{1} \;\;\;\;\;\; \left \{ d &lt; d_{1} \right \}\,\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[f_{2}) \;\;\;\;\;\; e = \left (d-d_{2}  \right )^{2} \;\;\;\;\;\;\;\; \left \{ d_{1} \leqslant d &lt; d_{2} \right \}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[f_{3}) \;\;\;\;\;\; e = 0 \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; \left \{ d_{2} \leqslant d \leqslant d_{3} \right \}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[f_{4}) \;\;\;\;\;\; e = \left (d-d_{3}  \right )^{2} \;\;\;\;\;\;\;\; \left \{ d_{4} &lt; d \leqslant d_{4} \right \}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[f_{5}) \;\;\;\;\;\; e = m_{2} \cdot d + b_{2} \;\;\;\;\;\;  \left \{ d &gt; d_{4} \right \}\,\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p>Where </p><p class="math-container">\[m_{1} = 2 \left ( d_{1}-d_{2} \right ) \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[b_{1} = f_{2}\left ( d_{1} \right ) - m_{1} \cdot d_{1} \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[m_{2} = 2\left ( d_{4} - d_{3} \right ) \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p class="math-container">\[b_{2} = f_{4}\left ( d_{4} \right ) - m_{2} \cdot d_{4} \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\]</p><p><em>The resulting function can be called with the following signature:</em></p><pre><code class="nohighlight">flat_bottom_potential(d::T; v::Opt{Vector{T}} = nothing) where {T &lt;: AbstractFloat}</code></pre><p>Return an energy value based on the provided distance <code>d</code>. If a vector <code>v</code> is also provided (optional), the flat-bottom restraint will also return the forces <code>f1</code> and <code>f2</code> (the forces felt on both ends of the vector <code>v</code>). The vector <code>v</code> should have length = 3, corresponding to the 3 dimensions of the distance between the two <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances (X, Y and Z). For more information on the flat-bottom potential, please read: <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4692055/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4692055/</a>. </p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.apply_potential"><code>apply_potential</code></a> <a href="#ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint"><code>calc_flat_bottom_restraint</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; f = ProtoSyn.Calculators.get_flat_bottom_potential(d1 = 1.0, d2 = 2.0, d3 = 3.0, d4 = 4.0);

julia&gt; f(2.5)
0.0

julia&gt; f(1.73, v = (1.0, 1.0, 1.0))
(0.0729, (0.54, 0.54, 0.54), (-0.54, -0.54, -0.54))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Calculators/potential.jl#L364-L414">source</a></section></article><p><img src="../../../../assets/ProtoSyn-fbr.png" alt="ProtoSyn Flat Bottom Potential"/></p><p><strong>Figure 1 |</strong> The flat bottom potential is continuous but divided in 5 sectors. At the extremes, this is a linear potential, becoming quadratic as it nears the central sector, which is flat at <code>y = 0.0</code> between <code>d2</code> and <code>d3</code>, allowing some wiggle room to the metric being measured and evaluated. This potential can be unidirectional: flat at <code>y = 0.0</code> from <code>[0, d3]</code> if <code>d1 = d2 = 0.0</code> or from <code>[d3, +∞[</code> if <code>d3 = d4 = +∞</code>.</p><h2 id="Creating-custom-potential-functions"><a class="docs-heading-anchor" href="#Creating-custom-potential-functions">Creating custom potential functions</a><a id="Creating-custom-potential-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-custom-potential-functions" title="Permalink"></a></h2><p>Besides the currently <a href="#Available-potentials">Available potentials</a>, users can freely create custom and/or improved potential functions. In order to incorporate these potentials in <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> instances (and therefore in <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunction"><code>EnergyFunction</code></a> instances), the following signature must be followed.</p><pre><code class="language-julia">energy, force1, force2 = new_potential(d::T; v::Opt{Vector{T}} = nothing) where {T &lt;: AbstractFloat}</code></pre><p>Any function must, therefore, receive a distance value <code>d::T</code> between two <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances and return the corresponding energy felt. Optionally, it may receive a vector <code>v::Vector{T}</code>, which is the difference vector between the two <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> positions, in which case the potential should also return the two forces felt on each atom from this energetic interaction.</p><p>The newly defined method can then be used in the <a href="#ProtoSyn.Calculators.apply_potential"><code>apply_potential</code></a> function: for each pair of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in the <a href="../calculators-section/#ProtoSyn.Calculators.full_distance_matrix"><code>full_distance_matrix</code></a> this potential will be evaluated. The <a href="#ProtoSyn.Calculators.apply_potential"><code>apply_potential</code></a> (with the new potential) can then be used in a new <code>:calc</code> field of any new <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> (with the correct signature, see <a href="../calculators-section/#Creating-a-custom-EnergyFunctionComponent">Creating a custom EnergyFunctionComponent</a>). However, as a general rule of good practice, an extra step is usually included: as exemplified by the <a href="#ProtoSyn.Calculators.get_flat_bottom_potential"><code>get_flat_bottom_potential</code></a> method, the potential here is actually a <em>functor</em>, returned everytime the <a href="#ProtoSyn.Calculators.get_flat_bottom_potential"><code>get_flat_bottom_potential</code></a> function is called. A set of settings act as the input of this function (the settings of the encompassing <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a>), parametrizing the returned potential. Using this approach, the user has complete access to the <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a><code>.settings</code> field, which will dictate the parametrization of the newly developed potential. This can be useful, for example, in efforts to correctly parametrize an energetic contribution based on a set of data, as the used potential settings can be changed and optimized each step of the simulation, as a new potential is generated everytime. However, this generation does not negatively impact performance in any meaningfull way. </p><h2 id="Available-masks"><a class="docs-heading-anchor" href="#Available-masks">Available masks</a><a id="Available-masks-1"></a><a class="docs-heading-anchor-permalink" href="#Available-masks" title="Permalink"></a></h2><p>A list of available masks/maps in ProtoSyn is described bellow. See <a href="#Creating-custom-masks">Creating custom masks</a> for the required signature of new potential function masks/maps.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.intra_residue_mask" href="#ProtoSyn.Calculators.intra_residue_mask"><code>ProtoSyn.Calculators.intra_residue_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intra_residue_mask(pose::Pose, selection::AbstractSelection)</code></pre><p>For all the atoms in the provided <code>AbstractSelection</code> <code>selection</code> (N), return a 2D N x N <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> with all the atoms of the given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> not in the same residue selected. </p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This function is rather heavy and has low performance. If no design effort is being made (where the sequence changes), the resulting <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> from this function can and should be re-used (only calculated once). If, for a specific application, the <code>AbstractSelection</code> <code>selection</code> remains constant but the <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> needs to be re-calculated (for example, because there was a design/mutation step, use the <em>functor</em> resulting from <a href="#ProtoSyn.Calculators.get_intra_residue_mask"><code>get_intra_residue_mask</code></a>).</p></div></div><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.diagonal_mask"><code>diagonal_mask</code></a> <a href="#ProtoSyn.Calculators.get_intra_residue_mask"><code>get_intra_residue_mask</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight">julia&gt; ProtoSyn.Calculators.intra_residue_mask(pose, !an&quot;^CA$|^N$|^C$|^H$|^O$&quot;r)
ProtoSyn.Mask{Atom}(Bool[1 1 … 0 0; 1 1 … 0 0; … ; 0 0 … 1 1; 0 0 … 1 1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Calculators/potential.jl#L479-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_intra_residue_mask" href="#ProtoSyn.Calculators.get_intra_residue_mask"><code>ProtoSyn.Calculators.get_intra_residue_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_intra_residue_mask(selection::AbstractSelection)</code></pre><p>Provides the <a href="#ProtoSyn.Calculators.intra_residue_mask"><code>intra_residue_mask</code></a> function as a <em>functor</em>, which will calculate the intra residue mask for the given <code>AbstractSelection</code> <code>selection</code>. (Only the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in the selection are considered, all other atoms are not included in the <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a>). Useful when creating a new <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> or when the <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> should be updated each step/call.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.intra_residue_mask"><code>intra_residue_mask</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ProtoSyn.Calculators.get_intra_residue_mask(!an&quot;^CA$|^N$|^C$|^H$|^O$&quot;r)
(::ProtoSyn.Calculators.var&quot;#_intra_residue_mask#5&quot;{UnarySelection{ProtoSyn.Stateless}}) (generic function with 1 method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Calculators/potential.jl#L522-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.diagonal_mask" href="#ProtoSyn.Calculators.diagonal_mask"><code>ProtoSyn.Calculators.diagonal_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">diagonal_mask(pose::Pose, selection::AbstractSelection)</code></pre><p>For all the atoms in the provided <code>AbstractSelection</code> <code>selection</code> (N), return a 2D N x N <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> with all the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances of the given <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> not in the natural diagonal selected (i.e. ignores same atom interaction artifacts).</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>When the selection is constant but the resulting <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> needs to be re-calculated every call/step (for example, due to a design or mutation step), consider using the <em>functor</em> from <a href="#ProtoSyn.Calculators.get_diagonal_mask"><code>get_diagonal_mask</code></a>.</p></div></div><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.intra_residue_mask"><code>intra_residue_mask</code></a> <a href="#ProtoSyn.Calculators.get_diagonal_mask"><code>get_diagonal_mask</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight">julia&gt; ProtoSyn.Calculators.diagonal_mask(pose, an&quot;CA&quot;)
ProtoSyn.Mask{Atom}(3, 3)
3×3 BitArray{2}:
 0  1  1
 1  0  1
 1  1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Calculators/potential.jl#L557-L582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.get_diagonal_mask" href="#ProtoSyn.Calculators.get_diagonal_mask"><code>ProtoSyn.Calculators.get_diagonal_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_diagonal_mask(selection::AbstractSelection)</code></pre><p>Provides the <a href="#ProtoSyn.Calculators.diagonal_mask"><code>diagonal_mask</code></a> as a <em>functor</em>, which will calculate the diagonal mask for the given <code>AbstractSelection</code> <code>selection</code>. Useful when creating a new <a href="../calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent"><code>EnergyFunctionComponent</code></a> or when the <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> should be updated each step/call.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.Calculators.diagonal_mask"><code>diagonal_mask</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight">julia&gt; ProtoSyn.Calculators.get_diagonal_mask(an&quot;CA&quot;)
(::ProtoSyn.Calculators.var&quot;#_diagonal_mask#6&quot;{FieldSelection{ProtoSyn.Stateless,Atom}}) (generic function with 1 method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Calculators/potential.jl#L590-L606">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.Calculators.load_map" href="#ProtoSyn.Calculators.load_map"><code>ProtoSyn.Calculators.load_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_map([::Type{T}], filename::String) where {T &lt;: AbstractFloat}</code></pre><p>Load the map in the <code>filename</code> file (i.e. Contact Map). The file should be in PFRMAT RR format (See: <a href="https://predictioncenter.org/casp13/index.cgi?page=format#RR">https://predictioncenter.org/casp13/index.cgi?page=format#RR</a>). Returns an N x N map of the found weights, with pairs not identified in the file set to 0.0 (N is the maximum indentifier found on the file. As an example, it might be the case where a peptide has 74 residues, but no pair with residue 74 is found on the file, the maximum identifier found might be 72, for example. In this case, the resulting map will have size 72 x 72. In order to ensure the loaded map size matches the underlying peptide size, consider adding an entry of 0.0 on the map file, with the correct maximum identifier). Note: If no optional type <code>T</code> is provided, will use <code>ProtoSyn.Units.defaultFloat</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight">julia&gt; cmap = ProtoSyn.Calculators.load_map(&quot;contact_map_example.txt&quot;)
73×73 Array{Float64,2}:
 ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Calculators/potential.jl#L615-L635">source</a></section></article><p><img src="../../../../assets/ProtoSyn-masks.png" alt="ProtoSyn Available Masks"/></p><p><strong>Figure 2 |</strong> Some of the available <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> instances in ProtoSyn. An <a href="#ProtoSyn.Calculators.intra_residue_mask"><code>intra_residue_mask</code></a> de-selects all atoms that belong to the same <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instance (only accounting for inter-<a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> interactions). A <a href="#ProtoSyn.Calculators.diagonal_mask"><code>diagonal_mask</code></a> simply de-selects the same <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance in a 2D <a href="../calculators-section/#ProtoSyn.Calculators.full_distance_matrix"><code>full_distance_matrix</code></a>. Finally, a contact map is a loaded map (using the <a href="#ProtoSyn.Calculators.load_map"><code>load_map</code></a> method) that asserts a 2D Matrix of weights or biases to be multiplied by the resulting energy and forces matrices in <a href="#ProtoSyn.Calculators.apply_potential"><code>apply_potential</code></a>. As an example, this can be the likelihood of two <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances having a distance shorter can <code>D</code> Angstrom (Å).</p><h2 id="Creating-custom-masks"><a class="docs-heading-anchor" href="#Creating-custom-masks">Creating custom masks</a><a id="Creating-custom-masks-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-custom-masks" title="Permalink"></a></h2><p>In addition to the <a href="#Available-masks">Available masks</a>, users may wish to create and add custom <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> instances to employ in the <a href="#ProtoSyn.Calculators.apply_potential"><code>apply_potential</code></a> method. This method can receive a 2D <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> instance directly, as well as a <code>Matrix{T}</code> or a <code>Function</code> instance. Each case is discussed bellow:</p><ul><li><strong>2D <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a></strong> : A static mask, calculated only once. Energy and forces contributions will only be considered for the selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances (make sure the size of the <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> matches the number of selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in the <a href="#ProtoSyn.Calculators.apply_potential"><code>apply_potential</code></a> call). As an example, see <a href="#ProtoSyn.Calculators.intra_residue_mask"><code>intra_residue_mask</code></a>. The syntax to create a new ProtoSyn <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> is as follows. For more details, see the <a href="../../submodules/selections/#Masks">Masks</a> section.</li></ul><pre><code class="language-julia-repl">julia&gt; 2d_mask = Mask{Atom}(BitArray(falses(4, 4)))
ERROR: syntax: &quot;2&quot; is not a valid function argument name</code></pre><ul><li><strong><span>$Matrix{T}$</span></strong> : A static map, calculated only once. Energy and forces contibutions will be multiplied by the <code>Matrix{T}</code> (make sure that the <code>Matrix{T}</code> size matches the number of selected <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in the <a href="#ProtoSyn.Calculators.apply_potential"><code>apply_potential</code></a> call). As an example, see <a href="#ProtoSyn.Calculators.load_map"><code>load_map</code></a>. The syntax to create a new <code>Matrix{T}</code> is as follows (as an example of a random map).</li></ul><pre><code class="language-julia-repl">julia&gt; 2d_map = rand(4, 4)
ERROR: syntax: &quot;2&quot; is not a valid function argument name</code></pre><ul><li><code>Function</code> : A dynamic mask or map, calculated every step/call of <a href="#ProtoSyn.Calculators.apply_potential"><code>apply_potential</code></a>. This function should have the following simple signature, receiving a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> <code>pose</code> as input and returning either a <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> or a <code>Matrix{T}</code>.</li></ul><pre><code class="language-julia">mask_or_map(pose::Pose)</code></pre><p>Altough potentially sacrificing the performance of the code, this allows for new <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> or a <code>Matrix{T}</code> instances to be calculated every step of a simulation, reflecting new changes, such as mutations or design efforts, for example.</p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>A common practice in building new <code>Function</code> instances that return <a href="../../submodules/selections/#ProtoSyn.Mask"><code>Mask</code></a> or a <code>Matrix{T}</code> instances for application in the <a href="#ProtoSyn.Calculators.apply_potential"><code>apply_potential</code></a> method is to encompass this <code>Function</code> as a <em>functor</em> of another <code>Function</code>. As an example, see the <a href="#ProtoSyn.Calculators.get_intra_residue_mask"><code>get_intra_residue_mask</code></a> method. In this cases, the encompassing <code>Function</code> receives the <code>AbstractSelection</code> <code>selection</code>, making sure that the returned <code>Function</code> selects <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances only within this <code>selection</code>.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bond-distance-restraint/">« Bond distance Restraint</a><a class="docs-footer-nextpage" href="../../mutators/mutators-section/">Mutators Section »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 1 July 2021 15:18">Thursday 1 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
