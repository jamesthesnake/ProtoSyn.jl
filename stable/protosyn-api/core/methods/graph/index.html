<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Graph · ProtoSyn.jl</title><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.png" alt="ProtoSyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../../">ProtoSyn.jl</a></span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../../../getting-started/installation/">Installation</a></li><li><a class="tocitem" href="../../../../getting-started/first-steps/">First steps</a></li><li><a class="tocitem" href="../../../../getting-started/examples/">Examples</a></li></ul></li><li><span class="tocitem">ProtoSyn API</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Core</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-1-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Graph</a><ul class="internal"><li><a class="tocitem" href="#Root-vs-Origin"><span>Root vs Origin</span></a></li><li><a class="tocitem" href="#Parenthood-relationships"><span>Parenthood relationships</span></a></li><li><a class="tocitem" href="#Container-manipulation"><span>Container manipulation</span></a></li><li><a class="tocitem" href="#core-graph-methods-indexation"><span>Indexation</span></a></li><li><a class="tocitem" href="#Counters-and-Iterators"><span>Counters and Iterators</span></a></li><li><a class="tocitem" href="#Bonds"><span>Bonds</span></a></li></ul></li><li><a class="tocitem" href="../state/">State</a></li><li><a class="tocitem" href="../pose/">Pose</a></li><li><a class="tocitem" href="../io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../aux/">Auxiliary methods</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-3" type="checkbox"/><label class="tocitem" for="menuitem-3-1-3"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../calculators/calculators-section/">Calculators Section</a></li><li><a class="tocitem" href="../../calculators/torchani/">TorchANI</a></li><li><a class="tocitem" href="../../calculators/bond-distance-restraint/">Bond distance Restraint</a></li><li><a class="tocitem" href="../../calculators/potential-restraints/">Potential Restraints</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-4" type="checkbox"/><label class="tocitem" for="menuitem-3-1-4"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../mutators/mutators-section/">Mutators Section</a></li><li><a class="tocitem" href="../../mutators/mutators-dihedral/">Dihedral Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-crankshaft/">Crankshaft Mutator</a></li><li><a class="tocitem" href="../../mutators/mutators-rigid-body/">Rigid Body Mutators</a></li><li><a class="tocitem" href="../../mutators/mutators-compound/">Compound Mutators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-5" type="checkbox"/><label class="tocitem" for="menuitem-3-1-5"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../drivers/drivers-section/">Drivers Section</a></li><li><a class="tocitem" href="../../drivers/drivers-monte-carlo/">Monte Carlo</a></li><li><a class="tocitem" href="../../drivers/drivers-steepest-descent/">Steepest Descent</a></li><li><a class="tocitem" href="../../drivers/drivers-ils/">ILS</a></li><li><a class="tocitem" href="../../drivers/drivers-compound/">Compound Driver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-1-6" type="checkbox"/><label class="tocitem" for="menuitem-3-1-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/selections/">Selections</a></li><li><a class="tocitem" href="../../submodules/builder/">Builder</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Peptides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../peptides/types/">Types</a></li><li><input class="collapse-toggle" id="menuitem-3-2-3" type="checkbox"/><label class="tocitem" for="menuitem-3-2-3"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/methods/io/">Input and Output (IO)</a></li><li><a class="tocitem" href="../../../peptides/methods/graph/">Graph</a></li><li><a class="tocitem" href="../../../peptides/methods/state/">State</a></li><li><a class="tocitem" href="../../../peptides/methods/pose/">Pose</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-4" type="checkbox"/><label class="tocitem" for="menuitem-3-2-4"><span class="docs-label">Calculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/calculators/sidechain-clash-restraint/">Sidechain Clash Restraint</a></li><li><a class="tocitem" href="../../../peptides/calculators/contact-restraint/">Contact Restraint</a></li><li><a class="tocitem" href="../../../peptides/calculators/ca-ca-clash-restraint/">Cα-Cα Clash Restraint</a></li><li><a class="tocitem" href="../../../peptides/calculators/caterpillar-solvation/">Caterpillar Solvation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-5" type="checkbox"/><label class="tocitem" for="menuitem-3-2-5"><span class="docs-label">Mutators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/mutators/rotamer/">Rotamer Mutator</a></li><li><a class="tocitem" href="../../../peptides/mutators/design/">Design Mutator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-6" type="checkbox"/><label class="tocitem" for="menuitem-3-2-6"><span class="docs-label">Drivers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/drivers/rotamer-blitz-driver/">Rotamer Blitz</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2-7" type="checkbox"/><label class="tocitem" for="menuitem-3-2-7"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../peptides/submodules/selections/">Selections</a></li><li><a class="tocitem" href="../../../peptides/submodules/builder/">Builder</a></li><li><a class="tocitem" href="../../../peptides/submodules/rotamers/">Rotamers</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Materials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-3-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../materials/methods/lattices/">Lattices</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Sugars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-4-2" type="checkbox"/><label class="tocitem" for="menuitem-3-4-2"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../sugars/submodules/builder/">Builder</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../common/introduction/">Introduction</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ProtoSyn API</a></li><li><a class="is-disabled">Core</a></li><li><a class="is-disabled">Methods</a></li><li class="is-active"><a href>Graph</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Graph</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/master/docs/src/protosyn-api/core/methods/graph.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="core-graph-methods"><a class="docs-heading-anchor" href="#core-graph-methods">Graph</a><a id="core-graph-methods-1"></a><a class="docs-heading-anchor-permalink" href="#core-graph-methods" title="Permalink"></a></h1><p>This section lists functions that work on the system <a href="../../types/#state-types">Graph</a>, such as functions that deal with parent/child relations, indexes and bonds, among others. These are subdivided by topics, for organization purposes:</p><ul><li><a href="#Root-vs-Origin">Root vs Origin</a></li><li><a href="#Parenthood-relationships">Parenthood relationships</a></li><li><a href="#Container-manipulation">Container manipulation</a></li><li><a href="#core-graph-methods-indexation">Indexation</a></li><li><a href="#Counters-and-Iterators">Counters and Iterators</a></li><li><a href="#Bonds">Bonds</a></li></ul><h2 id="Root-vs-Origin"><a class="docs-heading-anchor" href="#Root-vs-Origin">Root vs Origin</a><a id="Root-vs-Origin-1"></a><a class="docs-heading-anchor-permalink" href="#Root-vs-Origin" title="Permalink"></a></h2><p>The <strong>root</strong> of a <a href="../../types/#state-types">Graph</a> is a set of 3 pseudoatoms belonging to a <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a>, acting as the anchor for internal coordinate calculations, while an <strong>origin</strong> is any <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance with no parent in any given container (for example, due to a cut). While a <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> can only have 1 <strong>root</strong>, it can have multiple <strong>origins</strong> (which usually need to be reconnected for most of the simulations of ProtoSyn).</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.origin" href="#ProtoSyn.origin"><code>ProtoSyn.origin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">origin(container::AbstractContainer)</code></pre><p>Return the first <code>Atom</code> in <code>AbstractContainer</code> <code>container</code> that has no parent. The iteration follows the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance <code>:id</code> field, if correctly indexed. If no <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance without parent is found (i.e.: circular structures), return <code>nothing</code>. Note that the <a href="#ProtoSyn.root"><code>root</code></a> atoms are not considered. </p><p><strong>See also</strong></p><p><a href="#ProtoSyn.root"><code>root</code></a> <a href="#ProtoSyn.reindex-Tuple{Topology}"><code>reindex</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.root" href="#ProtoSyn.root"><code>ProtoSyn.root</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">root(container::AbstractContainer)</code></pre><p>Return the first <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> of the Root of the <a href="../../types/#state-types">Graph</a> that given <code>AbstractContainer</code> <code>container</code> belongs to. If the given <code>AbstractContainer</code> <code>container</code> is not a <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a> instance and has <code>:container</code> field set to <code>nothing</code>, return <code>nothing</code>.</p><pre><code class="nohighlight">root(topology::Topology)</code></pre><p>Return the first <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> of the Root of the given <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a> <code>topology</code> instance.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.origin"><code>origin</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L28-L43">source</a></section></article><h2 id="Parenthood-relationships"><a class="docs-heading-anchor" href="#Parenthood-relationships">Parenthood relationships</a><a id="Parenthood-relationships-1"></a><a class="docs-heading-anchor-permalink" href="#Parenthood-relationships" title="Permalink"></a></h2><p><a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> and <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances have parenthood relationships, in a directional <a href="../../types/#state-types">Graph</a>. Several methods allow the manipulation of such relationships, and are of additional importance when using internal coordinates to facilitate and speed up some calculations.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.hasparent" href="#ProtoSyn.hasparent"><code>ProtoSyn.hasparent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hasparent(c::AbstractContainer) -&gt; Bool</code></pre><p>Test whether the given AbstractContainer <code>c</code> has a parent.</p><p><strong>See Also</strong></p><p><a href="#ProtoSyn.isparent"><code>isparent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L51-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.isparent" href="#ProtoSyn.isparent"><code>ProtoSyn.isparent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isparent(parent::AbstractContainer, child::AbstractContainer)</code></pre><p>Test whether <code>parent</code> is the parent of <code>child</code>.</p><p><strong>See Also</strong></p><p><a href="#ProtoSyn.hasparent"><code>hasparent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.setparent!" href="#ProtoSyn.setparent!"><code>ProtoSyn.setparent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setparent!(child::T, parent::T) where {T &lt;: AbstractContainer}</code></pre><p>Set <code>parent</code> as the parent of <code>child</code>, while adding <code>child</code> to <code>parent.children</code>.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.popparent!"><code>popparent!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L79-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.popparent!" href="#ProtoSyn.popparent!"><code>ProtoSyn.popparent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">popparent!(child::AbstractContainer}</code></pre><p>Remove the parent from <code>child</code> (sets it to <code>nothing</code>) while removing <code>child</code> from <code>parent.children</code> (only if <code>child</code> is a child of <code>parent</code>).</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.setparent!"><code>setparent!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L100-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.ascendents" href="#ProtoSyn.ascendents"><code>ProtoSyn.ascendents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ascedents(container::AbstractContainer, level::Int)</code></pre><p>Return a <code>Tuple</code> containing the N (<code>level</code>) previous <code>:id</code> fields of the <code>:parent</code> <code>AbstractContainer</code> instances of the given <code>container</code> (recursivelly).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ascendents(pose.graph[1][1][4], 4)
(4, 3, 1, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L213-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.detach" href="#Base.detach"><code>Base.detach</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">detach(segment::Segment)</code></pre><p>Detach and return the given <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> from it&#39;s container <a href="../../types/#state-types">Graph</a>, by:</p><ul><li>Detaching any <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> and <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instance from the <a href="../../types/#state-types">Graph</a>&#39;s Root (by popping parenthood relationships), if said instances belong to the given <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> instance.</li><li>Deleting this <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> from its container <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a>. </li></ul><p><em>This function is a Base module overload.</em></p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This function does not alter the <a href="../../types/#state-types">State</a> of the <a href="../../types/#Pose">Pose</a> containing the provided <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a>. </p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; detach(pose.graph[1])
Segment{/UNK:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/base.jl#L442-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.travel_graph" href="#ProtoSyn.travel_graph"><code>ProtoSyn.travel_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">travel_graph(start::Atom; [stop::Opt{Atom} = nothing])</code></pre><p>Return a <code>Vector{Atom}</code> with all atom instances between <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>start</code> and <code>stop</code>, while following the structure&#39;s <a href="../../types/#state-types">Graph</a>. If no <code>stop</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance is provided or if it isn&#39;t found as a downstream parent of the <code>start</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>, all instances until no children <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances are found are returned (for example, until the end of the current <a href="../../types/#Pose">Pose</a> of <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a>). Note that the order of the returned <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances reflects the organization of the graph followed, and not the distance/parenthood to the <code>start</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a>, and should therefore be ignored in most cases.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.is_contiguous"><code>is_contiguous</code></a> <a href="#ProtoSyn.hasparent"><code>hasparent</code></a> <a href="#ProtoSyn.setparent!"><code>setparent!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ProtoSyn.travel_graph(pose.graph[1][end][10])
4-element Vector{Atom}:
 Atom{/UNK:1/UNK:1/LEU:21/CD1:334}
 Atom{/UNK:1/UNK:1/LEU:21/HD13:337}
 Atom{/UNK:1/UNK:1/LEU:21/HD12:336}
 Atom{/UNK:1/UNK:1/LEU:21/HD11:335}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L407-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.is_contiguous" href="#ProtoSyn.is_contiguous"><code>ProtoSyn.is_contiguous</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_contiguous(pose::Pose, selection::AbstractSelection)</code></pre><p>Returns <code>true</code> if all the <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances gathered from the <code>selection</code> applied to the given <code>pose</code> are contiguous (have a parenthood relationship connecting them all). Note that the given <code>selection</code> is always promoted to <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> level.</p><p><strong>See also</strong></p><p><a href="../../submodules/selections/#ProtoSyn.promote-Union{Tuple{T2}, Tuple{AbstractSelection, Type{T2}, Function}} where T2&lt;:ProtoSyn.AbstractContainer"><code>ProtoSyn.promote</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ProtoSyn.is_contiguous(pose, rid&quot;1&quot; | rid&quot;3&quot;)
false

julia&gt; ProtoSyn.is_contiguous(pose, rid&quot;1:10&quot;)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L487-L506">source</a></section></article><p><img src="../../../../assets/ProtoSyn-graph2.png" alt="ProtoSyn graph"/></p><p><strong>Figure 1 |</strong> A diagram of a directional <a href="../../types/#state-types">Graph</a> in ProtoSyn.</p><h2 id="Container-manipulation"><a class="docs-heading-anchor" href="#Container-manipulation">Container manipulation</a><a id="Container-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Container-manipulation" title="Permalink"></a></h2><p><a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances have a <code>:container</code> field, setting the container <code>AbstractContainer</code> (usually a <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instance). The same logic applies to <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances, inside <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> structs, and <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> instances inside <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a> structs (according to the established hierarchy of <code>AbstractContainer</code> instances). The following methods allow for the correct manipulation of this relations, allowing to add and remove <code>AbstractContainer</code> instances from the respective <code>:container</code> field, as well as creating copies of them.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.hascontainer" href="#ProtoSyn.hascontainer"><code>ProtoSyn.hascontainer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hascontainer(c::AbstractContainer)</code></pre><p>Return <code>true</code> if the given <code>AbstractContainer.container</code> is not <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer" href="#Base.push!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push!(container::AbstractContainer{T}, item::T) where {T &lt;: AbstractContainer}</code></pre><p>Add an <code>AbstractContainer</code> <code>item</code> to the <code>AbstractContainer</code> <code>container</code>, updating the <code>container</code> size and setting the correct <code>item.container</code>. Return the altered <code>container</code>.</p><pre><code class="nohighlight">push!(residue::Residue, atom::Atom)</code></pre><p>In the specific case of adding an <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>atom</code> to a <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>residue</code>, also add the <code>atom.name</code> to the <code>residue.itemsbyname</code> dictionary for correct indexation by name. Return the altered <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>residue</code>.</p><pre><code class="nohighlight">push!(container::AbstractContainer{T}, items::Vector{T}) where {T &lt;: AbstractContainer}</code></pre><p>Add a vector of <code>AbstractContainer</code> <code>items</code> in the <code>AbstractContainer</code> <code>container</code>, updating the <code>container</code> size and setting the correct <code>item.container</code> for each item in the <code>items</code>. Note that this method keeps the order of <code>items</code>. Return the altered <code>container</code>.</p><p><em>This function is a Base module overload.</em></p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This function does not set any <a href="#Bonds">Bonds</a> or <a href="#Parenthood-relationships">Parenthood relationships</a> to other items in the same <code>container</code>. This function does not set a complementary <a href="../../types/#state-types">State</a>.</p></div></div><p><strong>See also</strong></p><p><a href="#Base.insert!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, Integer, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>insert!</code></a> <a href="#Base.delete!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>delete!</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight">julia&gt; push!(pose.graph[1][1], Atom(&quot;CA&quot;, -1, -1, &quot;C&quot;))
Residue{/UNK:1/UNK:1/SER:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/base.jl#L37-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.insert!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, Integer, T}} where T&lt;:ProtoSyn.AbstractContainer" href="#Base.insert!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, Integer, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">insert!(container::AbstractContainer{T}, index::Integer, item::T) where {T &lt;: AbstractContainer}</code></pre><p>Insert an <code>AbstractContainer</code> <code>item</code> in the <code>AbstractContainer</code> <code>container</code> at the given <code>index</code>, updating the <code>container</code> size and setting the correct <code>item.container</code>. Return the altered <code>container</code>.</p><pre><code class="nohighlight">insert!(container::Residue, index::Integer, item::Atom)</code></pre><p>In the specific case of inserting an <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>atom</code> in a <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>residue</code>, also add the <code>atom.name</code> to the <code>residue.itemsbyname</code> dictionary for correct indexation by name. Return the altered <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>residue</code>.</p><pre><code class="nohighlight">insert!(container::AbstractContainer{T}, index::Integer, items::Vector{T}) where {T &lt;: AbstractContainer}</code></pre><p>Insert a vector of <code>AbstractContainer</code> <code>items</code> in the <code>AbstractContainer</code> <code>container</code> at the given <code>index</code>, updating the <code>container</code> size and setting the correct <code>item.container</code> for each item in the <code>items</code>. Note that this method keeps the order of <code>items</code>. Return the altered <code>container</code>.</p><p><em>This function is a Base module overload.</em></p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>This function does not set any <a href="#Bonds">Bonds</a> or <a href="#Parenthood-relationships">Parenthood relationships</a> to other items in the same <code>container</code>. This function does not set a complementary <a href="../../types/#state-types">State</a>.</p></div></div><p><strong>See also</strong></p><p><a href="#Base.push!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>push!</code></a> <a href="#Base.delete!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>delete!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; insert!(pose.graph[1][1], 3, Atom(&quot;CA&quot;, -1, -1, &quot;C&quot;))
Residue{/UNK:1/UNK:1/SER:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/base.jl#L101-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer" href="#Base.delete!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete!(container::AbstractContainer{T}, item::T) where {T &lt;: AbstractContainer}</code></pre><p>Delete the given <code>AbstractContainer</code> <code>item</code> from the <code>AbstractContainer</code> <code>container</code>, if found, while updating the <code>container.size</code> and <code>item.container</code> fields. In the specific case of deleting an <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance from a <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a>, update <code>container.itemsbyname</code> as well. Return the altered <code>container</code>. If the given <code>AbstractContainer</code> <code>item</code> is not found in the <code>AbstractContainer</code> <code>container</code>, return <code>nothing</code>.</p><p><strong>See also</strong></p><p><a href="#Base.push!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>push!</code></a> <a href="#Base.insert!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, Integer, T}} where T&lt;:ProtoSyn.AbstractContainer"><code>insert!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; delete!(pose.graph[1][1], pose.graph[1][1][&quot;CA&quot;])
Residue{/UNK:1/UNK:1/SER:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/base.jl#L380-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{Atom}" href="#Base.copy-Tuple{Atom}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy(container::AbstractContainer)</code></pre><p>Return a copy of the given <code>AbstractContainer</code> <code>container</code>. Note that for <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> instances only the intra-residue <a href="#Bonds">Bonds</a> and <a href="#Parenthood-relationships">Parenthood relationships</a> can be copied. The same logic applies to the intra-segment <a href="../../types/#graph-types">Graph</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; copy(pose.graph[1, 1, 1])
Atom{/N:1}

julia&gt; copy(pose.graph[1, 1])
Residue{/SER:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/base.jl#L212-L228">source</a></section></article><h2 id="core-graph-methods-indexation"><a class="docs-heading-anchor" href="#core-graph-methods-indexation">Indexation</a><a id="core-graph-methods-indexation-1"></a><a class="docs-heading-anchor-permalink" href="#core-graph-methods-indexation" title="Permalink"></a></h2><p>An important initial detail when describing the <a href="#core-graph-methods">Graph</a> methods is describing the family of <code>getindex</code> methods overloaded by ProtoSyn when dealing with <a href="../../types/#graph-types">Graph</a> structures. There is, in essence, 4 ways to access a specific instance in the <a href="../../types/#graph-types">Graph</a>:</p><ul><li>Using the regular syntax;</li></ul><pre><code class="language-julia-repl">julia&gt; pose.graph.items[1].items[1].items[1]
Atom{/UNK:1/UNK:1/GLY:1/N:1}

julia&gt; pose.graph.items[1].items[1]
Residue{/UNK:1/UNK:1/GLY:1}</code></pre><ul><li>Using the short syntax with index;</li></ul><pre><code class="language-julia-repl">julia&gt; pose.graph[1][1][1]
Atom{/UNK:1/UNK:1/GLY:1/N:1}

julia&gt; pose.graph[1][1]
Residue{/UNK:1/UNK:1/GLY:1}</code></pre><ul><li>Using the condensed syntax with index;</li></ul><pre><code class="language-julia-repl">julia&gt; pose.graph[1, 1, 1]
Atom{/UNK:1/UNK:1/GLY:1/N:1}

julia&gt; pose.graph[1, 1]
Residue{/UNK:1/UNK:1/GLY:1}</code></pre><ul><li>Using the short or condensed syntax with atom name (for <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances only).</li></ul><pre><code class="language-julia-repl">julia&gt; pose.graph[1][1][&quot;N&quot;]
Atom{/UNK:1/UNK:1/GLY:1/N:1}

julia&gt; pose.graph[1, 1, &quot;N&quot;]
Atom{/UNK:1/UNK:1/GLY:1/N:1}</code></pre><p>Note that queries by <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a><code>.name</code> are case sensitive. Besides using it to get <a href="../../types/#graph-types">Graph</a> structures, <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a><code>.name</code> fields can also be used to query for existence:</p><pre><code class="language-julia-repl">julia&gt; &quot;N&quot; in pose.graph[1][1]
true</code></pre><p>The following methods deal with the correct indexation of the <a href="../../types/#state-types">Graph</a>. Note that, altough not necessary, some simulation functions assume that both the <a href="../../types/#state-types">Graph</a> and <a href="../../types/#state-types">State</a> indexation of a <a href="../../types/#Pose">Pose</a> are synched and are equal.</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.genid" href="#ProtoSyn.genid"><code>ProtoSyn.genid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genid()</code></pre><p>Return a random <code>UInt16</code> number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.reindex-Tuple{Topology}" href="#ProtoSyn.reindex-Tuple{Topology}"><code>ProtoSyn.reindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reindex(topology::Topology; set_ascendents = true)</code></pre><p>Re-indexes the whole <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a> <code>topology</code>, setting both the <code>:id</code> and <code>:index</code> of instances inside the <code>topology</code> to the corresponding relative index in the <code>container.items</code> which they belong to. If <code>set_ascendents</code> is set to <code>true</code> (is, by default), each <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instance <code>:ascendents</code> field will be updated to reflect the new indices.</p><pre><code class="nohighlight">reindex(segment::Segment)</code></pre><p>Re-indexes a <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> <code>segment</code>, setting both the <code>:id</code> and <code>:index</code> of instances inside the <code>topology</code> to the corresponding relative index in the <code>container.items</code> which they belong to.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.ascendents"><code>ascendents</code></a> <a href="../state/#ProtoSyn.reindex-Tuple{State}"><code>reindex(::State)</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; reindex(pose.graph)
Topology{/UNK:1}

julia&gt; reindex(pose.graph[1])
Segment{/UNK:1/UNK:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L144-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.ids" href="#ProtoSyn.ids"><code>ProtoSyn.ids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ids(atoms::Vector{Atom})</code></pre><p>Return a vector with the <code>:id</code> <code>Int</code> field for every <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> in the given <code>atoms</code> vector.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.travel_graph"><code>travel_graph</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight">julia&gt; ProtoSyn.ids(an&quot;CA&quot;(pose, gather = true))
21-element Vector{Int64}:
   3
  14
  29
  40
  55
  65
   ⋮
 243
 257
 281
 300
 317
 327</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L450-L477">source</a></section></article><h2 id="Counters-and-Iterators"><a class="docs-heading-anchor" href="#Counters-and-Iterators">Counters and Iterators</a><a id="Counters-and-Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Counters-and-Iterators" title="Permalink"></a></h2><p>ProtoSyn includes custom <a href="#Counters-and-Iterators">Counters and Iterators</a> to analyze and loop over <a href="../../types/#graph-types">Graph</a> structures. In one hand, by using Counters the user can count the number of sub <code>AbstractContainer</code> instances in a <a href="../../types/#graph-types">Graph</a> component (for example, the number of <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances in a <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a> or a <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a>). This can be achieved by using the <code>count_atoms</code>, <code>count_residues</code> and <code>count_segments</code> methods.</p><pre><code class="language-julia-repl">julia&gt; ProtoSyn.count_atoms(pose.graph)
39

julia&gt; ProtoSyn.count_atoms(pose.graph[1][1])
7

julia&gt; ProtoSyn.count_residues(pose.graph)
3</code></pre><p>On the other hand, Iterators allow the user to iterate over all sub <code>AbstractContainer</code> instances in a <a href="../../types/#graph-types">Graph</a> component, by using the <code>eachatom</code>, <code>eachresidue</code> and <code>eachsegment</code> methods.</p><pre><code class="language-julia-repl">julia&gt; eachatom(pose.graph)
ItemIterator{Topology, _ByAtom} with size (1, 3, 39)

julia&gt; for residue in eachresidue(pose.graph[1])
           println(residue);
       end
Residue{/UNK:1/UNK:1/GLY:1}
Residue{/UNK:1/UNK:1/MET:2}
Residue{/UNK:1/UNK:1/GLU:3}</code></pre><h2 id="Bonds"><a class="docs-heading-anchor" href="#Bonds">Bonds</a><a id="Bonds-1"></a><a class="docs-heading-anchor-permalink" href="#Bonds" title="Permalink"></a></h2><p>The following methods deal with the bonding/unbonding of atoms (and respective <a href="#Parenthood-relationships">Parenthood relationships</a> when using the <a href="#ProtoSyn.join"><code>join</code></a> function).</p><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.bond" href="#ProtoSyn.bond"><code>ProtoSyn.bond</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bond(at1::Atom, at2::Atom)</code></pre><p>Bond both given <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances (adds <code>at2</code> to <code>at1.bonds</code> and vice-versa). Both <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances need to be in the same <a href="../../types/#ProtoSyn.Segment"><code>Segment</code></a>.</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.join"><code>join</code></a> <a href="#ProtoSyn.unbond!"><code>unbond!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ProtoSyn.bond(pose.graph[1][1][&quot;C&quot;], pose.graph[1][2][&quot;CA&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L325-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.unbond!" href="#ProtoSyn.unbond!"><code>ProtoSyn.unbond!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unbond!(pose::Pose, at1::Atom, at2::Atom; [keep_downstream_position::Bool = true])::Pose</code></pre><p>Return a <a href="../../types/#Pose">Pose</a> instance with both given <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances unbonded (removed from eachother <code>bonds</code> list, pops parenthood and sets the downstream <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a><code>.parent</code> field to be the Root of the upstream <a href="../../types/#ProtoSyn.Topology"><code>Topology</code></a>). If <code>keep_downstream_position</code> is set to <code>true</code> (is, by default), the downstream <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> position is maintained (by calling <a href="../state/#ProtoSyn.request_c2i!"><code>request_c2i!</code></a> and <a href="../state/#ProtoSyn.sync!"><code>sync!</code></a> methods). </p><div class="admonition is-category-ukw"><header class="admonition-header">Note:</header><div class="admonition-body"><p>Unbonding two atoms also removes any parenthood relationship, therefore making the returned <a href="../../types/#ProtoSyn.Pose"><code>Pose</code></a> from this function un-usable without further changes (the internal coordinates graph is severed on the unbonding site).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; unbond!(pose, pose.graph[1][2][&quot;C&quot;], pose.graph[1][3][&quot;N&quot;])
Pose{Topology}(Topology{/UNK:1}, State{Float64}:
 Size: 343
 i2c: true | c2i: false
 Energy: Dict(:Total =&gt; Inf)
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L235-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ProtoSyn.join" href="#ProtoSyn.join"><code>ProtoSyn.join</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">join(at1::Atom, at2::Atom)</code></pre><p>Join <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>at1</code> with <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> <code>at2</code>.</p><pre><code class="nohighlight">join(r1::Residue, s1::String, r2::Residue, s2::String)</code></pre><p>Join <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> named <code>s1</code> from <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>r1</code> with <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> named <code>s2</code> from <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> <code>r2</code>.</p><p>Bond (add eachother to <code>other.bonds</code> field) and set parent/children relationship of both the <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> instances and respective <code>atom.container</code> (<a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a>). Note that <code>at2</code> <a href="../../types/#ProtoSyn.Atom"><code>Atom</code></a> will become parent at <code>at1</code> (and <code>at2.container</code> <a href="../../types/#ProtoSyn.Residue"><code>Residue</code></a> will become parent of <code>at1.container</code>).</p><p><strong>See also</strong></p><p><a href="#ProtoSyn.bond"><code>bond</code></a> <a href="#ProtoSyn.unbond!"><code>unbond!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Residue!(pose.graph[1], ProtoSyn.ResidueName(&quot;ALA&quot;), 1);

julia&gt; Atom!(pose.graph[1][end], &quot;N&quot;, 1, 1, &quot;N&quot;);

julia&gt; ProtoSyn.join(pose.graph[1][1], &quot;C&quot;, pose.graph[1][end], &quot;N&quot;)
Residue{/UNK:1/UNK:1/ALA:1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/3a5f148f31782f4c86c163bc48e475ec9945b7ba/src/Core/Methods/graph.jl#L349-L376">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../types/">« Types</a><a class="docs-footer-nextpage" href="../state/">State »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 1 July 2021 15:18">Thursday 1 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
