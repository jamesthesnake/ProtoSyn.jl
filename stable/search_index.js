var documenterSearchIndex = {"docs":
[{"location":"getting-started/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"ProtoSyn.jl version 1.1 has been developed and tested for Julia 1.7.2.","category":"page"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"After setting up you Julia installation, open a new REPL and add ProtoSyn.jl using the package manager, directly from the project's GitHub page.","category":"page"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"julia> ] add https://github.com/sergio-santos-group/ProtoSyn.jl.git","category":"page"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"All Julia-based dependencies should automatically be installed/updated.","category":"page"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"In order to use some energy function components, such as TorchANI or REF15 (from PyRosetta), a Python installation is required. ProtoSyn attempts to locate the necessary packages in the system (from PATH and PYTHON_PATH). If not available, installation instructions are shown for each missing package.","category":"page"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"For trying out new features, consider using the development branch of ProtoSyn. Be aware that some bugs and missing documentation are to be expected when using the latest versions.","category":"page"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"julia> ] add https://github.com/sergio-santos-group/ProtoSyn.jl.git#dev","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/types/#core-types","page":"Types","title":"Types","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"In this section we will explore the main struct instances that compose the core of ProtoSyn's engine, divided in the following topics, for organization purposes:","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Pose\nFragment\nGraph\nState","category":"page"},{"location":"protosyn-api/core/types/#pose-types","page":"Types","title":"Pose","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"A pose holds all necessary information regarding a molecular system. This information is divided in the Graph and State .","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Pose","category":"page"},{"location":"protosyn-api/core/types/#ProtoSyn.Pose","page":"Types","title":"ProtoSyn.Pose","text":"Pose{T <: AbstractContainer}(graph::T, state::State)\n\nReturn a Pose instance. A Pose is a complete description of a molecular system  at any given point, having both the interaction graph and the current state of the system coordinates represented. A Pose is typed by an [AbstractContainer], usually a Topology.\n\nPose(::T, frag::Fragment) where {T <: AbstractContainer}\n\nReturn a Pose instance from a Fragment, where the State is empty/blank. The graph contents are copied to the new Pose. If no type T <: AbstractFloat is provided, the Units.defaultFloat will be used.\n\nSee also\n\nFragment\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#fragment-types","page":"Types","title":"Fragment","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"ProtoSyn.jl package uses a pose of a single Segment (therefore without a Root) to carry information during certain processes (such as building a new peptide from a sequence).","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Fragment","category":"page"},{"location":"protosyn-api/core/types/#ProtoSyn.Fragment","page":"Types","title":"ProtoSyn.Fragment","text":"Fragment\n\nA Fragment is a type overload for Pose{Segment} and therefore does not contain a root/origin. These are usually used as temporary carriers of information, without the ability to be directly incorporated in simulations.\n\nSee also\n\nfragment\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#graph-types","page":"Types","title":"Graph","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"The directed graph holds the information regarding the hierarchical organization of a molecular system, where the top level of organization is a Topology instance, which can contain one or more instances of Segment. This structure, in turn, is comprised of one or more Residue instances, which are themselves a set of Atom instances, this being the lowest level of data organization in ProtoSyn. By being a directed graph, this data organization structure introduces the concept of parenthood between particles in the system: each Atom has a parent, and may have one or more child Atom instances. The same concept is extended to Residue and Segment instances. Ultimately, the initial Atom in a Pose is a child of the root structure, a group of three virtual atoms. The parenthood relationships not only allow for directed traveling of the graph, but also offer interesting opportunities when coupled with the hybrid coordinate system of the Pose's State.","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"(Image: ProtoSyn graph)","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Topology\nSegment\nResidue","category":"page"},{"location":"protosyn-api/core/types/#ProtoSyn.Topology","page":"Types","title":"ProtoSyn.Topology","text":"Topology <: AbstractContainer{Segment}\nTopology(name::String, id::Int)\n\nConstruct a Topology, with the given name and id. A Topology is the top level of hierarchy in a Graph, and holds a Root Residue, therefore initializing the internal coordinates system in the corresponding [State] of a Pose.  Note: Topology is of super type AbstractTopology, which is an AbstractContainer.\n\nFields\n\nname::String - The name of the Topology\nid::Int - The ID of the Topology\nitems::Vector{Segment} - All the Segment instances in this Topology (default: empty)\nsize::Int - The number of Segment instances in this Topology (default: 0)\nroot::Residue - The root Residue of this Topology\ncontainer::Nothing - Used to identify the root Residue  (default: nothing)\n\nukw: Note:\nWhen in a Pose, both the Topology and the corresponding State need to share the same :id. This is used to identify situations where a change in one of this structures was not reflected on the other.\n\nSee also\n\nroot Segment\n\nExamples\n\njulia> top = Topology(\"UNK\", 1)\nTopology{/UNK:1}\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#ProtoSyn.Segment","page":"Types","title":"ProtoSyn.Segment","text":"Segment <: AbstractContainer{Residue}\nSegment(name::String, id::Int)\n\nConstruct a Segment, with the given name and id. The created segment has no container. A Segment is a group of Residue instances. Note: Segment is of super type AbstractSegment, which is an AbstractContainer.\n\nFields\n\nname::String - The name of the Segment\nid::Int - The ID of the Segment\nindex::Int - The index of the Segment (default: same as :id)\ncode::Char - A 1-letter code for the chain (used in PDB formatting) (default: '?')\nitems::Vector{Residue} - A list of Residue instances in this Segment (default: empty)\ncontainer::Opt{AbstractTopology} - An optional container for this Segment (default: nothing)\nsize::Int - The number of Residue instances in this Segment (default: 0)\n\nSee also\n\nTopology Residue\n\nExamples\n\njulia> res = Segment(\"UNK\", 1)\nSegment{/UNK:1}\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#ProtoSyn.Residue","page":"Types","title":"ProtoSyn.Residue","text":"Residue <: AbstractContainer{Atom}\nResidue(name::String, id::Int)\n\nConstruct a Residue, with the given name and id. The created residue has no container; it is also a free directed-graph node (no parent/children). A Residue is a group of Atom instances. Note: Residue is of super type AbstractResidue, which is an AbstractContainer.\n\nFields\n\nname::ResidueName - The name of the Residue\nid::Int - The ID of the Residue\nindex::Int - The index of the Residue (default: same as :id)\nitems::Vector{Atom} - A list of Atom instances in this Residue (default: empty)\nitemsbyname::Dict{String, Atom} - A Dict object containing a link to each of the Atom instances in this Residue bsed on the :name of the Atom (default: empty)\ncontainer::Opt{AbstractSegment} - An optional container for this Residue (default: nothing)\nsize::Int - The number of Atom instances in this Residue (default: 0)\nvisited::Bool - Check whether this Residue has been visited (used by a some functions) (default: false)\nparent::Opt{Residue} - Optionally, the parent of this Residue in the directional graph (default: nothing)\nchildren::Vector{Residue} - Optionally, the list of children Residue instances downstream of this Residue (default: empty)\nascedents::Opt{NTuple{4, Int}} - Optionally, the list of 4 ascendents, including this Residue (default: nothing)\n\nSee also\n\nSegment Atom ascendents ResidueName\n\nExamples\n\njulia> res = Residue(\"UNK\", 1)\nResidue{/UNK:1}\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"ukw: Note:\nInstead of defining Residue.name as a String, ProtoSyn uses a specific type (ResidueName) to accomodate specific conventions in aminoacid naming.","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"ProtoSyn.ResidueName\nAtom","category":"page"},{"location":"protosyn-api/core/types/#ProtoSyn.ResidueName","page":"Types","title":"ProtoSyn.ResidueName","text":"ResidueName(s::String) <: AbstractString\n\nA string overload to accomodate different known and expected denominations of certain residues (\"HIS\" == \"HIE\" for example).\n\nExample\n\njulia> ProtoSyn.ResidueName(\"HIS\")\nHIS\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#ProtoSyn.Atom","page":"Types","title":"ProtoSyn.Atom","text":"Atom <: AbstractContainer{Nothing}\n\nAn Atom type.\n\nAtom(name::String, id::Int, index::Int, symbol::String)\n\nConstruct an Atom, with the given name, id, index, and symbol. The created atom has no bonds and container; it is also a free directed-graph node (no parent/children). Note: Atom is of super type AbstractAtom, which is an AbstractContainer.\n\nFields\n\nname::String - The name of the Atom\nid::Int - The ID of the Atom\nindex::Int - The index of the Atom (default: same as :id)\nsymbol::String - The chemical element symbol of this Atom\nbonds::Vector{Atom} - A list of Atom instances connected to this Atom by a bond (default: empty)\ncontainer::Opt{AbstractResidue} - An optional container for this Atom (default: nothing)\nvisited::Bool - Check whether this Atom has been visited (used by a some functions) (default: false)\nparent::Opt{Atom} - Optionally, the parent of this Atom in the directional graph (default: nothing)\nchildren::Vector{Atom} - Optionally, the list of children Atom instances downstream of this Atom (default: empty)\nascedents::Opt{NTuple{4, Int}} - Optionally, the list of 4 ascendents, including this Atom (default: nothing)\n\nSee also\n\nResidue [ascendents]\n\nExamples\n\njulia> at = Atom(\"H1\", 1, 1, \"H\")\nAtom{/H1:1}\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#state-types","page":"Types","title":"State","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"A State structure is responsible for holding the current state of the internal and cartesian coordinates, as well as the forces felt on each atom and the resulting energy of the system (as calculated by an [EnergyFunction]). This structure is sub-divided in a list of AtomState instances and a StateMatrix. Both of these structures are complementary, meaning that any change in one in synched in the other. While AtomState instances hold both the internal and cartesian coordinates relative to a single Atom, StateMatrix is a 2D matrix of all cartesian coordinates of the atoms in a given Pose.","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"State\nAtomState\nStateMatrix","category":"page"},{"location":"protosyn-api/core/types/#ProtoSyn.State","page":"Types","title":"ProtoSyn.State","text":"State([::T]) where {T <: AbstractFloat}\n\nA State is a complete representation of a given molecular system regarding the position, the forces felt and the resulting energetic contribution by each atom. Each AtomState in a system.\n\nState([::T], n::Int) where {T <: AbstractFloat}\n\nReturn a State with size n, with all items set to be an empty AtomState.\n\nState([::T], items::Vector{AtomState{T}}) where {T <: AbstractFloat}\n\nReturn a State with size length(items), with all the given items.\n\nukw: Note:\nIf no type T <: AbstractFloat is provided, Units.defaultFloat will be used.\n\nFields\n\nitems::Vector{AtomState{T}} - The list of AtomState instances in this State (default: empty)\nsize::Int - The number of AtomState instances in this State (default: 0)\nid::Int - The Id (to be matched to the corresponding Topology in a Pose) (default: -1)\ni2c::Bool - Flag indicating this State needs to be synched to cartesian coordinates (default: false)\nc2i::Bool - Flag indicating this State needs to be synched to internal coordinates (default: false)\nindex_offset::Int - Ignore the first N AtomState instances (default: 3)\nx::StateMatrix{T} - The cartesian coordinate matrix of all AtomState instances in this State (default: empty)\nf::Matrix{T} - The force matrix of all AtomState instances in this State (default: empty)\ne::Dict{Symbol, T} - The list of all energetic components evaluated for this State (default: empty)\n\nSee also\n\nTopology AtomState StateMatrix\n\nExamples\n\njulia> State(4)\nState{Float64}:\n Size: 4\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#ProtoSyn.AtomState","page":"Types","title":"ProtoSyn.AtomState","text":"AtomState{T}(parent::Any, index::Int, t::MVector{3, T}, r::MMatrix{3, 3, T, 9}, b::T, θ::T, ϕ::T, δ::T, Δϕ::T, changed::Bool) where {T <: AbstractFloat}\n\nAn AtomState instance. Holds information regarding the state of the atom, including the cartesian and internal coordinates.\n\nAtomState([::T]) where {T <: AbstractFloat}\n\nReturn an empty AtomState instance, with all default values.\n\nukw: Note:\nIf no type T <: AbstractFloat is provided, Units.defaultFloat will be used.\n\nukw: Note:\nChanging this AtomState cartesian coordinates will update and sync changes with a sibling StateMatrix, as long as this structs parent is correctly set.\n\nFields\n\nparent::Any - If set, should point to the parent State containing this AtomState (default: nothing)\nindex::Int - the index of this AtomState\nt::MVector{3, T} - The translation vector from origin (cartesian coordinates) (default: empty)\nr::MMatrix{3, 3, T, 9} - The rotation matrix for cartesian to internal coordinate sync (default: empty)\nb::T - Distance (in Angstrom Å) to parent atom (default: 0)\nθ::T - Angle (in radians) to ascendent atoms (default: 0)\nϕ::T - Dihedral angle (in radians) to ascendent atoms (default: 0)\nδ::T - Atomic partial charge (default: 0.0)\nΔϕ::T - Dihedral angle change (in radians) to be applied to children atoms (default: 0)\nchanged::Bool - Flag indicating whether this AtomState has been modified (useful in some functions such as i2c! and c2i!) (default: false)\n\nukw: Note:\nThe Δϕ field in AtomState allows for easy set-up of dihedral angles in molecular structures. By modifying Δϕ in an atom, all child atoms will be rotated by the same amount, even in being branched structures.\n\nSee also\n\nState StateMatrix\n\nExamples\n\njulia> AtomState()\nAtomState{Float64}:\n Index: -1\n T: [0.000, 0.000, 0.000]\n b: 0.000 Å | θ:  0.000 rad (   0.00°) | ϕ:  0.000 rad (   0.00°) | Δϕ:  0.000 rad (   0.00°)\n δ: 0.000\n Changed: false\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#ProtoSyn.StateMatrix","page":"Types","title":"ProtoSyn.StateMatrix","text":"StateMatrix{T}(parent::Any, coords::Matrix{T}) where {T <: AbstractFloat}\n\nA StateMatrix instance holds the cartesian coordinates of all AtomState instances in a State. It is an overload of a Matrix struct, and used to efficiently apply substantial changes to a system or a large number of atoms. \n\nukw: Note:\nIf no type T <: AbstractFloat is provided, Units.defaultFloat will be used.\n\nukw: Note:\nChanging this StateMatrix cartesian coordinates will update and sync changes with a sibling AtomState, as long as this structs parent is correctly set. In such case, the parent.c2i flag is also set to true.\n\nFields\n\nparent::Any - If set, should point to the parent State containing this StateMatrix (default: nothing)\ncoords::Matrix - The cartesian coordinates matrix\n\nSee also\n\nState AtomState\n\nExamples\n\njulia> StateMatrix(zeros(3, 3))\nStateMatrix{Float64}:\n Parent set: false\n3×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#Array-of-Structures-vs-Structure-of-Arrays","page":"Types","title":"Array of Structures vs Structure of Arrays","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Given this organization of cartesian coordinates in a Pose, a decades old dilemma naturally emerges: should the data be organized in Array of Structures or in a Structure of Arrays. The differences are illustrated bellow:","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Structure of Arrays (SoA) - The main object is a single structure which holds a vector for each of the coordinates of all Atom instances. Each coordinate vector of all Atom instances is contiguous in memory.\nArray of Structures (AoS) - The main object is a vector of Atom instances, where each Atom structure holds a field for each coordinate. Each Atom set of coordinates is contiguous in memory.","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"(Image: ProtoSyn Energy Function)","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Figure 1 | Visualization of Atom instances organization in memory: Structure of Arrays (SoA) vs Array of Structures (AoS). In one hand, when employing the Structure of Arrays (SoA) paradigm, memory is contiguous when accessing all the X coordinates of each Atom instance (for example). On the other hand, when employing the Array of Structures (AoS) paradigm, memory is contiguous when accessing all the X, Y and Z coordinates of a single atom (or adjacently indexed atoms).","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Given that Julia is a column major programming language and based on performance benchmarks during early development cycles, ProtoSyn is developed using the Array of Structures (AoS) paradigm (each State contains an array of structures AtomState).","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/submodules/builder/#core-builder","page":"Builder","title":"Builder","text":"","category":"section"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"The Builder is a submodule of ProtoSyn.Core module. As such, the following core introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"The following sections offer a more in-depth view of the available types and methods for building molecular structures from template libraries:","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"Defining and loading a Stochastic L-Grammar\nBuilding a molecular structure\nManipulating a molecular structure by adding new residues from templates","category":"page"},{"location":"protosyn-api/core/submodules/builder/#core-builder-1","page":"Builder","title":"Defining and loading a Stochastic L-Grammar","text":"","category":"section"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"A core feature of ProtoSyn is the generation of structures from scratch, using residue templates as building blocks for complex structures. The Builder submodule introduces this functionality by providing support for Stochastic L-grammars. As a succint summary, L-grammar systems provide a simple syntax to encode rather complex structures, supporting ramifications (as in carbohydrates and glycoproteins) and random generation of compositions by stochastic rules.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"In ProtoSyn, several different L-Grammar systems are provided, based on the type of variables. For example, in the Peptides module, a peptide-based L-Grammar is made available, where the alphabet/variables are the 20 natural aminoacids. In this case, since peptides are a linear chain, there isn't a stochastic rule: each aminoacid, when expanded, simply returns itself. Finally, the main operator (α) is a peptidic bond generator, connecting two residues in a row. Therefore, as an example of employment of Peptides L-Grammar, the string \"GME\" could be easily expanded and built into a 3D structure of 3 aminoacids: Glycine-Methionine-Glutamic Acid, connected by peptidic bonds.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"ukw: Note:\nSince L-grammars are specific for a given type/family of molecules, no default grammar is provided by ProtoSyn.Core module. The following examples and details are discussed by using the Peptides default L-grammar. ","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"(Image: ProtoSyn L-grammar)","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"Figure 1 | A diagram representation of the Peptides default L-grammar. Any L-grammar in ProtoSyn is composed of 3 elements: [1] a variables library containing the templates of all the building blocks available. Each variable is a complete description of all internal associations between Atom instances (Bonds and Parenthood relationships) as well as all internal coordinates and charges). This information, once loaded, forms an independent Fragment object and is indexed by a :name or a :code. In the case of the Peptides L-Grammar, there are 20 variables, one for each of the 20 natural aminoacids; [2] one or more operators, describing bridging connections between 2 of the L-Grammar variables. These, once loaded, return a function that bonds (and applies the correct Parenthood relationships) the requested Atom instances, while also applying specific internal coordinates to the involved Atom instances. In the case of the Peptides L-Grammar, the only available operator describes a peptidic bond (in reality, 2 extra operators are available for generating internal coordinates for the linear peptides & the special case of prolines); [3] optionally, a set of stochastic rules for choosing an operator. ProtoSyn employs stochastic rules for choosing what operator to apply to any 2 given templates, meaning that different operators can be randomly applied based on a set of weights, generating complex structures in a random way, if desired. In the case of the Peptides L-grammar, such rules are not applied, since there is only 1 operator to be applied linearly.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"As previously explored, ProtoSyn supports Stochastic L-Grammar structures for defining semi-random and ramified molecular structures. The following types and methods explore how this is achieved in more detail. In addition, loading an LGrammar also adds any additional information (such as available residue types for mutation) to all relevant global variables in ProtoSyn.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"LGrammar\nStochasticRule\nload_grammar_from_file","category":"page"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.LGrammar","page":"Builder","title":"ProtoSyn.LGrammar","text":"LGrammar{T <: AbstractFloat, K, V}(rules::Dict{K, Vector{StochasticRule{K,V}}}, variables::Dict{K, Fragment}, operators::Dict{K, Function}, defop::Opt{Function})\n\nAn LGrammar instance. Holds information regarding a stochastic L-Grammar system, made up of a set of variables connectable by one or more operators. Optionally, stochastic rules can randomly pick the operator to apply, based on a set of weights.\n\nLGrammar{T, K, V}() where {T <: AbstractFloat, K, V}\n\nReturn an empty LGrammar instance.\n\nFields:\n\nrules::Dict{K, Vector{StochasticRule{K,V}}} - A dictionary of StochasticRule instances indexed by the variable key over which the given rule will operate; \nvariables::Dict{K, Fragment} - A dictionary of variables (Fragment templates) indexed by the corresponding code;\noperators::Dict{K, Function} - A dictionary of operator Function instances indexed by a named String;\ndefop::Opt{Function} - Default operator. If no operator is described in the given derivation (during the build process), uses this operator.\n\nSee also\n\nStochasticRule build load_grammar_from_file\n\nukw: Note:\nAs a general rule, LGrammar instances are loaded from an .YML file (using the load_grammar_from_file method). Check this entry for a more in-depth description of the file format.\n\nExamples\n\njulia> grammar = LGrammar{Float64, String, Vector{String}}()\nLGrammar{Float64, String, Vector{String}}:\n Rules: None.\n Variables: None.\n Operators: None.\n\njulia> grammar = ProtoSyn.Peptides.grammar\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.StochasticRule","page":"Builder","title":"ProtoSyn.StochasticRule","text":"StochasticRule(p::T, rule::Pair{K, V}) where {T <: AbstractFloat, K, V}\n\nReturn a new StochasticRule instance with the given probability of occurrence p. The rule is a Pair{K, V} where in most cases K is an instance of type String (i.e.: a Key) and V is an instance of type Vector{String} (i.e.: a Vector of instructions). These are also called of  \"production instructions\" and define the result of deriving the given \"key\" in any derivation. As an example, the pair \"A\" => [\"A\", \"ɑ\", \"A\"] would be interpreted upon derivation, and the entry A would be expanded to AA, where both new A instances are joined by the ɑ operator, with a probability of occurrence of p.\n\nFields\n\np::T - The probability of occurrence;\nsource::K - The key of the rule on this StochasticRule instance;\nproduction::V - The resulting vector of the derivation of this StochasticRule instance on the given source.\n\nSee also\n\nLGrammar\n\nExamples\n\njulia> sr = StochasticRule(1.0, \"A\" => [\"A\", \"ɑ\", \"A\"])\nA(p=1.0) -> [\"A\", \"ɑ\", \"A\"]\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.load_grammar_from_file","page":"Builder","title":"ProtoSyn.load_grammar_from_file","text":"load_grammar_from_file([::Type{T}], filename::AbstractString, key::String) where {T <: AbstractFloat}\n\nCreate an LGrammar instance from the contents of a grammar file (in .YML format) under the key entry. The file contents are parsed by the lgfactory method. Any numerical entry is parsed to the provided type T (or Units.defaultFloat if no type is provided). Return the parsed LGrammar instance. automatically calls load_grammar_extras_from_file!.\n\nSee also\n\nLGrammar lgfactory\n\nExamples\n\njulia> lgrammar = load_grammar_from_file(Float64, filename, \"peptide\")\n\njulia> lgrammar = load_grammar_from_file(filename, \"peptide\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"(Image: ProtoSyn L-grammar)","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"Figure 2 | An exploration of the .YML file format describing a new LGrammar instance (and loaded by the load_grammar_from_file method). Templates for the variables entry can be in any of the supported formats by ProtoSyn (such as .YML and .PDB). Usually .YML formats are employed, since extra information such as the Parenthood relationships between intra-residue atoms can be easily included. ProtoSyn is able to parse certain unit symbols, such as the degree symbol (°). Otherwise, the default units are in radians.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"lgfactory\nProtoSyn.opfactory\nload_grammar_extras_from_file!","category":"page"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.lgfactory","page":"Builder","title":"ProtoSyn.lgfactory","text":"lgfactory([::Type{T}], template::Dict) where {T <: AbstractFloat}\n\nCreate an LGrammar instance from the contencts of a template Dict (normally read from a grammar file). Any numerical entry is parsed to the provided type T (or Units.defaultFloat if no type is provided). The operators entry is parsed by the opfactory method. Return the parsed LGrammar instance.\n\nSee also\n\nLGrammar load_grammar_from_file opfactory\n\nukw: Note:\nThis is an internal method of ProtoSyn and shouldn't normally be used directly.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.opfactory","page":"Builder","title":"ProtoSyn.opfactory","text":"opfactory(args::Any)\n\nReturn the operation function (as a closure) given the input arguments args (normally read from a grammar file). \n\nSee also\n\nlgfactory\n\nukw: Note:\nThe resulting operation function is responsible for setting the internal coordinates of residues in the system when connecting, building and manipulating poses.\n\nukw: Note:\nThis is an internal method of ProtoSyn and shouldn't normally be used directly.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.load_grammar_extras_from_file!","page":"Builder","title":"ProtoSyn.load_grammar_extras_from_file!","text":"load_grammar_extras_from_file!([::Type{T}], filename::AbstractString, key::String) where {T <: AbstractFloat}\n\nLoads the key entry in the given LGrammar .YML file (filename) extras into the correct global variables in ProtoSyn. Any numerical entry is parsed to the provided type T (or Units.defaultFloat if no type is provided).\n\nThe extra info loaded by this method is:\n\nAny alt entry is added to ProtoSyn.alt_residue_names\n\nukw: Note:\nOther modules (such as Peptides) may retrieve extra information from the LGrammar file. As such, these modules often include an expanded method for load_grammar_extras_from_file!.\n\nukw: Note:\nThis method is automatically called from load_grammar_from_file. This is the recommended way to load an LGrammar (this method shouldn't be called as a standalone for most applications).\n\nExamples\n\njulia> ProtoSyn.load_grammar_extras_from_file!(ProtoSyn.resource_dir*\"/Peptides/grammars.yml\", \"default\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/builder/#core-builder-2","page":"Builder","title":"Building a molecular structure","text":"","category":"section"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"One of the main goals of an L-Grammar in ProtoSyn is to facilitate building a molecular structure from a sequence by joining together template variables as building blocks. A vector of codes describes the desired structure. In the case of Peptides, for example, this is simply a linear sequence of aminoacids, while more complex structures, such as ramified carbohydrates or glycoproteins might have an equally more complex vector of codes. The following methods explore further on how to use ProtoSyn's L-Grammar system to build new molecular structures from a template libraries.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"@seq_str\nfragment(::LGrammar{T, K, V}, ::Any) where {T <: AbstractFloat, K, V}\nbuild","category":"page"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.@seq_str","page":"Builder","title":"ProtoSyn.@seq_str","text":"@seq_str(s::String)\n\nConstruct a vector of strings from the provided string. Helpful when providing a derivation to any building method (such as build).\n\nShort syntax\n\nseq\"...\"\n\nExamples\n\njulia> seq\"ABC\"\n3-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n\n\n\n\n\n","category":"macro"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.fragment-Union{Tuple{V}, Tuple{K}, Tuple{T}, Tuple{LGrammar{T, K, V}, Any}} where {T<:AbstractFloat, K, V}","page":"Builder","title":"ProtoSyn.fragment","text":"fragment(grammar::LGrammar{T, K, V}, derivation) where {T <: AbstractFloat, K, V}\n\nCreate and return a new Fragment (Pose instance with just a single Segment) using the given derivation sequence on the provided LGrammar grammar instructions. The main purpose of fragments is to be temporary carriers of information, such as during the building process of a new peptide from a sequence. Therefore, these structures often don't have any real meaning and are, as such, deprived of a root/origin for the graph. Actual structures should instead be of the slightly more complete type Pose.\n\nSee also\n\nbuild\n\nExamples\n\njulia> frag = fragment(res_lib, seq\"AAA\")\nFragment(Segment{/UNK:63875}, State{Float64}:\n Size: 30\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.build","page":"Builder","title":"ProtoSyn.build","text":"build(grammar::LGrammar{T}, derivation)\n\nBuild a new Pose instance using the given derivation sequence on the provided LGrammar grammar instructions. Return the generated Pose after synching (using the sync! method).\n\nSee Also\n\nfragment\n\nExamples\n\njulia> res_lib = ProtoSyn.Peptides.grammar;\n\njulia> pose = ProtoSyn.build(res_lib, seq\"GME\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 39\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"Sometimes, an LGrammar may provide multiple tautomers for a single Residue type. By default, when building a peptide from a sequence, ProtoSyn will use the first found tautomer, so the list order is important.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"find_tautomer","category":"page"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.find_tautomer","page":"Builder","title":"ProtoSyn.find_tautomer","text":"find_tautomer(tautomer::Tautomer, target::Residue)\n\nGiven a target Residue, search the provided Tautomer tautomer list for the corresponding template Residue, based on the Graph (employs the travel_graph method).\n\nExamples\n\njulia> tautomer = Peptides.grammar.variables[\"H\"]\nFragment(Segment{/HIE:22535}, State{Float64}:\n Size: 17\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)(And 1 other tautomer(s) available.)\n\njulia> ProtoSyn.find_tautomer(tautomer, pose.graph[1][72])\nFragment(Segment{/HID:3247}, State{Float64}:\n Size: 17\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/builder/#core-builder-3","page":"Builder","title":"Manipulating a molecular structure by adding new residues from templates","text":"","category":"section"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"Once built (or loaded), a molecular structure can be manipulated and changed in various ways. Several methods available to add, modify and remove Residue instances from a molecular structure are discussed in the Methods section (see Appending, inserting and removing Atom and Residue instances). The Builder submodule also includes methods allowing the insertion of template residues from a sequence of vector of codes.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"append_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Any; ::Any)\ninsert_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Any; ::Any, ::Bool)","category":"page"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.append_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Any}","page":"Builder","title":"ProtoSyn.append_fragment!","text":"append_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation; op::Any = \"α\")\n\nBased on the provided grammar, add the residue sequence from derivation to the given Pose pose, appending it after the given Residue residue. This residue and the new Fragment will be connected using operation op (\"α\" by default). Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nSee also\n\ninsert_fragment!\n\nExamples\n\njldoctest julia> ProtoSyn.append_fragment!(pose, pose.graph[1][36], res_lib, seq\"MMM\") Pose{Topology}(Topology{/2a3d:532}, State{Float64}:  Size: 628  i2c: true | c2i: false  Energy: Dict(:Total => Inf) )\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.insert_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Any}","page":"Builder","title":"ProtoSyn.insert_fragment!","text":"insert_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation; op::Any = \"α\", connect_upstream::Bool = true)\n\nBased on the provided grammar, add the residue sequence from derivation to the given pose, inserting it on the position of the given Residue instance residue (the residue gets shifted downstream). The first downstream Residue and the new Fragment will be connected using operation op (\"α\" by default). If connect_upstream is set to true (is, by default), also connect to the upstream Residue instances using the same operation op. Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nSee also\n\nappend_fragment!\n\nExamples\n\njulia> ProtoSyn.unbond!(pose, pose.graph[1][1][\"C\"], pose.graph[1, 2, \"N\"])\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.insert_fragment!(pose, pose.graph[1][2], res_lib, seq\"A\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 353\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"(Image: ProtoSyn Manipulation)","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"Figure 3 | Some examples of the application of molecular manipulation methods: [1] Appending Residue instances at the end of a Segment using the append_fragment! method; [2] Adding Residue instances at the center and [3] at the beggining of an existing Segment, using the insert_fragment! method. In the schematic representation of the molecular structure, R denotes the Topology root.","category":"page"},{"location":"protosyn-api/peptides/calculators/seqdes/","page":"SeqDes model","title":"SeqDes model","text":"CurrentModule = ProtoSyn.Peptides.Calculators.SeqDes","category":"page"},{"location":"protosyn-api/peptides/calculators/seqdes/#SeqDes-model","page":"SeqDes model","title":"SeqDes model","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/seqdes/","page":"SeqDes model","title":"SeqDes model","text":"The SeqDes model Calcualtors module introduces the possibility to employ part of the work by Huang et al. (see this paper) in ProtoSyn. The SeqDes model, in sum, evaluates the current sequence and chi dihedrals in accordance to a trained model on many natural proteins (but generalizable to de novo sequences).","category":"page"},{"location":"protosyn-api/peptides/calculators/seqdes/","page":"SeqDes model","title":"SeqDes model","text":"get_pdb_data\ncalc_seqdes\nget_default_seqdes","category":"page"},{"location":"protosyn-api/peptides/calculators/seqdes/#ProtoSyn.Peptides.Calculators.SeqDes.get_pdb_data","page":"SeqDes model","title":"ProtoSyn.Peptides.Calculators.SeqDes.get_pdb_data","text":"get_pdb_data(pose::Pose, selection::Opt{AbstractSelection} = nothing)\n\nReturns all PDB data necessary for calc_seqdes from the given Pose pose. If an AbstractSelection selection is provided, consider only the selected Atom instances (for Residue level data, since the selection is promoted, any Residue with at least 1 selected Atom is considered).\n\nShould return:\n\natom_coords: N x 3 Vector (atomic positions)\natom_data: N x 4 Vector(atomic data):\n[residue_id, bb_ind, atom_type, residue_type], where residue_id is 0-indexed; bb_ind is either 1 or 0, if the corresponding atom is in the protein backbone or not, respectively; atom_type is the index of the atom element in the Calculators.SeqDes.atom_types dictionary; and residue_type is the index of the residue type in the  Calculators.SeqDes.residue_types dictionary.\nresidue_bb_index: Nr x 4 (atomic index of all backbone atoms + CB)\n[N, CA, C, CB], where all atomic indexes are 0-indexed; for residues without CB, the -1 index is used.\nresidue_data: Dict('chain_code' => Nr x 4) (residue data)\n[residue_id, residue_id_code, residue_index, residue_type], where residue_id_code can be ignored and set to ' ', residue_index is 0-indexed and residue_type is the index of the residue type in the Calculators.SeqDes.residue_types dictionary.\nresidue_label: Nr x 1 (list of residue types)\nchis: Nr x 2 x 4 (chi dihedral angle values)\n[[chi1_v, chi2_v, chi3_v, chi4_v], [chi1, chi2, chi3, chi4]], where chi1_v, chi2_v, etc is the actual dihedral value (in a 4 element array) and chi1, chi2, etc is either 1 or 0, if the corresponding chi dihedral exists or nor, respectively.\n\nukw: Note:\nN is the number of atoms and Nr is the number of residues. Hydrogens (with symbol H) are always ignored.\n\nSee also\n\ncalc_seqdes\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.SeqDes.get_pdb_data(pose)\n(...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/seqdes/#ProtoSyn.Peptides.Calculators.SeqDes.calc_seqdes","page":"SeqDes model","title":"ProtoSyn.Peptides.Calculators.SeqDes.calc_seqdes","text":"calc_seqdes([::Type{ProtoSyn.CUDA_2}], pose::Pose, selection::Opt{AbstractSelection}, [update_forces::Bool = false]; [use_cuda::Bool = true])\n\nCalculates the Pose pose energy in accordance to the SeqDes machine learning model (see https://www.nature.com/articles/s41467-022-28313-9). In sum, this model evaluates the current sequence and chi dihedrals in accordance to a trained model on many natural proteins (but generalizable). If an AbstractSelection selection is given, only the selected Atom instances are considered for the energy calculation. This method does not calculate forces. As such, the update_forces flag has no effect and serves only for standardization purposes between Calculators methods. Currently, this method requires the usage of ProtoSyn.CUDA_2 acceleration type (and setting the use_cuda flag to true). Returns the energy value, nothing (forces), energy per residue and the calculated logits. Note that the calculated logits can be employed in the SeqDes ML model to retrieve rotamers according to the model. Both the energy per residue and logits are returned as PyObject tensors.\n\nSee also\n\nget_default_seqdes\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.SeqDes.calc_seqdes(pose, nothing)\n(13.240120887756348, nothing, PyObject tensor(...), PyObject tensor(...))\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/seqdes/#ProtoSyn.Peptides.Calculators.SeqDes.get_default_seqdes","page":"SeqDes model","title":"ProtoSyn.Peptides.Calculators.SeqDes.get_default_seqdes","text":"get_default_seqdes(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default SeqDes energy EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance, 1.0 by default). This function employs calc_seqdes as the :calc function.\n\nSettings\n\nuse_cuda::Bool - Whether to use CUDA acceleration type. Currently, this EnergyFunctionComponent requires use_cuda to be true.\n\nSee also\n\ncalc_seqdes\n\nExamples\n\n```jldoctest julia> ProtoSyn.Peptides.Calculators.SeqDes.getdefaultseqdes() 🞧  Energy Function Component: +–––––––––––––––––––––––––-+ | Name           | SeqDesMLModel                  | | Alpha (α)      | 1.0                              | | Update forces  | false                            | | Calculator     | calcseqdes                      | +–––––––––––––––––––––––––-+ |    +–––––––––––––––––––––––––––––––––––––––––+ ├──  ● Settings                      | Value                                            | |    +–––––––––––––––––––––––––––––––––––––––––+ |    | usecuda                      | true                                             | |    +–––––––––––––––––––––––––––––––––––––––––+ |     └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/types/#peptides-types","page":"Types","title":"Types","text":"","category":"section"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"The Peptides module introduces one new family of types: the Secondary Structure. In the next section, a more in depth exploration of the usage and utility of each of these types is provided:","category":"page"},{"location":"protosyn-api/peptides/types/#Secondary-Structure","page":"Types","title":"Secondary Structure","text":"","category":"section"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"The following types allow the maintenance of Secondary Structure information (i.e.: the psi, psi and omega backbone angles that result in any given Secondary Structure, such as an alpha helix or a beta sheet, for example). In ProtoSyn, the Secondary Structure dictionary is a collection of SecondaryStructureTemplate instances (one for each secondary structure type). These, in turn, are a colection of DihedralTemplate instances (one for the phi dihedral angle, one for the psi dihedral angle and one for the omega dihedral angle, therefore completly describing the set of dihedrals that form that particular SecondaryStructureTemplate). A DihedralTemplate is a description of a given dihedral around a \"mean\" value (without including \"variation\", methods like setss! apply this \"default\" value) that may optionally include a ramachandran sampler (see show_available_ramachandran_samplers). These samplers, taken from a Ramachandran map, allow a dihedral value to vary while maintaining the natural distribution observed in large databases of proteins. This section also makes available ramachandran potentials, allowing the user to evaluate how \"ramachandran-like\" a given dihedral angle is (see show_available_ramachandran_potentials). ","category":"page"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"show_available_ramachandran_samplers\nshow_available_ramachandran_potentials\nsample_ramachandran\nDihedralTemplate\nSecondaryStructureTemplate\nSecondaryStructure","category":"page"},{"location":"protosyn-api/peptides/types/#ProtoSyn.Peptides.show_available_ramachandran_samplers","page":"Types","title":"ProtoSyn.Peptides.show_available_ramachandran_samplers","text":"show_available_ramachandran_samplers()\n\nPrints all available ramachandran samplers.\n\nSee also\n\nshow_available_ramachandran_potentials()\n\nExamples\n\njulia> ProtoSyn.Peptides.show_available_ramachandran_samplers()\n • 8 ramachandran samplers available:\n ├── ProtoSyn.Peptides.phi_α_R_sampler\n ├── ProtoSyn.Peptides.psi_α_R_sampler\n ├── ProtoSyn.Peptides.phi_α_L_sampler\n ├── ProtoSyn.Peptides.psi_α_L_sampler\n ├── ProtoSyn.Peptides.phi_β_sampler\n ├── ProtoSyn.Peptides.psi_β_sampler\n ├── ProtoSyn.Peptides.phi_coil_sampler\n └── ProtoSyn.Peptides.psi_coil_sampler\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/types/#ProtoSyn.Peptides.show_available_ramachandran_potentials","page":"Types","title":"ProtoSyn.Peptides.show_available_ramachandran_potentials","text":"show_available_ramachandran_potentials()\n\nPrints all available ramachandran potentials.\n\nSee also\n\nshow_available_ramachandran_samplers()\n\nExamples\n\njulia> ProtoSyn.Peptides.show_available_ramachandran_potentials()\n • 8 ramachandran potentials available:\n ├── ProtoSyn.Peptides.phi_α_R_potential\n ├── ProtoSyn.Peptides.psi_α_R_potential\n ├── ProtoSyn.Peptides.phi_α_L_potential\n ├── ProtoSyn.Peptides.psi_α_L_potential\n ├── ProtoSyn.Peptides.phi_β_potential\n ├── ProtoSyn.Peptides.psi_β_potential\n ├── ProtoSyn.Peptides.phi_coil_potential\n └── ProtoSyn.Peptides.psi_coil_potential\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/types/#ProtoSyn.Peptides.sample_ramachandran","page":"Types","title":"ProtoSyn.Peptides.sample_ramachandran","text":"sample_ramachandran(dnp::DiscreteNonParametric; min_prob::T = 0.0) where {T <: AbstractFloat}\n\nSample a dihedral angle from a DiscreteNonParametric dnp distribution. ProtoSyn makes available several ramachandran distributions (for the different backbone dihedral angles & ramachandran zones of interest). Check show_available_ramachandran_samplers for available options. min_prob defines the minimum probability for the returned dihedral angle (higher min_prob values result in more narrow distributions, closer to the ideal and mean value). Returns the dihedral angle value in radians.\n\nExamples\n\njulia> ProtoSyn.Peptides.sample_ramachandran(ProtoSyn.Peptides.psi_coil_sampler)\n0.5934119456780721\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/types/#ProtoSyn.Peptides.DihedralTemplate","page":"Types","title":"ProtoSyn.Peptides.DihedralTemplate","text":"DihedralTemplate{T}(angle::T, [sampler::Opt{DiscreteNonParametric} = nothing]) where {T <: AbstractFloat}\n\nA DihedralTemplate offers a template for a given dihedral type, with a mean value of angle. Optionally, this tempalte can also include a DiscreteNonParametric distribution sampler, which returns angle values with a given variation around the value ideal and mean value. This is used, for example, in methods such as setss!. Note that for standardization purposes, methods in ProtoSyn expect the angle value to be in radians. Optionally, this DihedralTemplate can have a name. This serves no programatically purpose other than differentiation between DihedralTemplate instances by the user.\n\nSee also\n\nSecondaryStructureTemplate\n\nExamples\n\njulia> ProtoSyn.Peptides.SecondaryStructure[:helix].ϕ\n(Dihedral Template)    Phi (ϕ):   -1.117 rad |   -64.00 deg | Sampler: ✓ Set\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/types/#ProtoSyn.Peptides.SecondaryStructureTemplate","page":"Types","title":"ProtoSyn.Peptides.SecondaryStructureTemplate","text":"SecondaryStructureTemplate{T}(ϕ::T, ψ::T, ω::T) where {T <: AbstractFloat}\n\nReturn a new SecondaryStructureTemplate with the given phi ϕ, psi ψ and omega ω backbone angles (in radians) as DihedralTemplate instances.\n\nSee also\n\nSecondaryStructure\n\nExamples\n\njulia> ProtoSyn.Peptides.SecondaryStructure[:helix]\nSecondary Structure Template:\n ├── (Dihedral Template)    Phi (ϕ):   -1.117 rad |   -64.00 deg | Sampler: ✓ Set\n ├── (Dihedral Template)    Psi (ψ):   -0.820 rad |   -47.00 deg | Sampler: ✓ Set\n └── (Dihedral Template)  Omega (ω):    3.142 rad |   180.00 deg | Sampler: ✖ Not set\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/types/#ProtoSyn.Peptides.SecondaryStructure","page":"Types","title":"ProtoSyn.Peptides.SecondaryStructure","text":"SecondaryStructure\n\nThis constant holds default values for common SecondaryStructureTemplate instances: :helix, :linear, :parallel_sheet and :antiparallel_sheet.\n\nExamples\n\njulia> ProtoSyn.Peptides.SecondaryStructure\nDict{Symbol, ProtoSyn.Peptides.SecondaryStructureTemplate} with 5 entries:\n  :antiparallel_sheet => Secondary Structure Template:…\n  :linear             => Secondary Structure Template:…\n  :left_handed_helix  => Secondary Structure Template:…\n  :parallel_sheet     => Secondary Structure Template:…\n  :helix              => Secondary Structure Template:…\n\n\n\n\n\n","category":"constant"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"(Image: ProtoSyn Backbone SS)","category":"page"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"Figure 2 | The default SecondaryStructureTemplate instances in ProtoSyn, defined in the SecondaryStructure dictionary. A SecondaryStructureTemplate can be applied to a Pose, for example, using the setss! method.","category":"page"},{"location":"protosyn-api/peptides/types/#MOVE-THIS","page":"Types","title":"MOVE THIS","text":"","category":"section"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"(Image: ProtoSyn Chi Dihedral Atoms)","category":"page"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"Figure 1 | In ProtoSyn, peptide atoms are named according to the IUPAC and Protein Data Bank nomeculature (see the Atomic Coordinate and Bibliographic Entry Format Description - page 26). As such, in the table above, the names of the representative atoms of each chi angle are shown. These are the atoms returned by the call to the Dihedral auxiliary struct, and can be used in other functions, such as getdihedral or setdihedral!.","category":"page"},{"location":"protosyn-api/peptides/calculators/ss-propensity/","page":"Secondary structure propensity","title":"Secondary structure propensity","text":"CurrentModule = ProtoSyn.Peptides.Calculators","category":"page"},{"location":"protosyn-api/peptides/calculators/ss-propensity/#Secondary-Structure-Propensity","page":"Secondary structure propensity","title":"Secondary Structure Propensity","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/ss-propensity/","page":"Secondary structure propensity","title":"Secondary structure propensity","text":"“Propensity for secondary structures represents an intrinsic property of an amino acid (…)” - Susan Contantini, 2006","category":"page"},{"location":"protosyn-api/peptides/calculators/ss-propensity/","page":"Secondary structure propensity","title":"Secondary structure propensity","text":"The Secondary Structure Propensity Calculators module introduces a measure of how likely a given peptide sequence is based on the natural distribution of aminoacids in nature for the assessed secondary structure, according to Constantini et al. (See this paper).","category":"page"},{"location":"protosyn-api/peptides/calculators/ss-propensity/","page":"Secondary structure propensity","title":"Secondary structure propensity","text":"load_default_aa_ss_propensity\ncalc_aa_ss_propensity\nget_default_aa_ss_propensity\nfixate_secondary_structure!","category":"page"},{"location":"protosyn-api/peptides/calculators/ss-propensity/#ProtoSyn.Peptides.Calculators.load_default_aa_ss_propensity","page":"Secondary structure propensity","title":"ProtoSyn.Peptides.Calculators.load_default_aa_ss_propensity","text":"load_default_aa_ss_propensity([::Type{T}]) where {T <: AbstractFloat}\n\nLoad the default aminoacid secondary structure propensity map from ProtoSyn.Peptides.aa_ss_propensity_filename. Set the values to be of type T (ProtoSyn.Units.defaultFloat, by default). ProtoSyn automatically loads this map to ProtoSyn.Peptides.Calculators.default_aa_ss_propensity during loading. The values are extracted from Contantini et al. work (See https://www.sciencedirect.com/science/article/pii/S0006291X06002543.\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.load_default_aa_ss_propensity()\nDict{Char, Dict{Char, Float64}} with 3 entries:\n  'H' => Dict('P'=>0.50, 'M'=>1.21, 'K'=>1.11, 'F'=>1.01…)\n  'E' => Dict('P'=>0.44, 'M'=>0.99, 'K'=>0.83, 'F'=>1.43…)\n  'C' => Dict('P'=>1.72, 'M'=>0.83, 'K'=>1.00, 'F'=>0.76…)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/ss-propensity/#ProtoSyn.Peptides.Calculators.calc_aa_ss_propensity","page":"Secondary structure propensity","title":"ProtoSyn.Peptides.Calculators.calc_aa_ss_propensity","text":"calc_aa_ss_propensity([::Type{A}], pose::Pose, selection::Opt{AbstractSelection}, update_forces::Bool; [secondary_structure::Union{Function, String} = ProtoSyn.Peptides.categorize_ss_from_dihedral_angles], [aa_ss_propensity_map::Dict{Char, Dict{Char, T}} = default_aa_ss_propensity]) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat}\n\nCalculates the Pose pose energy in accordance to the aa_ss_propensity_map. This map correlates aminoacid nature to secondary structure propensity. The Pose pose secondary structure is given by the secondary_structure argument (either a String using the 3-mode categorization - \"H\" for helix, \"E\" for beta sheets and \"C\" for coils; or a Function that takes the given Pose pose as a single input argument and returns the 3-mode categorization - ProtoSyn.Peptides.categorize_ss_from_dihedral_angles, by default). Read ProtoSyn.Peptides.categorize_ss_from_dihedral_angles documentation for more details on Pose requirements. If an AbstractSelection selection is given, only the selected Residue instances are considered for the energy calculation (any given selection will be promoted to Residue type, see ProtoSyn.promote). This method does not calculate forces. As such, the update_forces flag has no effect and serves only for standardization purposes between Calculators methods. An optional parameter Type{<: AbstractAccelerationType} can be provided, stating the acceleration type used to calculate this energetic contribution (See ProtoSyn acceleration types, if not provided defaults to ProtoSyn.acceleration.active).\n\nukw: Note:\nIn ProtoSyn version 1.1, the ProtoSyn.Peptides.categorize_ss_from_dihedral_angles is notoriously weak. Therefore, manually assigning a secondary structure from a third-party categorization software (such as DSSP) or a ML prediction server (such as RaptorX) is preferable. This may change in future versions of ProtoSyn.\n\nSee also\n\nget_default_aa_ss_propensity\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.calc_aa_ss_propensity(pose, nothing, false)\n(-86.07000000000001, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/ss-propensity/#ProtoSyn.Peptides.Calculators.get_default_aa_ss_propensity","page":"Secondary structure propensity","title":"ProtoSyn.Peptides.Calculators.get_default_aa_ss_propensity","text":"get_default_aa_ss_propensity(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default aminoacid secondary structure propensity energy EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance, 1.0 by default). This function employs calc_aa_ss_propensity as the :calc function.\n\nSettings\n\naa_ss_propensity_map::Dict{Char, Dict{Char, T}} - The secondary structure map, correlates a 3-mode category (\"H\", \"E\" or \"C\") to a propensity value, for each aminoacid type (in 1-letter convention).\nsecondary_structure::Union{Function, String} - The Pose secondary structure, either as a static String or a dynamic funtion that takes a Pose as the single input and returns the secondary structure String.\n\nSee also\n\ncalc_aa_ss_propensity fixate_secondary_structure!\n\nExamples\n\n```jldoctest julia> ProtoSyn.Peptides.Calculators.getdefaultaasspropensity() 🞧  Energy Function Component: +–––––––––––––––––––––––––-+ | Name           | AASSPropensity                 | | Alpha (α)      | 1.0                              | | Update forces  | true                             | | Calculator     | calcaasspropensity            | +–––––––––––––––––––––––––-+  |    +–––––––––––––––––––––––––––––––––––––––––+  ├──  ● Settings                      | Value                                            |  |    +–––––––––––––––––––––––––––––––––––––––––+  |    | aasspropensitymap          | Dict{Char, Dict{Char, Float64}}(3 components)    |  |    | secondarystructure           | categorizessfromdihedral_angles               |  |    +–––––––––––––––––––––––––––––––––––––––––+  |      └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/ss-propensity/#ProtoSyn.Peptides.Calculators.fixate_secondary_structure!","page":"Secondary structure propensity","title":"ProtoSyn.Peptides.Calculators.fixate_secondary_structure!","text":"fixate_secondary_structure!(efc::EnergyFunctionComponent, pose::Pose)\n\nIf the given EnergyFunctionComponent efc is of type AASSPropensity and its current :secondary_structure setting is a dynamic Function, apply this method to the given Pose pose to set a static secondary structure String. This increases the EnergyFunctionComponent efc performace.\n\nSee also\n\nget_default_aa_ss_propensity\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.fixate_secondary_structure!(efc, pose)\n\"CHHHHHHHHHHHHHHHHHHHCCCHHHHHHHHHHHHHHHHHHHHHHCCCHHHHHHHHHHHHHHHHHHHHHHHHC\"\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/introduction/#Materials","page":"Introduction","title":"Materials","text":"","category":"section"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"Besides the Core module, ProtoSyn comes with several other extra modules that build on top of and expand the base methods, types and submodules. These ProtoSyn modules are specific for a given topic. In the case of the Materials module, all new or expanded methods and types explore the topic of atom lattices, MOFs, etc. With this extra constraint, most methods can be especialized.","category":"page"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"In sum, the Materials module makes available several methods, types and submodules specific for atom lattices and other atomic material structures.","category":"page"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"ukw: Note:\n🛠 Under construction. This module is not finished: several bugs and incomplete features can be found. The existing code is provided as is, and should be mainly used for further improvement and development.","category":"page"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"In order to use this module, including the following call is often useful:","category":"page"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn","category":"page"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn.Materials","category":"page"},{"location":"protosyn-api/peptides/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/methods/io/#peptides-io","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"The following methods allow the user to load and export models and data from and to files, and build on top of the Core methods (See Input and Output (IO)). The main different in comparison with the Core module IO methods is the addition of parenthood inference and graph sorting according to IUPAC conventions.","category":"page"},{"location":"protosyn-api/peptides/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"load\ndownload","category":"page"},{"location":"protosyn-api/peptides/methods/io/#ProtoSyn.Peptides.load","page":"Input and Output (IO)","title":"ProtoSyn.Peptides.load","text":"load([::Type{T}], filename::AbstractString; [bonds_by_distance::Bool = false], [alternative_location::String = \"A\"], [include_residues::Vector{String} = Vector{String}()], [ignore_residues::Vector{String} = Vector{String}()], [ignore_chains::Vector{String} = Vector{String}()], [sort_atoms_by_graph::Bool = false]) where {T <: AbstractFloat}\n\nLoad the given filename into a Pose, parametrized by T. If this is not provided, the default ProtoSyn.Units.defaultFloat is used instead. The file format is infered from the extension (See ProtoSyn.supported_formats for all supported formats). If bonds_by_distance is set to true (false, by default), the CONECT records will be complemented with bonds infered by distance. The threshold distances for each pair of atoms is defined in ProtoSyn.bond_lengths. Infers parenthood and ascedence from bonds (N-Residue instances have the connected C-Residue as child). By default, and when available, ProtoSyn will use alternative_location A, unless specified in the flag alternative_location. If the input file if of type PDB and a trajectory, returns a vector of Pose instances instead. If provided, ProtoSyn will ignore any Residue and Segment instances in ignore_residues and ignore_chains, respectivelly (by name). If a Residue instance is not found in ProtoSyn.Peptides.available_aminoacids (for example, a ligand or a non-canonical aminoacid), ProtoSyn will skip setting inter-residue parenthoods. This can be overwritten by adding the Residue name in include_residues, in which case ProtoSyn will attempt to find and established all possible inter-residue parenthood relationships. In more complex cases this should be manually checked. Despite the overall Pose's Graph, Atom order in the encompassing AbstractContainer is, by default, maintained the same as the input filename. This can se re-ordered to match the infered parenthood by setting the sort_atoms_by_graph flag to true (false, by default), in which case the ProtoSyn.sort_atoms_by_graph! method will be used (employing the ProtoSyn.Peptides.IUPAC search algorithm).\n\nukw: Note:\nThis function is an extension of ProtoSyn.load.\n\nExamples\n\njulia> ProtoSyn.Peptides.load(\"1ctf.pdb\", bonds_by_distance = true)\nPose{Topology}(Topology{/2a3d:61708}, State{Float64}:\n Size: 1140\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/io/#Base.download","page":"Input and Output (IO)","title":"Base.download","text":"ProtoSyn.Peptides.download([::Type{T}], pdb_code::String; [bonds_by_distance::Bool = false], [include_residues::Vector{String} = Vector{String}()], [ignore_residues::Vector{String} = Vector{String}()], [ignore_chains::Vector{String} = Vector{String}()], [sort_atoms_by_graph::Bool = true]) where {T <: AbstractFloat}\n\nDownload the PDB file (for the given PDB code) from the RCSB Protein Data Bank into a Pose. The downloaded file can be found in the current working directory. If T is specified, the downloaded file will be loaded into a Pose parametrized by T, otherwise uses the default ProtoSyn.Units.defaultFloat. Uses the specific Peptides.load method. For more information on the input arguments, check the load method documentation.\n\nExamples\n\njulia> ProtoSyn.download(\"2A3D\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/external-packages/","page":"External packages","title":"External packages","text":"CurrentModule = ProtoSyn.Peptides.GMX","category":"page"},{"location":"protosyn-api/peptides/submodules/external-packages/#peptides-external-packages","page":"External packages","title":"External packages","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/external-packages/","page":"External packages","title":"External packages","text":"The External packages is a submodule of ProtoSyn.Peptides module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/peptides/submodules/external-packages/","page":"External packages","title":"External packages","text":"As futher explained in the Core module External packages section, ProtoSyn makes available tools to define and manipulate input structures for common and useful external packages.","category":"page"},{"location":"protosyn-api/peptides/submodules/external-packages/#Gromacs","page":"External packages","title":"Gromacs","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/external-packages/","page":"External packages","title":"External packages","text":"For the Gromacs simulation suite, the Peptides module introduces methods to define .itp files for protein structures, as well as manipulate the Pose graph to match both the Atom names and Atom order expected by Gromacs. ","category":"page"},{"location":"protosyn-api/peptides/submodules/external-packages/","page":"External packages","title":"External packages","text":"generate_gmx_itp\ngenerate_gmx_topology\nsort_atoms_and_graph_gmx!\nGMXS\nassign_gmx_atom_names!\ngenerate_gmx_files","category":"page"},{"location":"protosyn-api/peptides/submodules/external-packages/#ProtoSyn.Peptides.GMX.generate_gmx_itp","page":"External packages","title":"ProtoSyn.Peptides.GMX.generate_gmx_itp","text":"generate_gmx_itp(pose::Pose, [selection::Opt{AbstractSelection} = nothing]; [molecule_itp_filename::String = \"protein.itp\"], [overwrite::Bool = true], [keep_temp_files::Bool = false], [gmx_histidine_type::Int = 0], [gmx_water_model::String = \"tip3p\"], [gmx_forcefield::String = \"amber99sb-ildn\"])\n\nGenerate a protein .itp file for usage in Gromacs using the gmx pdb2gmx utility program with forcefield parameters for the given Pose pose. If an AbstractSelection selection is provided, only the selected Atom instances will be considered (in a Fragment) for .itp generation. Note that since gmx pdb2gmx is being used, non-protein Residue instance may cause problems or undesired parameters in the resulting .itp file. It is reccomended to select protein Residue instances only. The .itp data will be written to molecule_itp_filename (if file exists, setting overwrite to true will overwrite any existing file with the same name, set to true by default). Setting keep_temp_files to true (false, by default) prevents ProtoSyn from deleting any temporary files and directories generated during the method call (this includes Gromacs backups ending with \"#\" and any file or directory starting with \"jl_\"). During gmx pdb2gmx call, automatically sets:\n\nHistidines to be of type gmx_histidine_type (default: 0);\nWater model to be of type gmx_water_model (default: \"tip3p\");\nForcefield to be of type gmx_forcefield (default: \"amber99sb-ildn\").\n\nSee also\n\ngenerate_gmx_topology\n\nExamples\n\njulia> ProtoSyn.Peptides.GMX.generate_gmx_itp(pose)\n✓ All necessary packages were found!\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/external-packages/#ProtoSyn.Peptides.GMX.generate_gmx_topology","page":"External packages","title":"ProtoSyn.Peptides.GMX.generate_gmx_topology","text":"generate_gmx_topology(pose::Pose; [protein_itp_filename::String = \"protein.itp\"], [atomtypes_itp_filename::String = \"atomtypes.itp\"], [molecule_itp_filename::String = \"molecule.itp\"], [overwrite::Bool = true], [keep_temp_files::Bool = false], [gmx_histidine_type::Int = 0], [gmx_water_model::String = \"tip3p\"], [gmx_forcefield::String = \"amber99sb-ildn\"], [topology_filename::String = \"topol.top\"], [include_atomtypes::Bool = false])\n\nGenerate a system .top file for usage in Gromacs (using the gmx pdb2gmx and acpype utility programs) with forcefield parameters for the given Pose pose. This method automatically tries to select protein Residue instances using the ProteinSelection. The selected Residue instances forcefield parameters will be compiled into protein_itp_filename using the gmx pdb2gmx utility program (if file exists, setting overwrite to true will overwrite any existing file with the same name, set to true by default). During gmx pdb2gmx call, automatically sets:\n\nHistidines to be of type gmx_histidine_type (default: 0);\nWater model to be of type gmx_water_model (default: \"tip3p\");\nForcefield to be of type gmx_forcefield (default: \"amber99sb-ildn\").\n\nAny remaining Residue instances will be considered as ligand molecules, and the forcefield information will be compiled into molecule_itp_filename and atomtypes_itp_filename using the acpype utility program. Setting keep_temp_files to true (false, by default) prevents ProtoSyn from deleting any temporary files and directories generated during the method call (this includes Gromacs backups ending with \"#\" and any file or directory starting with \"jl\"). The resulting .itp files are combined into the final `topologyfilename.top file (ifinclude_atomtypesis set totrue, the ligand molecule's atomtypes file is also included in the topology,false` by default).\n\nukw: Note:\nThis method is untested on proteins with multiple ligands and may fail. This may change in future versions of ProtoSyn.\n\nSee also\n\ngenerate_gmx_itp generate_gmx_files\n\nExamples\n\njulia> ProtoSyn.Peptides.GMX.generate_gmx_topology(pose)\n✓ All necessary packages were found!\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/external-packages/#ProtoSyn.Peptides.GMX.sort_atoms_and_graph_gmx!","page":"External packages","title":"ProtoSyn.Peptides.GMX.sort_atoms_and_graph_gmx!","text":"sort_atoms_and_graph_gmx!(pose::Pose)\n\nSorts Atom instances in the encompassing AbstractContainer structures and the resulting Graph for Gromacs simulations (Gromacs expects a given atom order to match with the gmx pdb2gmx and acpype generated .itp and .top files - this does not necessarilly match the IUPAC conventions).\n\nSee also\n\nassign_gmx_atom_names! generate_gmx_files\n\nExamples\n\njulia> ProtoSyn.Peptides.GMX.sort_atoms_and_graph_gmx!(pose)\nPose{Topology}(Topology{/2a3d:60945}, State{Float64}:\n Size: 1140\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/external-packages/#ProtoSyn.Peptides.GMX.GMXS","page":"External packages","title":"ProtoSyn.Peptides.GMX.GMXS","text":"(ProtoSyn.Peptides.GMX.GMXS)(atom::Atom, stack::Vector{Atom})\n\nGromacs-like algorithm for travel_graph. Correctly sorts the given Atom atom children instances and concatenates with the current stack as expected by the Gromacs external package.\n\nExamples\n\njulia> ProtoSyn.Peptides.GMX.GMXS(pose.graph[1, 1, 1], Vector{Atom}())\n4-element Vector{Atom}:\n Atom{/2a3d:34300/A:1/MET:1/H1:2}\n Atom{/2a3d:34300/A:1/MET:1/H2:3}\n Atom{/2a3d:34300/A:1/MET:1/H3:4}\n Atom{/2a3d:34300/A:1/MET:1/CA:5}\n\n\n\n\n\n","category":"constant"},{"location":"protosyn-api/peptides/submodules/external-packages/#ProtoSyn.Peptides.GMX.assign_gmx_atom_names!","page":"External packages","title":"ProtoSyn.Peptides.GMX.assign_gmx_atom_names!","text":"assign_gmx_atom_names!(pose::Pose, selection::Opt{AbstractSelection} = nothing)\n\nRename Atom instances in the given Pose pose to match with the gmx pdb2gmx and acpype generated .itp and .top files - this does not necessarilly match the IUPAC conventions. If an AbstractSelection selection is provided, consider only the selected Atom instances (any given selection will be promoted to be of Atom type - see ProtoSyn.promote).\n\nSee also\n\nassign_default_atom_names! rename! sort_atoms_and_graph_gmx! generate_gmx_files\n\nExamples\n\njulia> ProtoSyn.Peptides.GMX.assign_gmx_atom_names!(pose)\nPose{Topology}(Topology{/2a3d:55318}, State{Float64}:\n Size: 1140\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/external-packages/#ProtoSyn.Peptides.GMX.generate_gmx_files","page":"External packages","title":"ProtoSyn.Peptides.GMX.generate_gmx_files","text":"generate_gmx_files(pose::Pose; protein_itp_filename::String =\"protein.itp\", output_pdb_filename::String =\"system.pdb\", atomtypes_itp_filename::String =\"atomtypes.itp\", molecule_itp_filename::String =\"molecule.itp\", overwrite::Bool =true, keep_temp_files::Bool =false, gmx_histidine_type::Int =0, gmx_water_model::String =\"tip3p\", gmx_forcefield::String =\"amber99sb-ildn\", topology_filename::String =\"topol.top\", include_atomtypes::Bool =false)\n\nGenerate all the necessary files to launch a Gromacs MD simulation (.top, .itp and correctly ordered/named .pdb files). For topology generation, please check generate_gmx_topology documentation: all arguments used in that method are also input arguments of this one. For .pdb generation, ProtoSyn attempts to sort (using sort_atoms_and_graph_gmx!) and rename (using assign_gmx_atom_names!) Atom instances in accordance to the expected values in Gromacs before exporting the given Pose pose to a output_pdb_filename file. Check these methods documentation for more details.\n\nExamples\n\njulia> ProtoSyn.Peptides.GMX.generate_gmx_files(pose)\n✓ All necessary packages were found!\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"CurrentModule = ProtoSyn.Calculators","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#Calculators-section","page":"Calculators Section","title":"Calculators section","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Each module in ProtoSyn may contain a Calculators section which includes types and methods that allow ProtoSyn to measure the fitness of a given State, according to a specific EnergyFunction instance. The resulting energy value is stored in the State.e field, as a Dictionary of EnergyFunctionComponent instances. The :total energy of the system is the sum of each component contribution. Each module in ProtoSyn (such as the Peptides module) adds new components and methods specific to that module's purpose. As a starting point, the Core module sets up all necessary types and methods transversal to all modules, as well as a few basic energetic components. In the next section, a further exploration on how to develop and set-up custom EnergyFunction instances is provided, organized in the following sections:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Energy functions & energy function components\nCreating a custom EnergyFunctionComponent\nProtoSyn acceleration types\nVerlet lists\nDistance matrix calculation\nAvailable EnergyFunctionComponents","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#Energy-functions-and-energy-function-components","page":"Calculators Section","title":"Energy functions & energy function components","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"An EnergyFunction is the main high-level object of ProtoSyn for energy calculation of a Pose instance, whose building blocks are the EnergyFunctionComponent instances.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Calculators.EnergyFunctionComponent\nCalculators.EnergyFunction","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent","page":"Calculators Section","title":"ProtoSyn.Calculators.EnergyFunctionComponent","text":"EnergyFunctionComponent(name::String, calc::Function, settings::Dict{Symbol, Any}, α::T, update_forces::Bool)\n\nReturn a new EnergyFunctionComponent instance with the given name. An EnergyFunctionComponent object is responsible to calculate an energetic contribution to the system, based on a given interaction, model or restraint (for example, a Bond Distance Restraint is responsible to calculate the energetic contribution by bonds with lengths superior to a given threshold). The :total energy of a Pose is, therefore, the sum of all EnergyFunctionComponent applied in a given calculation. Each  EnergyFunctionComponent has a calc Function that receives a Pose and outputs an energy value. Optionally, this calc Function can also return a set of forces felt on all considered atoms, based on the potential or model used, which is calculated if the update_forces flag is set to true. For a more detailed explanation see the Creating a custom EnergyFunctionComponent section of the documentation). Additionally, certain EnergyFunctionComponent instances can have a settings dictionary, containing kwargs that are passed to the calc Function. These usually parametrize and fine tune the calculations perform (such as setting the flat bottom restraint distances, as an example). When calling an EnergyFunctionComponent calculation from an EnergyFunction, the relative weight of this EnergyFunctionComponent in relation to others is given by the α field.\n\nFields\n\nname::String - The name of this EnergyFunctionComponent. Used to index by name when in an EnergyFunction;\ncalc::Function - The calculation Function used to calculate this contribution;\nsettings::Dict{Symbol, Any} - (Optional) A dictionary of kwargs provided to the calc Function, parameterizing its usage;\nα::T - The relative weight of this EnergyFunctionComponent when in an EnergyFunction;\nupdate_forces::Bool - Toggle forces calculation by this EnergyFunctionComponent when in an EnergyFunction. \n\nSee also\n\nEnergyFunction\n\nExamples\n\njulia> ProtoSyn.Calculators.Restraints.get_default_bond_distance_restraint()\n         Name : Bond_Distance_Restraint\n   Weight (α) : 1.0\nUpdate forces : true\n      Setings :\n          :x0 => 2.0\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.EnergyFunction","page":"Calculators Section","title":"ProtoSyn.Calculators.EnergyFunction","text":"EnergyFunction(components::Vector{EnergyFunctionComponent}, clean_cache_every::Int16, cache::Int16, components_by_name::Dict{String, Int}, selection::AbstractSelection, update_forces::Bool)\n\nConstruct and return a new EnergyFunction instance. An EnergyFunction is a collection of EnergyFunctionComponent instances, where each of these components calculates an energetic contribution to the :total energy and forces acting on a system. An EnergyFunctionComponent can be retrieved by its index or by its name (as saved in components_by_name). The AbstractSelection selection defines the Atom selection this EnergyFunction is applied to. If  inner EnergyFunctionComponent instances also have AbstractSelection selections defined, the resulting selection will be the intersection between  both. The update_forces sets whether to calculate and update the Pose State forces. The Julia cache is automatically cleaned by garbage collection. However, in certain cases (such as using the TorchANI EnergyFunctionComponent), a manual call to garbage collection is necessary (see Issue 55140). In such cases, the EnergyFunction object has an internal cache that is cleaned (by calling garbage collection) at intervals of clean_cache_every calls. This interval is automatically adjusted down by measuring the current load on the GPU, calling garbage collection once the memory allocation is greater than ProtoSyn.Units.max_gpu_allocation.\n\nEnergyFunction([::Type{T}])\n\nConstruct and return an empty EnergyFunction instance. The :clean_cache_every field is set to ProtoSyn.Units.defaultCleanCacheEvery,  the AbstractSelection selection field is defined as an atomic TrueSelection and update_forces is set to false.\n\nEnergyFunction(components::Vector{EnergyFunctionComponent{T}}) where {T <: AbstractFloat}\n\nConstruct and return a new EnergyFunction instance filled with the given list of EnergyFunctionComponent instances components. The :clean_cache_every field is set to ProtoSyn.Units.defaultCleanCacheEvery, the AbstractSelection selection field is defined as an atomic TrueSelection and update_forces is set to false.\n\nFields\n\ncomponents::Vector{EnergyFunctionComponent} - The list of EnergyFunctionComponent instances in this EnergyFunction;\nclean_cache_every::Int16 - Forcefully call garbage collection every N calls;\ncache::Int16 - Current number of calls performed. Resets to zero every clean_cache_every;\ncomponents_by_name::Dict{String, Int} - The list of EnergyFunctionComponent instances in this EnergyFunction, indexed by :name;\nselection::AbstractSelection - The AbstractSelection selecting Atom instances to apply this EnergyFunction to;\nupdate_forces::Bool - Whether to calculate and update forces with this EnergyFunction.\n\nSee also\n\nEnergyFunctionComponent\n\nExamples\n\njulia> energy_function = ProtoSyn.Calculators.EnergyFunction()\n🗲  Energy Function (0 components):\n+----------------------------------------------------------------------+\n| Index | Component name                                | Weight (α)   |\n+----------------------------------------------------------------------+\n+----------------------------------------------------------------------+\n ● Update forces: false\n ● Selection: Set\n └── TrueSelection (Atom)\n\njulia> push!(energy_function, Calculators.Restraints.get_default_bond_distance_restraint())\n🗲  Energy Function (1 components):\n+----------------------------------------------------------------------+\n| Index | Component name                                | Weight (α)   |\n+----------------------------------------------------------------------+\n| 1     | Bond_Distance_Rest                            |      1.000   |\n+----------------------------------------------------------------------+\n ● Update forces: false\n ● Selection: Set\n └── TrueSelection (Atom)\n\n julia> energy_function[\"Bond_Distance_Rest\"].α = 0.5\n 0.5\n\njulia> energy_function\n🗲  Energy Function (1 components):\n+----------------------------------------------------------------------+\n| Index | Component name                                | Weight (α)   |\n+----------------------------------------------------------------------+\n| 1     | Bond_Distance_Rest                            |      0.500   |\n+----------------------------------------------------------------------+\n ● Update forces: false\n ● Selection: Set\n └── TrueSelection (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"An EnergyFunction instance is actually a functor, meaning it is callable in order to apply any energy function type to any Pose instance, using the following signature:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"(energy_function::EnergyFunction)(pose::Pose, update_forces::Bool = false)","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"An application example is provided bellow, using the TorchANI model as the sole EnergyFunctionComponent:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"using ProtoSyn\nusing ProtoSyn.Peptides\nusing ProtoSyn.Calculators\npose = ProtoSyn.build(Peptides.grammar, seq\"GME\")\ntorchani = Calculators.TorchANI.get_default_torchani_model()\nenergy_function = Calculators.EnergyFunction([torchani])\nenergy_function(pose)","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"torchani = Calculators.TorchANI.get_default_torchani_model()\nenergy_function = Calculators.EnergyFunction([torchani])\nenergy_function(pose)\nenergy_function(pose, true) # Calculating forces ...\npose.state.f","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"(Image: ProtoSyn Energy Function)","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Figure 1 | A diagram representation of the EnergyFunction organization as a set of EnergyFunctionComponent instances. Each component contribution is summed to evaluate the :total energy of the system, according to each component's scaling factor ɑ (in this example, 1.0 for the TorchANI Ensemble EnergyFunctionComponent and 0.8 for the Contact Map EnergyFunctionComponent). Some components may be able to calculate the set of forces acting on each atom of the system, in which case this contribution can be toggled on and off by the :update_forces flag. Furthermore, each component may be parametrized by a set of options. In this example, the Contact Map EnergyFunctionComponent can be further parametrized by setting the :d1, :d2, :d3 and :d4 values (controlling the flat bottom restraint potential), as well as the :selection on which to act and the :mask applied. Such settings are specific to each type of EnergyFunctionComponent and are explored in detail in each entry in this manual.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#Creating-a-custom-EnergyFunctionComponent","page":"Calculators Section","title":"Creating a custom EnergyFunctionComponent","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"As stated before, an EnergyFunctionComponent is mostly a smart wrapper around a :calc Function responsible for calculating a given energetic contribution based on a specific method, model or restraint type (as an example). Therefore, when developing custom EnergyFunctionComponent instances, certain aspects need to be taken into consideration. The following section lists particular restraints when creating custom EnergyFunctionComponent instances.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"The :calc Function signature:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"When being called from an EnergyFunction instance, ProtoSyn expects the following calc Function signature.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"calc(::A, pose::Pose, sele::Opt{AbstractSelection}, update_forces::Bool = false; kwarg1::Type{kwarg1} = default_value1, kwarg2::Type{kwarg2} = default_value2, ...) where {A <: ProtoSyn.AbstractAccelerationType}","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"The ::A (see the ProtoSyn acceleration types section), pose::Pose, sele::AbstractSelection and update_forces::Bool = false arguments are necessary and expected. Optionally, these can be followed by a variable number of arguments (kwargs), parameterizing and fine-tuning the usage of the calc Function. When calling this EnergyFunctionComponent from an EnergyFunction, these kwargs are passed from the EnergyFunctionComponent.settings dictionary, and can therefore be automatically and continuously adjusted in a simulation. Since it may happen that one or more kwargs may not be defined in the EnergyFunctionComponent.settings, defining a default value for each of the kwargs is considered a good practice when creating a custom EnergyFunctionComponent.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Example of potential :calc functions:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"# Without restricting the acceleration type\nfunction my_calc(::A, pose, sele::Opt{AbstractSelection}, update_forces::Bool) where {A <: ProtoSyn.AbstractAccelerationType}\n    (...)\nend\n\n# Restricting the acceleration type and defining additional settings (with default values)\nfunction my_calc(::ProtoSyn.CUDA_2, pose::Pose, sele::Opt{AbstractSelection}, update_forces::Bool; d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf, mask::MaskMap = nothing) where {T <: AbstractFloat}\n    (...)\nend","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"the :calc function returning values:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"ProtoSyn expects the :calc function to return 2 objects: firstly, the energy value, as an AbstractFloat (Float64, for example), and secondly, a Matrix of forces acting on the system. If a particular EnergyFunctionComponent does not calculate forces, it can optionally return nothing. Any extra returning values besides these (as long as these are the first, in this order), can be returned but will be ignored in the context of an EnergyFunction.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"function my_calc(::A, pose, sele::Opt{AbstractSelection}, update_forces::Bool) where {A <: ProtoSyn.AbstractAccelerationType}\n    (...)\n    return energy, forces\nend","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"The EnergyFunctionComponent.settings field","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"As previously stated, the EnergyFunctionComponent.settings are optional. If present, these are passed to the EnergyFunctionComponent.calc Function as kwargs, and therefore should match and have the same name (as a Symbol instead). This allows for easy access and modification of internal parameters of the calculation on the fly.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Examples:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Dict{Symbol, Any}(:d1 => 1.0, :d2 => 3.0, :d3 => Inf, :d4 => Inf, :mask => Calculators.get_diagonal_mask(pose, an\"C\"))","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn-acceleration-types","page":"Calculators Section","title":"ProtoSyn acceleration types","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Certain EnergyFunctionComponent instances in ProtoSyn require specific software and hardware on the machine performing the calculation, or at least have specific implementations of the code based on the availability or not of said features (for example, certain functions have specific implementations for CUDA and GPU acceleration). For this reason, ProtoSyn defines 3 levels of acceleration (3 different acceleration types, loosely based on Flynn's Taxonomy):","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"SISD_0 - Single Instruction Single Data: uses CPU, should work on most modern processors;\nSIMD_1 - Single Instruction Multiple Data: uses CPU, parallelizes a single instruction in a vector of data, available in modern processors with MMX, SSE and AVX/AVX-512 technologies, among others;\nCUDA_2 - Compute Unified Device Architecture: parallel computing platform and API enabling GPU acceleration of code. If CUDA is available, this is the default acceleration type set up in ProtoSyn.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"At start-up, ProtoSyn tries to identify the available software and hardware available and sets the fastest acceleration type possible as ProtoSyn.acceleration.active. This can, however, be overridden:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"ProtoSyn.acceleration.active\nProtoSyn.acceleration.active = ProtoSyn.SIMD_1","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#Verlet-lists","page":"Calculators Section","title":"Verlet lists","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"A Verlet list is a common data structure in molecular manipulation and simulation softwares that maintains a list of particles inside a given cut-off distance to eachother. The main objective of Verlet lists is to speed up calculations by ignoring most of the long-distance interactions between Atom instances, as these would have negligent effects in the simulation, while reducing the amount of memory allocated as a whole. Note that, given the movement and displacement of Atom instances in a simulation, this list rapidly becomes obsolete and needs to be re-updated.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Calculators.VerletList\nCalculators.update!","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.VerletList","page":"Calculators Section","title":"ProtoSyn.Calculators.VerletList","text":"VerletList(size::Int, capacity::Int, cutoff::Float64, offset::Vector{Int}, list::Vector{Int})\n\nHold information regarding the neighbouring particles of each particle in the system (with number of particles size). A VerletList is comprised of two arrays: the list, containing the neighbouring atoms j of atom i, with sequential atoms divided by an invalid -1 entry; and the offset array, containing the positions in array list for each atom i. Neighbouring atoms are defined as having a distance bellow the defined cutoff. The main objective of a VerletList is to speed up calculations (by ignoring long-range interactions between Atom instances) and to lower the total amount of memory allocated (the number of allocated Atom entries is at most the capacity of the VerletList). Note that, given the motion of particles in a simulation, a VerletList can quickly become obsolete, and needs to be updated using update!.\n\nVerletList(size::Int)\n\nCreates a new VerletList with infinite cutoff (holds all atoms in the molecule).\n\nVerletList(pose::Pose)\n\nCreates a new VerletList with infinite cutoff (holds all atoms in the Pose).\n\nFields\n\nsize::Int - The number of Atom instances this VerletList makes reference to. Should be the size of :offset field;\ncapacity::Int - Maximum number of interaction pairs listed in this VerletList; \ncutoff::Float64 - Interactions are considered when the distance between two Atom instances is less than this value;\noffset::Vector{Int} - Vector with the starting index for the neighbouring Atom.id entries in the :list field;\nlist::Vector{Int} - Vector with the neighbouring Atom.id entries, in sectors separated by invalid entries (such as -1).\n\nSee also\n\nupdate! distance\n\nExamples\n\njulia> ProtoSyn.Calculators.VerletList(4)\nProtoSyn.Calculators.VerletList(4, 4, Inf, [0, 0, 0, 0], [0, 0, 0, 0])\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.update!","page":"Calculators Section","title":"ProtoSyn.Calculators.update!","text":"update!([::Type{ProtoSyn.SISD_0}], verlet_list::VerletList, pose::Pose, [selection::Opt{ProtoSyn.AbstractSelection} = nothing])\nupdate!([::Type{ProtoSyn.SIMD_1}], verlet_list::VerletList, pose::Pose, [selection::Opt{ProtoSyn.AbstractSelection} = nothing])\n\nUpdates the given VerletList (using a SISD_0 or SIMD_1 acceleration approach) according to the defined 'verlet_list.cutoff' and the given coordinates in the Pose pose (in AoS format). If the acceletarion type is not given, the default ProtoSyn.acceleration.active is employed. If an AbstractSelection selection is provided, only include the pair of Atom instances as interacting, in the VerletList, if both instances are selected. \n\nExamples\n\njulia> ProtoSyn.Calculators.update!(verlet_list, pose)\n    ...\n\njulia> ProtoSyn.Calculators.update!(verlet_list, pose, an\"CA\")\n    ...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"(Image: ProtoSyn Verlet List)","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Figure 2 | A diagram representation of the VerletList organization. Usually, a VerletList is comprised of two arrays: the :list and the :offset. The :offset vector contains 1 entry for each Atom instance in a given Pose, whose Atom.id is the index of the vector. The actual content of the vector is an index on the :list array, defining the starting point from which to read this vector in order to find all the Atom instances intercating with the currently selected Atom. As such, the :list vector is a collection of Atom.id records, with contiguous sectors separated by invalid entries (such as -1). Each one of these contigous sectors is a collection of Atom.id values belonging to the Atom instances that interact with a common Atom. As an example, consider the represented schematic. The considered range of interactions is represnted in light grey, with radius a and centered on the selected Atom 2. As such, the Atom instances 5, 9 and 12 are inside the interaction radius, and should be considered for measurement. In the accompanying VerletList, index 2 in the :offset vector contains value 4. By reading the :list vector starting at index 4 (as indicated by the :offset vector) until an invalid position is found (such as -1), Atom.id 5, 9 and 12 are found. In the same schematic, the dashed grey line indicates a \"moving cut-off\". It's a common practice in the usage of VerletList instances to accomodate Atom movement in a simulation environment, in order to reduce the number of times the VerletList needs to be updated. In this case, radius b is added to the VerletList.cutoff, and should be equal to N x 2 x MD (where N is the number of steps before re-updating the VerletList and MD is the maximum displacement an Atom is allowed or expected to suffer each step of the simulation). Using this approach, Atom 1 (in the example) should be included in the :list vector, at the contiguous sector related to Atom 2.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"ukw: Note:\nAs of ProtoSyn 1.1, VerletList instances are only employable in distance calculations using distance_matrix methods. However, the underlying mechanisms of VerletList data structures can be useful elsewhere and are planned to be incorporated in default EnergyFunctionComponent instances in the future.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#Distance-matrix-calculation","page":"Calculators Section","title":"Distance matrix calculation","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"As previously stated, the Calculators section in Core exists mainly to set-up types and methods transversal to all ProtoSyn's Calculators in different modules (such as Peptides). One such method commonly employed in energy calculations is the ability to measure distance matrices. A distance matrix is a 2D matrix whose entries are the distance between the X and Y Atom, usually considering only the top triangular matrix. A full distance matrix can also be useful, as is available by using the full_distance_matrix method.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Calculators.distance_matrix\nCalculators.full_distance_matrix","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.distance_matrix","page":"Calculators Section","title":"ProtoSyn.Calculators.distance_matrix","text":"Calculators.distance_matrix([::A], coords::Matrix{T}) where {A, T <: AbstractFloat}\nCalculators.distance_matrix([::A], state::State{T}) where {A, T <: AbstractFloat}\nCalculators.distance_matrix([::A], pose::Pose) where {A}\n\nReturn a distance matrix with the distance of all pairs of coordinates in coords (this should be a Matrix{T} in AoS format) above the triangular matrix. Instead of a Matrix{T} coords, a State or Pose can be provided, in which case the coordinates considered are all the existent in the State or Pose.state, respectively. The optional A parameter defines the acceleration mode used (SISD_0, SIMD_1 or CUDA_2). If left undefined the default ProtoSyn.acceleration.active mode will be used. Note: Make sure the given Pose pose in synched (using the sync! method).\n\nCalculators.distance_matrix([::A], pose::Pose, selection::ProtoSyn.AbstractSelection)\n\nReturn a distance matrix with the distance of all pairs of atoms in the Pose pose who are selected in the given AbstractSelection selection and above the triangular matrix. The optional A parameter defines the acceleration mode used (SISD_0, SIMD_1 or CUDA_2). If left undefined the default ProtoSyn.acceleration.active mode will be used.\n\nCalculators.distance_matrix([::A], coords::Matrix{T}, verlet_list::VerletList) where {T <: AbstractFloat}\nCalculators.distance_matrix([::A], state::State{T}, verlet_list::VerletList) where {T <: AbstractFloat}\nCalculators.distance_matrix([::A], pose::Pose, verlet_list::VerletList)\n\nReturn a top triangular distance matrix with the distance of all pairs of coordinates in the VerletList verlet_list. Instead of a Matrix{T} coords, a State or Pose can be provided, in which case the coordinates considered are existent in the State or Pose.state, respectively. The optional A parameter defines the acceleration mode used (SISD_0, SIMD_1). If left undefined the default ProtoSyn.acceleration.active mode will be used. Note: Using VerletList, CUDA_2 acceleration mode is not available. If the default ProtoSyn.acceleration.active is set to CUDA_2, SIMD_1 will be used instead.\n\nukw: Note:\nAbstractSelections can still be applied when using VerletList instances, but need to be applied when updating the lists themselves. Check VerletList and update! entries for a more in-depth look at how Verlet lists work.\n\nSee also\n\nfull_distance_matrix\n\nExamples\n\njulia> ProtoSyn.Calculators.distance_matrix(pose.state.x)\nN×N CUDA.CuArray{Float64,2}:\n    ...\n\njulia> ProtoSyn.Calculators.distance_matrix(pose, an\"CA\")\nN×N CUDA.CuArray{Float64,2}:\n    ...\n\njulia> ProtoSyn.Calculators.distance_matrix(pose, verlet_list)\nN×N CUDA.CuArray{Float64,2}:\n    ...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.full_distance_matrix","page":"Calculators Section","title":"ProtoSyn.Calculators.full_distance_matrix","text":"Calculators.full_distance_matrix([::A], coords::Matrix{T}) where {A, T <: AbstractFloat}\nCalculators.full_distance_matrix([::A], state::State{T}) where {A, T <: AbstractFloat}\nCalculators.full_distance_matrix([::A], pose::Pose) where {A}\n\nReturn a distance matrix with the distance of all pairs of coordinates in coords (this should be a Matrix{T} in AoS format). Instead of a Matrix{T} coords, a State or Pose can be provided, in which case the coordinates considered are all the existent in the State or Pose.state, respectively. The optional A parameter defines the acceleration mode used (SISD_0, SIMD_1 or CUDA_2). If left undefined the default ProtoSyn.acceleration.active mode will be used.\n\nCalculators.full_distance_matrix([::A], pose::Pose, selection::ProtoSyn.AbstractSelection)\n\nReturn a distance matrix with the distance of all pairs of atoms in the Pose pose who are selected in the given AbstractSelection selection. The optional A parameter defines the acceleration mode used (SISD_0, SIMD_1 or CUDA_2). If left undefined the default ProtoSyn.acceleration.active mode will be used.\n\nSee also\n\ndistance_matrix\n\nExamples\n\njulia> ProtoSyn.Calculators.full_distance_matrix(pose.state.x)\nN×N CUDA.CuArray{Float64,2}:\n ...\n\njulia> ProtoSyn.Calculators.distance_matrix(pose, an\"CA\")\nN×N CUDA.CuArray{Float64,2}:\n ...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/calculators-section/#Available-EnergyFunctionComponents","page":"Calculators Section","title":"Available EnergyFunctionComponents","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Besides all the machinery to create custom energy components, ProtoSyn's Core module makes available some simple EnergyFunctionComponent instances. Since this is not a specialized module, available components should be indiferent to the type of molecular structure being evaluated. For a compelte list of all available EnergyFunctionComponent instances, consider using the show_available_energy_function_components method.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"show_available_energy_function_components","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.show_available_energy_function_components","page":"Calculators Section","title":"ProtoSyn.Calculators.show_available_energy_function_components","text":"show_available_energy_function_components([io::IO = stdout], [m::Module = ProtoSyn.Calculators])\n\nPrints all available EnergyFunctionComponent instances in the provided Module m (defaults to ProtoSyn.Calculators) to the given IO io (defaults to stdout). Recursivelly searches any inner Module.\n\nSee also\n\nget_available_energy_function_components\n\nExamples\n\njulia> ProtoSyn.Calculators.show_available_energy_function_components(ProtoSyn.Calculators)\n+------------------------------------------------------------------------------------------------+\n| Index | Component name            | Function                                                   |\n+------------------------------------------------------------------------------------------------+\n| 1     | Custom_Ref_Energy         | ProtoSyn.Calculators.get_default_custom_ref_energy         |\n| 2     | Coulomb                   | ProtoSyn.Calculators.Electrostatics.get_default_coulomb    |\n| 3     | GB_Solvation              | ProtoSyn.Calculators.GB.get_default_gb                     |\n+------------------------------------------------------------------------------------------------+\n└── Consider using the `?` menu to learn more about each EnergyFunctionComponent.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"As of ProtoSyn 1.1, the following EnergyFunctionComponent instances are made available from the Core module, and can be further explored in the respectivelly dedicated pages of this manual:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Bond Distance Restraint\nPotential restraints\nTorchANI (And TorchANI reference energy EnergyFunctionComponent)\nElectrostatics\nGeneralized Born Solvation\nSASA\nHydrogen bonds\nRadius of gyration\nCustom reference energy\nREF-15","category":"page"},{"location":"protosyn-api/core/drivers/drivers-ils/","page":"ILS","title":"ILS","text":"CurrentModule = ProtoSyn.Drivers","category":"page"},{"location":"protosyn-api/core/drivers/drivers-ils/#ILS-Driver","page":"ILS","title":"ILS Driver","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-ils/","page":"ILS","title":"ILS","text":"The ILS Driver performs the Iterated Local Search algorithm, introducing a large conformational change in between local optimization runs.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-ils/","page":"ILS","title":"ILS","text":"ILS\nILSState","category":"page"},{"location":"protosyn-api/core/drivers/drivers-ils/#ProtoSyn.Drivers.ILS","page":"ILS","title":"ProtoSyn.Drivers.ILS","text":"ILS(eval!::Union{Function, EnergyFunction}, jump!::Union{Function, AbstractMutator, Driver}, inner_driver!::Driver, callback::Opt{Callback}, max_steps::Int, temperature::Function)\n\nAn ILS Driver instance. As such, this object is callable as a functor with the following signature:\n\n(driver::ILS)(pose::Pose)\n\nThis simulation performs an Iterated Local Search algorithm. In this type of simulation, an inner_driver! takes the system from a state to another, possibly optimizing the structure into a local minimum. As an example, this can be a MonteCarlo or a SteepestDescent Driver. The resulting structure is evaluated (according to an eval! EnergyFunction instance or custom function) and accepted or rejected according to the Metropolis Criterion, based on the current temperature of the simulation (see MonteCarlo for more information regarding the Metropolis Criterion). In either case, the accepted structure or the recovered previous state structure is subjected to a jump!, that is, a large conformational change, taking the system to a new conformational space. This simulation loop runs for max_steps iteration. Each step, a call to an optional Callback callback is performed. A companion ILSState DriverState instance is also updated each step and provided to the Callback callback.\n\nFields\n\neval!::Union{Function, EnergyFunction} - The evaluator EnergyFunction or custom function, receives a Pose pose as the single argument;\njump!::Union{Function, AbstractMutator, Driver} - The jump method, receives a Pose pose as the single input argument, should introduce a relative high change in the conformation;\ninner_driver!::Driver - The inner loop Driver;\ncallback::Opt{Callback} - An optional Callback instance for the outer loop, receives two input arguments: the current Pose pose and the current DriverState driver_state;\nmax_steps::Int - The total number of simulation steps to be performed in the outer loop;\ntemperature::Function - The temperature function thermostat for the outer loop (see Available thermostats), receives the current step (as an Int) as the single input argument.\n\nSee also\n\nILSState\n\nExamples\n\njulia> ils = ProtoSyn.Drivers.ILS(energy_function, dihedral_mutator, monte_carlo, cb, 1000, ProtoSyn.Drivers.get_linear_quench(1.0, 1000))\n⚒  ILS Driver:\n ├──  ●  Evaluator:\n |    └── 🗲  Energy Function (4 components):\n |        +----------------------------------------------------------------------+\n |        | Index | Component name                                | Weight (α)   |\n |        +----------------------------------------------------------------------+\n |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |        +----------------------------------------------------------------------+\n |   \n ├──  ● Jump:\n |    └── ⚯  Dihedral Mutator:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                       | Value                          |\n |        +----------------------------------------------------------------------+\n |        | 1     | angle_sampler               | Function randn                 |\n |        | 2     | p_mut                       | 0.0100                         |\n |        | 3     | step_size                   | 0.5000                         |\n |        +----------------------------------------------------------------------+\n |         ● Selection: Set\n |         └── FieldSelection › Atom.name = r\"C|N\"\n |   \n ├──  ● Inner Driver:\n |    └── ⚒  Monte Carlo Driver:\n |         ├──  ●  Evaluator:\n |         |    └── 🗲  Energy Function (4 components):\n |         |        +----------------------------------------------------------------------+\n |         |        | Index | Component name                                | Weight (α)   |\n |         |        +----------------------------------------------------------------------+\n |         |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |         |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |         |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |         |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |         |        +----------------------------------------------------------------------+\n |         |   \n |         ├──  ● Sampler:\n |         |    └── ⚯  Dihedral Mutator:\n |         |        +----------------------------------------------------------------------+\n |         |        | Index | Field                       | Value                          |\n |         |        +----------------------------------------------------------------------+\n |         |        | 1     | angle_sampler               | Function randn                 |\n |         |        | 2     | p_mut                       | 0.0100                         |\n |         |        | 3     | step_size                   | 0.5000                         |\n |         |        +----------------------------------------------------------------------+\n |         |         ● Selection: Set\n |         |         └── FieldSelection › Atom.name = r\"C|N\"\n |         |   \n |         ├──  ○  Callback: Not set\n |         |   \n |         └──  ● Settings:\n |               Max steps: 10\n |             Temperature: linear_quench\n |   \n ├──  ● Callback:\n |    └── ✉  Callback:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                     | Value                            |\n |        +----------------------------------------------------------------------+\n |        | 1     | Event                     | energy_step_frame                |\n |        | 2     | Frequency                 | 10                               |\n |        +----------------------------------------------------------------------+\n |   \n └──  ● Settings:\n       Max steps: 1000\n     Temperature: linear_quench\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-ils/#ProtoSyn.Drivers.ILSState","page":"ILS","title":"ProtoSyn.Drivers.ILSState","text":"ILSState{T <: AbstractFloat}(step::Int = 0, converged::Bool = false, completed::Bool = false, stalled::Bool = false, acceptance_count = 0, temperature::T = T(0.0))\nILSState{T <: AbstractFloat}()\n\nA ILSState instance is a DriverState that keeps track of a ILS simulation status. Besides the default :step, :converged, :completed and :stalled fields, a ILSState instance adds the following tracking fields specific for ILS simulations:\n\nacceptance_count::Int - The number of accepted Pose changes by the Metropolis criterion;\ntemperature::T - The current temperature of the simulation.\n\nSee also\n\nILS\n\nExamples\n\njulia> ProtoSyn.Drivers.ILSState{Float64}()\nProtoSyn.Drivers.ILSState{Float64}(0, false, false, false, 0, 0.0)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-ils/","page":"ILS","title":"ILS","text":"(Image: ProtoSyn ils-driver)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-ils/","page":"ILS","title":"ILS","text":"Figure 1 | A schematic overview of the different stages in a ILS Driver: (1) - A jump! introduces a relative large conformational change into the system's structure, taking the Pose into a new conformational space; (2) - An inner_driver! optimizes the new structure, finding new local minima.","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"CurrentModule = ProtoSyn.Calculators.GB","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/#Generalized-Born-Solvation","page":"Generalized Born","title":"Generalized Born Solvation","text":"","category":"section"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"The Generalized Born (GB) solvation model attempts to approximate the Poisson-Boltzmann equation, using the following equation:","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"- frac12left ( frac1varepsilon_protein -frac1varepsilon_solvent  right ) sum_ij^Nfracq_iq_jf_GB","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"f_GB = sqrtd_ij^2 + left ( alpha_ialpha_j e^-fracd_ij4alpha_ialpha_j right)","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"where varepsilon_protein and varepsilon_solvent are the dieletric constants of the protein interior and of the solvent, respectively, qi and qj are the atomic partial charges for each interacting point-like particle, d_ij is the inter-atomic distance of the considered particle pair and, finally, alpha_i and alpha_j are the effective Born radii of both considered interacting particles. The Born radius of an Atom is a characterization of its burial degree in the solute, and defines the interaction amount with the solvent. Despite the GB solvation model success, accurate estimation of the Born radii in a system has been the bottleneck preventing mass adoption as the go-to implicit solvent potential.","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"The following section has been subdivided in several sub-section for organizational purposes:","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"Born Radii estimation\nGeneralized Born solvation EnergyFunctionComponent","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/#Born-Radii-estimation","page":"Generalized Born","title":"Born Radii estimation","text":"","category":"section"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"As previously stated, Born radii estimation is a performance-intensive task. Several approaches have been devised over the years to improve both the accuracy and calculation speed in Born radii estimation. ProtoSyn employs the work of Fogolari et al. (2020) (https://pubmed.ncbi.nlm.nih.gov/31693089/), estimating the Born radii using a machine learning model.","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"predict_igbr_nn_born_radii","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/#ProtoSyn.Calculators.GB.predict_igbr_nn_born_radii","page":"Generalized Born","title":"ProtoSyn.Calculators.GB.predict_igbr_nn_born_radii","text":"predict_igbr_nn_born_radii(pose::Pose, selection::Opt{AbstractSelection} = nothing; dm::Opt{Matrix{T}} = nothing, models::GBModels = models_onnx) where {T <: AbstractFloat}\n\nReturns the Born Radii for each [`Atom`](@ref) instance in the given\n\nPose pose (selected by the AbstractSelection selection - TrueSelection, by default), according to the IGBR neural network model (See Fogolari et al. work - https://pubmed.ncbi.nlm.nih.gov/31693089/). By default, uses the pre-trained ProtoSyn.Calculators.GB.models_onnx models, but can be set to use other models with the models argument. Optionally, a pre-calculated full distance matrix dm can be provided, otherwise will calculate one using the ProtoSyn.acceleration.active mode.\n\nSee also\n\ncalc_gb\n\nExamples\n\njulia> ProtoSyn.Calculators.GB.predict_igbr_nn_born_radii(pose)\n1140-element Vector{Float64}:\n 0.4011280834674835\n 0.3859025537967682\n 0.5258529782295227\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/gb-solvation/#Generalized-Born-solvation-EnergyFunctionComponent","page":"Generalized Born","title":"Generalized Born solvation EnergyFunctionComponent","text":"","category":"section"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"With the estimated Born radii, ProtoSyn employs the above-defined equations to evaluate a system's implicit solvation status using the following methods:","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"calc_gb\nget_default_gb","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/#ProtoSyn.Calculators.GB.calc_gb","page":"Generalized Born","title":"ProtoSyn.Calculators.GB.calc_gb","text":"calc_gb([::A], pose::Pose, selection::Opt{AbstractSelection}, [update_forces::Bool = false]; [born_radii::Union{Vector{T}, Function} = predict_igbr_nn_born_radii], [ϵ_protein::T = 1.0], [ϵ_solvent::T = 80.0], [models::GBModels = models_onnx]) where {A}\n\nCalculate the Pose pose solvation energy according to the Generalized Born function (make sure the Pose pose is synched, see sync!). ProtoSyn uses the Generalzied Born function as described in Simmerling et al. work (See https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4361090/). The protein and solvent dieletric constants can be defined using the ϵ_protein and ϵ_solvent arguments (default is 1.0 and 80.0, respectively). The Born Radii can be statically provided in the born_radii argument. Optionally, this argument can be a Function instance, in which case the Born Radii will be re-calculated, using the provided models (uses ProtoSyn.Calculators.GB.models_onnx, by default). Custom Born Radii predictors can be defined, using the following signature:\n\nmy_born_radii_predictor(pose::Pose, selection::Opt{AbstractSelection} = nothing; dm::Opt{Matrix{T}} = nothing, models::GBModels = models_onnx)\n\nNote the presence of pre-calculated full-distance matrix dm in the Function arguments. Even if no GBModels are used in the Born Radii prediction, calc_gb still provides them and as such the custom Function signature should expect them (or use kwargs). An optional parameter A (Type{<: AbstractAccelerationType}) can be provided, stating the acceleration type used to calculate this energetic contribution (See ProtoSyn acceleration types). Uses ProtoSyn.acceleration.active by default.\n\nSee also\n\nget_default_gb\n\nExamples\n\njulia> ProtoSyn.Calculators.GB.calc_gb(pose, nothing)\n(124.4289232784785, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/gb-solvation/#ProtoSyn.Calculators.GB.get_default_gb","page":"Generalized Born","title":"ProtoSyn.Calculators.GB.get_default_gb","text":"get_default_gb(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default Generalized Born EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). This component employs the calc_gb method, therefore defining a Pose energy based on the Generalized Born function. By default, this EnergyFunctionComponent uses the predict_igbr_nn_born_radii function to predict Born Radii every call. Define efc.settings[:born_radii] as a Vector{Float64} to use static born radii.\n\nSettings\n\nborn_radii::Union{Function, Vector{T}} - Defines either the born radii predictor function or static list of born radii (where T <: AbstractFloat);\nϵ_protein::T - Define the protein dieletric constant (where T <: AbstractFloat);\nϵ_solvent::T - Define the solvent dieletric constant (where T <: AbstractFloat);\nmodels::GBModels - Define the GBModels to use if :born_radii is a predictor function.\n\nExamples\n\njulia> ProtoSyn.Calculators.GB.get_default_gb()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | GB_Solvation                     |\n| Alpha (α)      | 1.0                              |\n| Update forces  | false                            |\n| Calculator     | calc_gb                          |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | ϵ_solvent                     | 80.0                                             |\n |    | models                        | C: ✓ | N: ✓ | H: ✓ | O: ✓ | S: ✓                 |\n |    | ϵ_protein                     | 4.0                                              |\n |    | born_radii                    | predict_igbr_nn_born_radii                       |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"ukw: Note:\nDespite using modern machine learning models (which substantially cut down the performance cost of estimating accurate born radii), this step is still costly and time-consuming. In not big changes are expected in the system (for example, only small refinement movements are introduced in the system, such as when re-packaging sidechains), consider using static born radii (calculated once and provided to calc_gb as a static Vector).","category":"page"},{"location":"protosyn-api/core/calculators/gb-solvation/","page":"Generalized Born","title":"Generalized Born","text":"ukw: Note:\nModern implicit solvation models often employ a hybrid approach, dubbed \"SASA/GB\". In short, the Generalized Born model attempts to estimate the enthalpic contribution of solvating a given molecule, and the SASA model calculates the entropy contribution of \"opening space\" for the solvation of such a molecule. Both models act together to provide a more clear picture of the solvation potential of that system. Consider employing the get_default_sasa EnergyFunctionComponent in conjunction with the get_default_gb EnergyFunctionComponent.","category":"page"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/","page":"Rotamer Blitz","title":"Rotamer Blitz","text":"CurrentModule = ProtoSyn.Peptides.Drivers","category":"page"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/#Rotamer-Blitz-Driver","page":"Rotamer Blitz","title":"Rotamer Blitz Driver","text":"","category":"section"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/","page":"Rotamer Blitz","title":"Rotamer Blitz","text":"The Rotamer Blitz Driver is an algorithm for sidechain packaging, exhaustively looping through all Rotamer possibilities and setting the most stable conformation for the Residue sidechain.","category":"page"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/","page":"Rotamer Blitz","title":"Rotamer Blitz","text":"RotamerBlitz\nRotamerBlitzState","category":"page"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/#ProtoSyn.Peptides.Drivers.RotamerBlitz","page":"Rotamer Blitz","title":"ProtoSyn.Peptides.Drivers.RotamerBlitz","text":"RotamerBlitz(eval!::Union{Function, ProtoSyn.Calculators.EnergyFunction}, rotamer_library::Dict{String, ProtoSyn.Peptides.BBD_RotamerLibrary}, n_first::Int, max_steps::Int, callback::Opt{ProtoSyn.Drivers.Callback}, selection::Opt{AbstractSelection})\n\nA RotamerBlitz Driver instance. As such, this object is callable as a functor with the following signature:\n\n(driver::RotamerBlitz)(pose::Pose)\n\nThis simulation performs a sidechain packaging algorithm, where each step (until a maximum of n_steps), all Residue instances in the provided Pose pose (in random order) may suffer a rotamer conformation change. As such, for each Residue instance, all n_first most likely Rotamer instances in the rotamer_library (according to the current backbone phi and psi dihedral angles) are applied (using the apply! method) and evaluated by the provided eval! EnergyFunction or custom function. Once all n_first most likely Rotamer instances are looped over, the most favourable (least energetic) one is re-applied. Each step, a call to an optional Callback callback is performed. A companion RotamerBlitzState DriverState instance is also updated each step and provided to the Callback callback.\n\nFields\n\neval!::Union{Function, EnergyFunction} - The evaluator EnergyFunction or custom function, receives a Pose pose as the single argument;\nrotamer_library::Dict{String, ProtoSyn.Peptides.BBD_RotamerLibrary} - The rotamer library used to sample new Rotamer instances from;\nn_first::Int - Maximum number of Rotamer instances to try, ordered from most to less likely;\nmax_steps::Int - The total number of simulation steps to be performed;\ncallback::Opt{Callback} - An optional Callback instance, receives two input arguments: the current Pose pose and the current DriverState driver_state;\nselection::Opt{AbstractSelection} - If provided, only selected Residue instances will be considered as target for the RotamerBlitz simulation, otherwise, consider all Residue instances.\n\nSee also\n\nRotamerBlitzState\n\nExamples\n\njulia> rb = ProtoSyn.Peptides.Drivers.RotamerBlitz(energy_function, rot_lib, 1, 2, cb, an\"CA\")\n⚒  Rotamer Blitz Driver:\n ├──  ●  Evaluator:\n |    └── 🗲  Energy Function (4 components):\n |        +----------------------------------------------------------------------+\n |        | Index | Component name                                | Weight (α)   |\n |        +----------------------------------------------------------------------+\n |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |        +----------------------------------------------------------------------+\n |   \n ├──  ● Callback:\n |    └── ✉  Callback:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                     | Value                            |\n |        +----------------------------------------------------------------------+\n |        | 1     | Event                     | energy_step_frame                |\n |        | 2     | Frequency                 | 10                               |\n |        +----------------------------------------------------------------------+\n |   \n ├──  ● Selection:\n |    └── FieldSelection › Atom.name = CA\n |   \n └──  ● Settings:\n             Rotamer Library: Set ✓\n                   Max steps: 2\n     Search N first rotamers: 1\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/#ProtoSyn.Peptides.Drivers.RotamerBlitzState","page":"Rotamer Blitz","title":"ProtoSyn.Peptides.Drivers.RotamerBlitzState","text":"RotamerBlitzState{T <: AbstractFloat}(step::Int = 0, converged::Bool = false, completed::Bool = false, stalled::Bool = false, acceptance_count = 0)\nRotamerBlitzState{T <: AbstractFloat}()\n\nA RotamerBlitzState instance is a DriverState that keeps track of a RotamerBlitz simulation status. Besides the default :step, :converged, :completed and :stalled fields, a RotamerBlitzState does not add any additional tracking fields specific for RotamerBlitz simulations.\n\nSee also\n\nRotamerBlitz\n\nExamples\n\njulia> ProtoSyn.Peptides.Drivers.RotamerBlitzState()\nProtoSyn.Peptides.Drivers.RotamerBlitzState(0, false, false, false)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/","page":"Rotamer Blitz","title":"Rotamer Blitz","text":"(Image: ProtoSyn rotamer-blitz-driver)","category":"page"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/","page":"Rotamer Blitz","title":"Rotamer Blitz","text":"Figure 1 | A schematic overview of the different stages in a RotamerBlitz Driver: (1) - For a single Residue, all N most likely Rotamer instances are applied (using the apply! method) and the resulting conformation's energy is evaluated; (2) - After trying all Rotamer instances, the less energetic conformation is recovered and applied. This is performed to all Residue instances in a given Pose, in random order; (3) - This process continues for a set amount of steps, resulting in a lower energy conformation for the sidechains in a Pose.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-compound/","page":"Compound Driver","title":"Compound Driver","text":"CurrentModule = ProtoSyn.Drivers","category":"page"},{"location":"protosyn-api/core/drivers/drivers-compound/#Compound-Driver","page":"Compound Driver","title":"Compound Driver","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-compound/","page":"Compound Driver","title":"Compound Driver","text":"Similar to the Compound Mutator, a Compound Driver joins and sequentially calls a set of Driver and AbstractMutator instances, as well as custom sampling functions (the only difference to a CompoundMutator is the addition of Driver instances as callable objects).","category":"page"},{"location":"protosyn-api/core/drivers/drivers-compound/","page":"Compound Driver","title":"Compound Driver","text":"CompoundDriver","category":"page"},{"location":"protosyn-api/core/drivers/drivers-compound/#ProtoSyn.Drivers.CompoundDriver","page":"Compound Driver","title":"ProtoSyn.Drivers.CompoundDriver","text":"CompoundDriver(drivers::Vector{Union{Function, AbstractMutator, Driver}}; [p::Float64 = 1.0])\n\nA CompoundDriver Driver instance. As such, this object is callable as a functor with the following signature:\n\n(driver::CompoundDriver)(pose::Pose)\n\nA CompoundDriver Driver groups several Driver, AbstractMutator and custom functions, calling each of the components sequentially. Does not sync! changes, this task is left to each individual Driver or AbstractMutator instance. p defines the probability of running this CompoundDriver when called (From 0.0 to 1.0).\n\nukw: Note:\nIn contrast with CompoundMutator, this Driver does not accept an AbstractSelection modifier. This may change in future versions of ProtoSyn.\n\nExamples\n\njulia> ProtoSyn.Drivers.CompoundDriver([monte_carlo, monte_carlo])\n⚒  CompoundDriver Driver (2 elements) (p: 1.0):\n ├── ⚒  Monte Carlo Driver:\n |    ├──  ●  Evaluator:\n |    |    └── 🗲  Energy Function (4 components):\n |    |        +----------------------------------------------------------------------+\n |    |        | Index | Component name                                | Weight (α)   |\n |    |        +----------------------------------------------------------------------+\n |    |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |    |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |    |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |    |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |    |        +----------------------------------------------------------------------+\n |    |   \n |    ├──  ● Sampler:\n |    |    └── ⚯  Dihedral Mutator:\n |    |        +----------------------------------------------------------------------+\n |    |        | Index | Field                       | Value                          |\n |    |        +----------------------------------------------------------------------+\n |    |        | 1     | angle_sampler               | Function randn                 |\n |    |        | 2     | p_mut                       | 0.0100                         |\n |    |        | 3     | step_size                   | 0.5000                         |\n |    |        +----------------------------------------------------------------------+\n |    |         ● Selection: Set\n |    |         └── FieldSelection › Atom.name = r\"C|N\"\n |    |   \n |    ├──  ○  Callback: Not set\n |    |   \n |    └──  ● Settings:\n |          Max steps: 10\n |        Temperature: linear_quench\n |   \n └── ⚒  Monte Carlo Driver:\n      ├──  ●  Evaluator:\n      |    └── 🗲  Energy Function (4 components):\n      |        +----------------------------------------------------------------------+\n      |        | Index | Component name                                | Weight (α)   |\n      |        +----------------------------------------------------------------------+\n      |        | 1     | TorchANI_ML_Model                             |      1.000   |\n      |        | 2     | Caterpillar_Solvation                         |      0.010   |\n      |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n      |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n      |        +----------------------------------------------------------------------+\n      |   \n      ├──  ● Sampler:\n      |    └── ⚯  Dihedral Mutator:\n      |        +----------------------------------------------------------------------+\n      |        | Index | Field                       | Value                          |\n      |        +----------------------------------------------------------------------+\n      |        | 1     | angle_sampler               | Function randn                 |\n      |        | 2     | p_mut                       | 0.0100                         |\n      |        | 3     | step_size                   | 0.5000                         |\n      |        +----------------------------------------------------------------------+\n      |         ● Selection: Set\n      |         └── FieldSelection › Atom.name = r\"C|N\"\n      |   \n      ├──  ○  Callback: Not set\n      |   \n      └──  ● Settings:\n            Max steps: 10\n          Temperature: linear_quench\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"CurrentModule = ProtoSyn.Peptides.Mutators","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/#Rotamer-Mutator","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"","category":"section"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"One of the AbstractMutator types made available by the ProtoSyn.Peptides module is the RotamerMutator, allowing a user to sample the sidechain conformation of one or more Residue instances. This has, for example, applications in sidechain packaging, ligand adsorption stabilization or active site generation algorithms, among others. For more information, see the Rotamers submodule section.","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"RotamerMutator","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/#ProtoSyn.Peptides.Mutators.RotamerMutator","page":"Rotamer Mutator","title":"ProtoSyn.Peptides.Mutators.RotamerMutator","text":"RotamerMutator(rotamer_library::Dict{String, ProtoSyn.Peptides.BBD_RotamerLibrary}, p_mut::AbstractFloat, n_first::Int, selection::Opt{AbstractSelection}, random_inexistent_phi_psi::Bool)\n\nReturn a RotamerMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(rotamer_mutator::RotamerMutator)(pose::Pose)\n\nThe RotamerMutator AbstractMutator loops through all Atom instances in the given Pose and applies a Rotamer conformation change if a random number (rand()) is bellow a given probability of mutation p_mut (will skip any Residue with unnaccessible phi or psi dihedral angles, such as the first and last Residue of a chain, unless randomize_inexistent_phi_psi flag is set to true, false by default. Is this case, will randomize the missing phi or psi dihedral angles in order to sample a semi-random Rotamer from rotamer_library). A Rotamer conformation change is a concerted rotation of all sidechain Atom instances in the Residue of the selected Atom (therefore for a single attempt at Rotamer change, unique Atom names should be selected, an\"CA\", for example). If an AbstractSelection selection is provided, only Atom instances marked as true in this selection are considered for Rotamer conformational change. The applied Rotamer is sampled from the RotamerMutator.rotamer_library, based on the name of the Residue and current phi and psi dihedral angle values. The n_first most likely Rotamer instances are taken into account during this sampling step. Note that the RotamerMutator syncs any pending cartesian to internal coordinate conversion (using the c2i! method). Requests internal to cartesian coordinates conversion (using request_i2c! method). Does not sync! the given Pose afterwards.\n\nThe RotamerMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(rotamer_mutator::RotamerMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\nrotamer_library::Dict{String, ProtoSyn.Peptides.BBD_RotamerLibrary} - A dictionary of BBD_RotamerLibrary instances, for each aminoacid type;\np_mut::AbtractFloat - Compared against a rand() call, applies this Mutator to Atom instances where rand() < p_mut;\nn_first::Int - Take only the N most likely Rotamer instances from the rotamer library;\nselection::Opt{AbstractSelection} - If given, this Mutator will only loop over the selected Atom instances;\nrandom_inexistent_phi_psi::Bool - If set to true, any Residue instance whose phi or psi dihedral angle is unable to be determined will be randomized (example: last aminoacid in a chain);\n\nSee also\n\nDesignMutator\n\nExamples\n\njulia> rm = ProtoSyn.Peptides.Mutators.RotamerMutator(rot_lib, 1.0, 10, an\"CA\" & !rn\"PRO\")\n⚯  Rotamer Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | rotamer_library             | Set ✓                          |\n| 2     | p_mut                       | 1.000                          |\n| 3     | n_first                     | 10                             |\n+----------------------------------------------------------------------+\n ● Selection: Set\n └── BinarySelection ❯  & \"and\" (Atom)\n      ├── FieldSelection › Atom.name = CA\n      └── UnarySelection ❯ ! \"not\" (Residue)\n           └── FieldSelection › Residue.name = PRO\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"(Image: ProtoSyn Rotamer Mutator Card)","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"Figure 1 | Schematic description of the RotamerMutator. ","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"(Image: ProtoSyn Rotamer Mutator)","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"Figure 2 | Example of the application of RotamerMutator to simulateously change the conformation of all sidechain Atom instances (except in Proline Residue instances). ","category":"page"},{"location":"protosyn-api/core/submodules/selections/#core-selections","page":"Selections","title":"Selections","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"The Selections are a submodule of ProtoSyn.Core module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"ProtoSyn comes equipped with a powerful syntax for selecting parts of molecular systems based on several different parameters. The parent type of all Selections is an AbstractSelection, which is parametrized by 2 different static types:","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"First, a State mode (of abstract type AbstractStateMode) indicates whether an AbstractSelection is Stateful or Stateless.\nStateful selections require a State in order to correctly calculate the Selection. An example would be a Selection that selects all Atom instances within 10Å of a given Atom.\nStateless selections do not require a State. An example would be a Selection that selects all residues named \"ALA\".\nSecondly, a Selection type is an instance of AbstractContainer (such as an Atom, Residue or Segment), and indicates the type of molecular structure that in being queried. For example, depending on the selection type, we can select all Residue instances named \"ALA\" or all Atom instances named \"ALA\".","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"ukw: Note:\nSome AbstractSelection types can use regular expressions (Regex) to search for the desired parameter. Such cases are discussed individually.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Selections, when applied to an AbstractContainer, return a binary Mask (see Masks section). These can be combined with others Masks (see Combining selections), used directly in Methods or gathered to a list of the actual instances of AbstractContainer (see Applying selections section).","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"The Selections section will be sub-divided in the following topics, for organization:","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Available selections\nMasks\nPromotion\nCombining selections\nApplying selections","category":"page"},{"location":"protosyn-api/core/submodules/selections/#Available-selections","page":"Selections","title":"Available selections","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"In this section the list all available AbstractSelection types will be explored.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"SerialSelection\nRangeSelection\nFieldSelection\nUpstreamTerminalSelection\nDownstreamTerminalSelection\nDistanceSelection\nRandomSelection\nRandomSelectionFromList\nRandomRangeSelection\nTrueSelection\nUnarySelection\nAromaticSelection\nBondCountSelection\nBondedToSelection\nChargeSelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"SerialSelection\nRangeSelection\nFieldSelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.SerialSelection","page":"Selections","title":"ProtoSyn.SerialSelection","text":"SerialSelection{T}(serial::Int, field::Symbol) where {T <: AbstractContainer}\n\nA SerialSelection selects instances based on :id and :index. It takes an input serial (as an Int) and a field (as a Symbol) and outputs a Mask (of type T <: AbstractContainer) containing all instances of said type in the given container whose field matches the serial number given marked as true. This selection works similarly to FieldSelection, but is especialized in dealing with number variables.\n\nState mode\n\nThe state mode of SerialSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of SerialSelection can be any T <: AbstractContainer.\n\nShort syntax\n\nsid\"...\" = Segment ID;\nrid\"...\" = Residue ID;\naid\"...\" = Atom ID;\nsix\"...\" = Segment Index;\nrix\"...\" = Residue Index;\naix\"...\" = Atom Index;\n\nExamples\n\njulia> sele = SerialSelection{Segment}(1, :id)\nSerialSelection › Segment.id = 1\n\njulia> sele = SerialSelection{Atom}(2, :index)\nSerialSelection › Atom.index = 2\n\njulia> sele = sid\"1\"\nSerialSelection › Segment.id = 1\n\njulia> sele = aix\"2\"\nSerialSelection › Atom.index = 2\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.RangeSelection","page":"Selections","title":"ProtoSyn.RangeSelection","text":"RangeSelection{T}(range::UnitRange{Int}, field::Symbol) where {T <: AbstractContainer}\n\nA RangeSelection takes an input range (as an UnitRange{Int}) and a field (as a Symbol) and outputs a Mask (of type T <: AbstractContainer) containing all instances of said type in the given container whose field matches is in the range given. This selection works simillarly to FieldSelection, but is especialized in dealing with numbers.\n\nukw: Note:\nThe RangeSelection is inclusive, meaning the :id of :index given in the selection will also be included in the selected Mask.\n\nState mode\n\nThe state mode of RangeSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of RangeSelection can be any T <: AbstractContainer.\n\nShort syntax\n\nsid\"...\" = Segment ID\nrid\"...\" = Residue ID\naid\"...\" = Atom ID\nsix\"...\" = Segment Index;\nrix\"...\" = Residue Index;\naix\"...\" = Atom Index;\n\nExamples\n\njulia> sele = RangeSelection{Segment}(1:4, :id)\nRangeSelection › Segment.id between 1 and 4\n\njulia> sele = RangeSelection{Atom}(2:10, :index)\nRangeSelection › Atom.index between 2 and 10\n\njulia> sele = sid\"1:4\"\nRangeSelection › Segment.id between 1 and 4\n\njulia> sele = aix\"2:10\"\nRangeSelection › Atom.index between 2 and 10\n\nukw: Note:\nThis selection assumes that all Abstractcontainer instances are ordered (i.e: aid\"1:10\" will select atoms 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10).\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.FieldSelection","page":"Selections","title":"ProtoSyn.FieldSelection","text":"FieldSelection{T}(pattern::String, field::Symbol, [is_regex::Bool = false]) where {T <: AbstractContainer}\n\nA FieldSelection takes an input pattern (as a String) and a field (as a Symbol) and outputs a Mask (of type T <: AbstractContainer) containing all instances of said type in the given container whose field matches the pattern marked as true. The given pattern can be considered as a Regular Expression (Regex), if is_regex flag is set to true. Optinally, when using a short syntax, appending an \"r\" flag at the end of the expression also sets is_regex to true.\n\nState mode\n\nThe state mode of FieldSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of FieldSelection can be any T <: AbstractContainer.\n\nShort syntax\n\nan\"...\" = Atom name\nas\"...\" = Atom symbol\nrn\"...\" = Residue name\nsn\"...\" = Segment name\n\nExamples\n\njulia> sele = FieldSelection{Atom}(\"C\", :symbol)\nFieldSelection › Atom.symbol = C\n\njulia> sele = FieldSelection{Residue}(\"AL*\", :name, is_regex = true)\nFieldSelection › Residue.name = r\"AL*\"\n\njulia> sele = as\"C\"\nFieldSelection › Atom.symbol = C\n\njulia> sele = rn\"AL*\"r\nFieldSelection › Residue.name = r\"AL*\"\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn selections1)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 1 | An example of a Serial, Range and Field selections being employed.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"UpstreamTerminalSelection\nDownstreamTerminalSelection\nDistanceSelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.UpstreamTerminalSelection","page":"Selections","title":"ProtoSyn.UpstreamTerminalSelection","text":"UpstreamTerminalSelection{T}() where {T <: AbstractContainer}\n\nAn UpstreamTerminalSelection returns a Mask selecting only the upstream terminal Residue or Atom instances in a Pose or AbstractContainer. Upstream terminal instances are defined as being children of the Pose or AbstractContainer root.\n\nState mode\n\nThe state mode of UpstreamTerminalSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of UpstreamTerminalSelection T is forced to be either Residue or Atom.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> sele = UpstreamTerminalSelection{Residue}()\nUpstreamTerminalSelection (Residue)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.DownstreamTerminalSelection","page":"Selections","title":"ProtoSyn.DownstreamTerminalSelection","text":"DownstreamTerminalSelection{T}() where {T <: AbstractContainer}\n\nA DownstreamTerminalSelection returns a Mask selecting only downstream terminal Residue or Atom instances in a Pose or AbstractContainer. Downstream terminal instances are defined as instances with a parent but no children.\n\nState mode\n\nThe state mode of DownstreamTerminalSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of DownstreamTerminalSelection T is forced to be either Residue or Atom.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> sele = DownstreamTerminalSelection()\nDownstreamTerminalSelection (Residue)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.DistanceSelection","page":"Selections","title":"ProtoSyn.DistanceSelection","text":"DistanceSelection(distance::Number, sele::S) where {S <: AbstractSelection}\n\nA DistanceSelection takes an input selection sele and outputs a Mask of Atom instances within the given distance (in Ansgtrom Å) of the selected atoms from sele.\n\nState mode\n\nThe state mode of DistanceSelection M is forced to be Stateful\n\nSelection type\n\nThe selection type of DistanceSelection T is forced to be Atom.\n\nExamples\n\njulia> sele = DistanceSelection(2.0, rn\"ALA\")\nDistanceSelection ❯ Within 2.0 Å (Atom)\n └── FieldSelection › Residue.name = ALA\n\njulia> 2.0:rn\"ALA\"\nDistanceSelection ❯ Within 2.0 Å (Atom)\n └── FieldSelection › Residue.name = ALA\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn selections2)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 2 | An example of the Terminal and Distance selections being employed.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"RandomSelection\nRandomSelectionFromList\nRandomRangeSelection\nAromaticSelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.RandomSelection","page":"Selections","title":"ProtoSyn.RandomSelection","text":"RandomSelection{T}(sele::Opt{AbstractSelection}) where {T <: AbstractContainer}\n\nA RandomSelection outputs a Mask (of type T <: AbstractContainer) containing a random instance of said type in the given container. Optionally, if an AbstractSelection sele is provided, the random selection is performed from the previously selected instances (from the inner sele). Note that, despite the inner sele selection type, the output will always be promoted to be of T type (using the promote method.)\n\nState mode\n\nThe state mode of RandomSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of RandomSelection can be any T <: AbstractContainer.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> sele = RandomSelection{Residue}()\nRandomSelection › Residue.id\n\njulia> RandomSelection{Atom}(rid\"1\")\nRandomSelection › Atom.id › From\n └── SerialSelection › Residue.id = 1\n\njulia> RandomSelection{Atom}(an\"C\" & rid\"1\")\nRandomSelection › Atom.id › From\n └── BinarySelection ❯  & \"and\" (Atom)\n      ├── FieldSelection › Atom.name = C\n      └── SerialSelection › Residue.id = 1\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.RandomSelectionFromList","page":"Selections","title":"ProtoSyn.RandomSelectionFromList","text":"RandomSelectionFromList(selections::Vector{T}) where {T <: AbstractSelection}\n\nA RandomSelectionFromList outputs a Mask (of type T <: AbstractContainer). This Mask is the result of the application of a randomly selected AbstractSelection from the provided list of AbstractSelection instances selections.\n\nukw: Note:\nAll the given AbstractSelection instances must be of the same type.\n\nState mode\n\nThe state mode of RandomSelectionFromList M is the same as the state mode of the provided list of AbstractSelection instances (which are all of the same type).\n\nSelection type\n\nThe selection type of RandomSelectionFromList M is the same as the selection type of the provided list of AbstractSelection instances (which are all of the same type).\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> s = ProtoSyn.RandomSelectionFromList([rid\"1\", rid\"2\"])\nRandomSelectionFromList ❯ (Residue)\n ├── SerialSelection › Residue.id = 1\n └── SerialSelection › Residue.id = 2\n \njulia> s = ProtoSyn.RandomSelectionFromList([rid\"1\", rn\"CBZ\"])\nERROR: AssertionError: RandomSelectionFromList `selections` elements must be all of the same type.\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.RandomRangeSelection","page":"Selections","title":"ProtoSyn.RandomRangeSelection","text":"RandomRangeSelection{T}() where {T <: AbstractContainer}\n\nA RandomRangeSelection outputs a Mask (of type T <: AbstractContainer) containing a random range of instances of said type in the given container. The considered range is based on the instance's :id.\n\nState mode\n\nThe state mode of RandomRangeSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of RandomRangeSelection can be any T <: AbstractContainer.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> sele = RandomRangeSelection{Residue}()\nRandomRangeSelection › Residue.id\n\nukw: Note:\nThis selection assumes that all Abstractcontainer instances are ordered (i.e: a random range between atom 1 and atom 10 will select atoms 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10).\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.AromaticSelection","page":"Selections","title":"ProtoSyn.AromaticSelection","text":"AromaticSelection([d::Int = 6])\n\nAn AromaticSelection selects Atom instances that belong to an aromatic ring. Rings are identified by their bonds, using the travel_bonds method: any atom who exists in the set of bonded atoms within d bonds to itself forms a ring (d = 6, by default). \n\nState mode\n\nThe state mode of SerialSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of SerialSelection T is forced to be Atom.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> AromaticSelection(6)\nAromaticSelection (Rings with 6 or less bonds) › (Atom)\n\njulia> AromaticSelection(7)\nAromaticSelection (Rings with 7 or less bonds) › (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn selections3)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 3 | An example of the Aromatic selection being employed.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"BondCountSelection\nBondedToSelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.BondCountSelection","page":"Selections","title":"ProtoSyn.BondCountSelection","text":"BondCountSelection{T}(n::Int, op::Function = ===)\n\nA BondCountSelection takes an input n value and an op (as a Function, is ===, by default) and outputs a Mask (of type Atom) containing all Atom instances whose number of bonded Atom instances (in atom.bonds) matches the given n (when compared with op). As an example, op can be >, <=, ==, etc.\n\nState mode\n\nThe state mode of BondCountSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of BondCountSelection is forced to be Atom.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> BondCountSelection(1)\nBondCountSelection (Atoms with N bonds === 1) › (Atom)\n\njulia> BondCountSelection(3, >)\nBondCountSelection (Atoms with N bonds > 3) › (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.BondedToSelection","page":"Selections","title":"ProtoSyn.BondedToSelection","text":"BondedToSelection(sele::S)\n\nA BondedToSelection takes an input selection sele and outputs a Mask of Atom instances which are bonded to any selected Atom from the inner sele. Note that the inner sele is automatically promoted to be of Atom selection type (using the promote method).\n\nState mode\n\nThe state mode of BondedToSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of BondedToSelection T is forced to be Atom.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> BondedToSelection(an\"C\")\nBondedToSelection ❯ (Atom)\n └── FieldSelection › Atom.name = C\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn selections4)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 4 | An example of the Bond Count and Bonded To selection being employed.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"ChargeSelection\nTrueSelection\nUnarySelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.ChargeSelection","page":"Selections","title":"ProtoSyn.ChargeSelection","text":"ChargeSelection(charge::F, op::Function = ===) where {F <: AbstractFloat}\n\nA ChargeSelection takes an input charge value and an op (as a Function, is ===, by default) and outputs a Mask (of type Atom) containing all Atom instances whose AtomState charge matches the given charge (when compared with op). As an example, op can be >, <=, ==, etc.\n\nState mode\n\nThe state mode of ChargeSelection M is forced to be Stateful.\n\nSelection type\n\nThe selection type of ChargeSelection is forced to be Atom.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> ChargeSelection(1.0)\nChargeSelection (Atoms with charge === 1.0) › (Atom)\n\njulia> ChargeSelection(-1.0, >)\nChargeSelection (Atoms with charge > -1.0) › (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.TrueSelection","page":"Selections","title":"ProtoSyn.TrueSelection","text":"TrueSelection{T}()\n\nA TrueSelection returns a Mask (of type T <: AbstractContainer) with all entries set to true.\n\nState mode\n\nThe state mode of [TrueSelection] M is forced to be Stateless.\n\nSelection type\n\nThe selection type of RandomRangeSelection can be any T <: AbstractContainer.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> sele = TrueSelection{Atom}()\nTrueSelection (Atom)\n\njulia> sele = !TrueSelection{Atom}()\nUnarySelection ❯ ! \"not\" (Atom)\n └── TrueSelection (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.UnarySelection","page":"Selections","title":"ProtoSyn.UnarySelection","text":"UnarySelection{M}(op::Function, sele::AbstractSelection)\n\nA UnarySelection applies an operation op to the given AbstractSelection sele. Available operations with short syntax:\n\n! - Logical Not. Negates the values selected by sele.\n\nState mode\n\nThe selection type of UnarySelection can be either Stateless or Stateful. When using the short syntax, it will automatically be set to the StateMode of the provided sele.\n\nSelection type\n\nThe selection type of UnarySelection can be any T <: AbstractContainer. When queried for using the selection_type function, will return the selection type of the given sele.\n\nExamples\n\njulia> sele = !rn\"ALA\"\nUnarySelection ❯ ! \"not\" (Residue)\n └── FieldSelection › Residue.name = ALA\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#Masks","page":"Selections","title":"Masks","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Masks are the primary result of applying a Selection to an AbstractContainer. These are, in essence, arrays of Bool instances, set to true only on the Atom, Residue or Segment instances that satisfy the restrictions imposed by any given selection (or combination of selections). The total size of a Mask is the amount of Atom, Residue or Segment instances in the AbstractContainer the selection is applied to (see Applying selections section).","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Mask","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.Mask","page":"Selections","title":"ProtoSyn.Mask","text":"ProtoSyn.Mask{T}(content::BitVector) where {T <: AbstractContainer}\n\nA Mask is a typed wrapped on a BitArray, and therefore can be N dimensional. Utility functions are provided for Mask instances up to 2D.\n\nProtoSyn.Mask{T}() where {T <: AbstractContainer}\n\nReturn an empty Mask of length 0.\n\nProtoSyn.Mask{T}(n::Int) where {T <: AbstractContainer}\n\nReturn a Mask of length n with all bits set to false.\n\nProtoSyn.Mask{T}(n::Tuple{Int, Int}) where {T <: AbstractContainer}\nProtoSyn.Mask{T}(n1::Int, n2::Int) where {T <: AbstractContainer}\n\nReturn a 2D Mask of size n (or size (n1, n2)) with all bits set to false.\n\nSelection type\n\nThe selection type of a Mask instance can be any T <: AbstractContainer.\n\nukw: Note:\nCombinatory operators (& and |) and unary operators (!) can be employed with Mask instances.\n\nExamples\n\njulia> ProtoSyn.Mask{Atom}()\nProtoSyn.Mask{Atom}(0,)\n0-element BitArray{1}\n\njulia> ProtoSyn.Mask{Residue}((3, 3))\nProtoSyn.Mask{Residue}(3, 3)\n3×3 BitMatrix:\n 0  0  0\n 0  0  0\n 0  0  0\n\njulia> !ProtoSyn.Mask{Atom}(5)\nProtoSyn.Mask{Atom}(5,)\n5-element BitVector:\n 1\n 1\n 1\n 1\n 1\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#Promotion","page":"Selections","title":"Promotion","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Promoting a selection or Mask refers to the act of changing the output selection type. As an example, one could promote the selection rn\"ALA\" (which would output a Mask of Residue instances selected) to output a Mask of Atom instances selected instead. Following the notion that core types in ProtoSyn have an established hierarchical relationship (Topology > Segment > Residue > Atom), this example type of promotion would be a downwards promotion. The opposite case would be an upwards promotion, such as promoting an\"CB\" to output a Mask of Residue instances instead. In such case, an extra parameter is required: an agregating function. Usually, this is either any (i.e.: select residues that contain at least one CB atom - this is the default) or all (i.e: select residues where all atoms are CB).","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"We have two options for promotion operations:","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"1 | Promote the underlying AbstractSelection, before applying to an AbstractContainer. This is, in essence, an AbstractSelection type by itself;","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"PromoteSelection\nProtoSyn.promote(::AbstractSelection, ::Type{T2}, ::Function) where {T2 <: AbstractContainer}","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.PromoteSelection","page":"Selections","title":"ProtoSyn.PromoteSelection","text":"PromoteSelection(sele::AbstractSelection, ::Type{T}, op::Function) where {T <: AbstractContainer}\n\nA PromoteSelection takes an input selection sele and outputs the same result in a different Mask type, (depending on the operation op requested for upwards promotions). \n\nState mode\n\nThe selection type of PromoteSelection can be either Stateless or Stateful: it will automatically be set to the StateMode of the provided sele on the constructor.\n\nSelection type\n\nThe selection type of PromoteSelection can be any T <: AbstractContainer. When queried for using the selection_type function, will return the selection type of the given sele.\n\nukw: Note:\nThis selection does not have a short syntax version. However, the promote function is used to return PromoteSelection instances with a more user friendly syntax.\n\nExamples\n\njulia> sele = PromoteSelection(rn\"ALA\", Segment, all)\nPromoteSelection ❯ From Residue to Segment\n └── FieldSelection › Residue.name = ALA\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.promote-Union{Tuple{T2}, Tuple{AbstractSelection, Type{T2}, Function}} where T2<:ProtoSyn.AbstractContainer","page":"Selections","title":"ProtoSyn.promote","text":"promote(sele::AbstractSelection, ::Type{T2}, [aggregator::Function = any]) where {T2 <: AbstractContainer}\n\nReturn a PromoteSelection instance for selection sele, promoting to the requested type T2 <: AbstractContainer. If this is an upwards promotion, use the given aggregator function (default: any).\n\nExamples\n\njulia> ProtoSyn.promote(rn\"ALA\", Atom)\nPromoteSelection ❯ From Residue to Atom\n └── FieldSelection › Residue.name = ALA\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"2 | Promote an already calculated Mask instance (by applying the selection - see Applying selections section).","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"ProtoSyn.promote(::Mask{T1}, ::Type{T2}, ::AbstractContainer, ::Function) where {T1 <: AbstractContainer, T2 <: AbstractContainer}\npromote(::Mask{T1}, ::Mask{T2}, ::AbstractContainer) where {T1, T2}","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.promote-Union{Tuple{T2}, Tuple{T1}, Tuple{Mask{T1}, Type{T2}, ProtoSyn.AbstractContainer, Function}} where {T1<:ProtoSyn.AbstractContainer, T2<:ProtoSyn.AbstractContainer}","page":"Selections","title":"ProtoSyn.promote","text":"promote(mask::Mask{T1}, ::Type{T2}, container::AbstractContainer, f::Function = any)::Mask where {T1 <: AbstractContainer, T2 <: AbstractContainer}\n\nCast a Mask of type T1 to be of type T2, in the context of the given container. If casting to a higher ranking type (upwards promotion - Ex. Atom -> Residue), a function f establishes the grouping operation (any occurrence (by default) or all occurrences of lower ranking type must be true to set the higher ranking entry to true.)\n\nExamples\n\njulia> m1 = an\"CB\"(pose);\n\njulia> ProtoSyn.promote(m1, Residue, pose.graph);\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.promote-Union{Tuple{T2}, Tuple{T1}, Tuple{Mask{T1}, Mask{T2}, ProtoSyn.AbstractContainer}} where {T1, T2}","page":"Selections","title":"ProtoSyn.promote","text":"promote(m1::Mask{T1}, m2::Mask{T2}, container::AbstractContainer) where {T1, T2}\n\nPromote one of the 2 given Masks (m1 and m2) to the lowest ranking common type (Ex. promote(m1::Mask{Residue}, m2::Mask{Atom}) => (Mask{Atom}, Mask{Atom)).\n\nExamples\n\njulia> m1 = an\"CB\"(pose);\n\njulia> m2 = rn\"LEU\"(pose);\n\njulia> ProtoSyn.promote(m1, m2, pose.graph);\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/selections/#Combining-selections","page":"Selections","title":"Combining selections","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Two selections can be combined using logical operators (such as or and and), returning a BinarySelection. The resulting selection's StateMode and selection type depend on the two merged selections.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"BinarySelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.BinarySelection","page":"Selections","title":"ProtoSyn.BinarySelection","text":"BinarySelection(op::Function, left::L, right::R) where {L <: AbstractSelection, R <: AbstractSelection}\n\nA BinarySelection merges two selections using different operators op, such as and and or. Return a new BinarySelection that combines both left and right AbstractSelections, using the defined operator op.\n\nState mode\n\nIf the defined selections have the same state mode, the resulting mask will be of that state mode. If the defined selections have different state modes (Ex: Stateless and Stateful) the resulting selection will have a Stateful state mode.\n\nSelection type\n\nIf the defined have the same selection type, the resulting mask will be of that type. If the defined selections have different selection types (Ex: Atom and Residue), the resulting mask will be promoted to the lowest ranking type (Ex: Atom).\n\nSee also\n\nPromotion\n\nShort syntax\n\n... & ...\n... | ...\n\nukw: Note:\nBinarySelection instances are left-dominant, meaning that a grouping of logical operators such as rn\"ALA\" & rn\"LEU\" | an\"CA\" will first resolve the rn\"ALA\" & rn\"LEU\" part (which should return an all-false Mask) and only then combine this Mask with the | an\"CA\" BinarySelection, thus essentially selecting only the CA atoms of the AbstractContainer its applied to.However, selections respect to parenthesis grouping, meaning rn\"ALA\" & (rn\"LEU\" | an\"CA\") will first resolve rn\"LEU\" | an\"CA\" (which should return a Mask selecting all atoms of all LEU residues plus the CA atoms of all other residues) and only then combine this Mask with the rn\"ALA\" & BinarySelection, thus essentially selecting only the CA atoms of any ALA residues of the AbstractContainer its applied to.\n\nExamples\n\njulia> sele = BinarySelection(&, rn\"ALA\", an\"CA\")\nBinarySelection ❯  & \"and\" (Atom)\n ├── FieldSelection › Residue.name = ALA\n └── FieldSelection › Atom.name = CA\n\njulia> rn\"ALA\" & an\"CA\"\nBinarySelection ❯  & \"and\" (Atom)\n ├── FieldSelection › Residue.name = ALA\n └── FieldSelection › Atom.name = CA\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn selections5)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 5 | An example of a possible combination of AbstractSelection types, in ProtoSyn. In this example, two FieldSelection instances (an\"CA\" and rn\"ALA\") are combined using a BinarySelection, with operation op being the & (\"and\"), effectly selecting all Atom instances in a given Pose who are CA atoms belonging to an ALA residue. This AbstractSelection is further used as input for a DistanceSelection, selecting all Atom instances within 10.0 Å of a CA atom in an ALA residue. Since FieldSelection instances act directly on a given Pose instance (and not on other AbstractSelection instances), these are said to be \"leaf selections\", in contrast with \"branch selections\". Branch selections act on other AbstractSelection instances. For example, the BinarySelection combines two AbstractSelection instances with a given operator op. ","category":"page"},{"location":"protosyn-api/core/submodules/selections/#Applying-selections","page":"Selections","title":"Applying selections","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"As stated in the Masks section, selections are applied to AbstractContainer instances, selecting all elements of the desired selection type in that container. This is known as resolving the selection. All AbstractSelection instances are actually functors, meaning that selections are callable objects.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"using ProtoSyn\nusing ProtoSyn.Peptides\npose = ProtoSyn.build(Peptides.grammar, seq\"GAME\")","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"rn\"ALA\"(pose.graph)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"ukw: Note:\nWhen applying BinarySelection instances, note the need for parenthesis to highlight what is part of the selection, to avoid syntax errors. The same applies to compound selections, such as DistanceSelection instances, for example.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(rn\"ALA\" & an\"CA\")(pose)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"As stated before, Stateful selections require a State to calculate the selection. Given the syntax used, there are two ways of providing the State:","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(10:rn\"ALA\")(pose.graph)(pose.state)\n(10:rn\"ALA\")(pose.graph, pose.state)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"In such cases, the second syntax (sele(pose.graph, pose.state)) is recomended.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Specific methods are available to apply selections to Pose instances, in particular. In this cases, the methods automatically calls sele(pose.graph, pose.state)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(10:rn\"ALA\")(pose)\nrn\"ALA\"(pose)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Finally, selections (and Mask instances) can be gathered. This, in essence, means looping over the resolved Mask and appending the actually selected Atom, Residue or Segment instances to an output Vector. This process can be done in one of two ways:","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"1 | By using the optional flag gather when applying a selection to an AbstractContainer (recommended);","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"an\"^C.*$\"r(pose, gather = true)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"2 | By directly calling the function gather.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"gather","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.gather","page":"Selections","title":"ProtoSyn.gather","text":"ProtoSyn.gather(mask::Mask{T}, container::AbstractContainer) where {T <: AbstractContainer}\n\nGather all instances of type T from container whose relative position is marked as true in the given mask.\n\nExamples\n\njulia> ProtoSyn.gather(rn\"ALA\"(pose), pose.graph)\n4-element Vector{Residue}:\n Residue{/UNK:1/UNK:1/ALA:5}\n Residue{/UNK:1/UNK:1/ALA:12}\n Residue{/UNK:1/UNK:1/ALA:13}\n Residue{/UNK:1/UNK:1/ALA:20}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/sugars/introduction/#Sugars","page":"Introduction","title":"Sugars","text":"","category":"section"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"Besides the Core module, ProtoSyn comes with several other extra modules that build on top of and expand the base methods, types and submodules. These ProtoSyn modules are specific for a given topic. In the case of the Sugars module, all new or expanded methods and types explore the topic of carbohydrates simulation and ramified sugar structures, including glycoproteins. With this extra constraint, most methods can be especialized.","category":"page"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"In sum, the Sugars module makes available several methods, types and submodules specific for ramified polysaccharide structures.","category":"page"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"ukw: Note:\n🛠 Under construction. This module is not finished: several bugs and incomplete features can be found. The existing code is provided as is, and should be mainly used for further improvement and development.","category":"page"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"In order to use this module, including the following call is often useful:","category":"page"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn","category":"page"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn.Sugars","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/#peptides-selection","page":"Selections","title":"Selections","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"The Selections is a submodule of ProtoSyn.Peptides module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"As an expansion of the Core module Selections, this submodule introduces some protein specific AbstractSelection types:","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"ProteinSelection\nPolarSelection\nSidechainSelection\nSecondaryStructureSelection\nPhiSelection\nPsiSelection\nOmegaSelection\nChiSelection","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"ProteinSelection\nPolarSelection","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/#ProtoSyn.ProteinSelection","page":"Selections","title":"ProtoSyn.ProteinSelection","text":"ProteinSelection()\n\nA ProteinSelection outputs a Mask of Residue instances where the protein aminoacids are marked as true. A known aminoacid is defined as having an entry both in ProtoSyn.three_2_one dictionary and in the default Peptides LGrammar.\n\nState mode\n\nThe state mode of ProteinSelection M is forced to be Stateless\n\nSelection type\n\nThe selection type of ProteinSelection T is forced to be Residue.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nukw: Note:\nThis selection is provided by the Peptides module but registered under ProtoSyn Core module, in order to directly accessible and merged with other AbstractSelection instances.\n\nExamples\n\njulia> ProteinSelection()\nProteinSelection › (Residue)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/selections/#ProtoSyn.PolarSelection","page":"Selections","title":"ProtoSyn.PolarSelection","text":"PolarSelection()\n\nA PolarSelection outputs a Mask of Residue instances where the polar aminoacids are marked as true (as defined in ProtoSyn.Peptides.polar_residues).\n\nState mode\n\nThe state mode of PolarSelection M is forced to be Stateless\n\nSelection type\n\nThe selection type of PolarSelection T is forced to be Residue.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nukw: Note:\nThis selection is provided by the Peptides module but registered under ProtoSyn Core module, in order to directly accessible and merged with other AbstractSelection instances.\n\nExamples\n\njulia> PolarSelection()\nPolarSelection › (Residue)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn Polar Selection)","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 1 | An example of a PolarSelection application.","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"SidechainSelection","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/#ProtoSyn.SidechainSelection","page":"Selections","title":"ProtoSyn.SidechainSelection","text":"SidechainSelection()\n\nA SidechainSelection outputs a Mask of Atom instances where the sidechain atoms are marked as true (all atoms not named C, H, CA, N or O - marks caps as true).\n\nState mode\n\nThe state mode of SidechainSelection M is forced to be Stateless\n\nSelection type\n\nThe selection type of SidechainSelection T is forced to be Atom.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nukw: Note:\nThis selection is provided by the Peptides module but registered under ProtoSyn Core module, in order to directly accessible and merged with other AbstractSelection instances. \n\nExamples\n\njulia> SidechainSelection()\nSidechainSelection › (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn Sidechain Selection)","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 2 | An example of a SidechainSelection application.","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"SecondaryStructureSelection","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/#ProtoSyn.SecondaryStructureSelection","page":"Selections","title":"ProtoSyn.SecondaryStructureSelection","text":"SecondaryStructureSelection(ss::Symbol, [threshold::Float64 = 0.87])\n\nA SecondaryStructureSelection outputs a Mask of Residue instances where the residues are marked as true if the current phi and psi dihedrals are within the threshold angular distance (in radians, 50° by default) of the reference values for the requested ss SecondaryStructure type.\n\nState mode\n\nThe state mode of SidechainSelection M is forced to be Stateful.\n\nSelection type\n\nThe selection type of SidechainSelection T is forced to be Residue.\n\nShort syntax\n\nss\"helix\" = Helix secondary structure\nss\"parallel_sheet\" = Parallel beta sheet secondary structure\nss\"antiparallel_sheet\" = Antiparallel beta sheet secondary structure\nss\"linear\" = Linear secondary structure\n\nukw: Note:\nThis selection is provided by the Peptides module but registered under ProtoSyn Core module, in order to directly accessible and merged with other AbstractSelection instances. \n\nExamples\n\njulia> SecondaryStructureSelection(:parallel_sheet, deg2rad(20))\nSecondaryStructureSelection › parallel_sheet (± 20.0°)\n\njulia> ss\"helix\"\nSecondaryStructureSelection › helix (± 50.0°)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn SS Selection)","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 3 | An example of a SecondaryStructureSelection application.","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"PhiSelection\nPsiSelection\nOmegaSelection\nChiSelection","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/#ProtoSyn.PhiSelection","page":"Selections","title":"ProtoSyn.PhiSelection","text":"PhiSelection()\n\nA PhiSelection outputs a Mask of Atom instances where the phi-controlling atoms are marked as true. Phi-controlling atoms are non upstream-terminal Atom instances named \"C\". (make sure the IUPAC naming conventions are respected, consider using assign_default_atom_names!) for renaming peptide structures into the default atom names).\n\nState mode\n\nThe state mode of PhiSelection M is forced to be Stateless\n\nSelection type\n\nThe selection type of PhiSelection T is forced to be Atom.\n\nukw: Note:\nThis selection is provided by the Peptides module but registered under ProtoSyn Core module, in order to directly accessible and merged with other AbstractSelection instances.\n\nExamples\n\njulia> PhiSelection()\nPhiSelection › (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/selections/#ProtoSyn.PsiSelection","page":"Selections","title":"ProtoSyn.PsiSelection","text":"PsiSelection()\n\nA PsiSelection outputs a Mask of Atom instances where the psi-controlling atoms are marked as true. Psi-controlling atoms are non downstream-terminal Atom instances named \"N\". (make sure the IUPAC naming conventions are respected, consider using assign_default_atom_names!) for renaming peptide structures into the default atom names).\n\nState mode\n\nThe state mode of PsiSelection M is forced to be Stateless\n\nSelection type\n\nThe selection type of PsiSelection T is forced to be Atom.\n\nukw: Note:\nThis selection is provided by the Peptides module but registered under ProtoSyn Core module, in order to directly accessible and merged with other AbstractSelection instances.\n\nExamples\n\njulia> PsiSelection()\nPsiSelection › (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/selections/#ProtoSyn.OmegaSelection","page":"Selections","title":"ProtoSyn.OmegaSelection","text":"OmegaSelection()\n\nAn OmegaSelection outputs a Mask of Atom instances where the omega-controlling atoms are marked as true. Omega-controlling atoms are non upstream-terminal Atom instances named \"CA\". (make sure the IUPAC naming conventions are respected, consider using assign_default_atom_names!) for renaming peptide structures into the default atom names).\n\nState mode\n\nThe state mode of OmegaSelection M is forced to be Stateless\n\nSelection type\n\nThe selection type of OmegaSelection T is forced to be Atom.\n\nukw: Note:\nThis selection is provided by the Peptides module but registered under ProtoSyn Core module, in order to directly accessible and merged with other AbstractSelection instances.\n\nExamples\n\njulia> PsiSelection()\nPsiSelection › (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/selections/#ProtoSyn.ChiSelection","page":"Selections","title":"ProtoSyn.ChiSelection","text":"ChiSelection(n::Union{Int, Vector{Int}})\n\nA ChiSelection outputs a Mask of Atom instances where the chi-controlling Atom instances of sidechain are marked as true (all atoms defined in Peptides.chi_dict, by name - make sure the IUPAC naming conventions are respected, consider using assign_default_atom_names!) for renaming peptide structures into the default atom names). this AbstractSelection selects the n-chi dihedral angles (chi1, chi2, chi3 or chi4). Optionally, a Vector{Int} can be provided, in wich case multiple chi-angles can be selected simultaneously.\n\nState mode\n\nThe state mode of ChiSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of ChiSelection T is forced to be Atom.\n\nShort syntax\n\nchi\"...\" = Chi angle\n\nukw: Note:\nUsing the short version syntax, it's possible to select multiple chi angles by using the 'r' flasg, as such: chi\"1|2|3|4\"r.\n\nukw: Note:\nThis selection is provided by the Peptides module but registered under ProtoSyn Core module, in order to directly accessible and merged with other AbstractSelection instances. \n\nExamples\n\njulia> ChiSelection(1)\nChiSelection (chi-1) › (Atom)\n\n\njulia> ChiSelection([1, 2])\nChiSelection (chi-1 and chi-2) › (Atom)\n\n\njulia> chi\"1\"\nChiSelection (chi-1) › (Atom)\n\n\njulia> chi\"1|2|3|4\"r\nChiSelection (chi-1, chi-2, chi-3 and chi-4) › (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/introduction/#Peptides","page":"Introduction","title":"Peptides","text":"","category":"section"},{"location":"protosyn-api/peptides/introduction/","page":"Introduction","title":"Introduction","text":"Besides the Core module, ProtoSyn comes with several other extra modules that build on top of and expand the base methods, types and submodules. These ProtoSyn modules are specific for a given topic. In the case of the Peptides module, all new or expanded methods and types are referring to the peptide and protein structures. With this extra constraint, most methods can be especialized: the ProtoSyn.unbond!, for example, is specialized in ProtoSyn.Peptides.unbond!, automatically unbonding the C atom to the next aminoacid's N atom - the peptidic bond.","category":"page"},{"location":"protosyn-api/peptides/introduction/","page":"Introduction","title":"Introduction","text":"In sum, the Peptides module makes available several methods, types and submodules specific for proteins and peptide structures.","category":"page"},{"location":"protosyn-api/peptides/introduction/","page":"Introduction","title":"Introduction","text":"In order to use this module, including the following call is often useful:","category":"page"},{"location":"protosyn-api/peptides/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn","category":"page"},{"location":"protosyn-api/peptides/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"CurrentModule = ProtoSyn.Peptides.Calculators.Caterpillar","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#Caterpillar-Solvation","page":"Caterpilar solvation model","title":"Caterpillar Solvation","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"The Caterpillar Solvation energy is a coarse-grained approximation to a solvation energy contribution, introducing a penalty for the exposure of hydrophobic Residue instances and a penalty for the burial of hydrophylic Residue instances (and vice-versa). ","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"The Caterpillar solvation energy calculation is based on the work of Coluzza et al (see this paper).","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"The ProtoSyn's modifications introduce a significant degree of complexity, futher explained bellow. In sum, the calculation takes 2 steps: the 1. Burial degree calculation and the 2. Hydrophobicity weight calculation.","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#.-Burial-degree-calculation","page":"Caterpilar solvation model","title":"1. Burial degree calculation","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"In this step, a given algorithm loops over all the residues (selecting a given atom for distance matrix calculation) and identifies the burial degree of each residue (this step can be parametrized by (1) the burial degree algorithm, (2) the identification curve, (3) the selection atom, (4) the rmax cut-off and (5) slope control sc. These settings are further explained bellow).","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#.1-Burial-degree-algorithm","page":"Caterpilar solvation model","title":"1.1 Burial degree algorithm","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"ProtoSyn offers 2 different burial degree identification algorithms, the Neighbour Count (NC) and Neighbour Vector (NV) (as explained further in this paper). In comparison to eachother, NC algorithms only take into consideration the number of selected atoms within a defined rmax range, while NV algorithms also take into consideration the orientation of neighbouring residues to defined the burial degree. As such, in general, NV algorithms are more precise, while carrying an additional performance weight.","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"neighbour_count\nneighbour_vector","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#ProtoSyn.Peptides.Calculators.Caterpillar.neighbour_count","page":"Caterpilar solvation model","title":"ProtoSyn.Peptides.Calculators.Caterpillar.neighbour_count","text":"ProtoSyn.Peptides.Calculators.Caterpillar.neighbour_count([::A], pose::Pose, selection::Opt{AbstractSelection}, [update_forces::Bool = false]; [identification_curve::Function = null_identification_curve], [hydrophobicity_weight::Function = null_hydrophobicity_weight], [rmax::T = 9.0], [sc::T = 1.0], [Ω::Union{Int, T} = 750.0], [hydrophobicity_map::Dict{String, T} = ProtoSyn.Peptides.doolitle_hydrophobicity]) where {A, T <: AbstractFloat}\n\nCalculate the given Pose pose caterpillar solvation energy using the Neighbour Count (NC) algorithm (see this article). If an AbstractSelection selection is provided, consider only the selected Atom instances (any given selection will be promoted to be of Atom type, see ProtoSyn.promote). In this model, the burial degree Ωi of each atom is equal to the number (count) of neighbouring Atom instances (within the defined rmax cut-off, in Angstrom Å) multiplied by a w1 weight, provided by the  identification_curve Function. This Function receives the distance between each pair of neighbouring atoms (as a float), the rmax value and, optionally, a slope control sc value, and return a weight w1 (as a float). The identification_curve signature is as follows:\n\nidentification_curve(distance::T; rmax::T = 9.0, sc::T = 1.0) where {T <: AbstractFloat}\n\nIn order to use pre-defined identification_curve Function instances defined in ProtoSyn, check linear and sigmoid.\n\nNote that:     - Shorter rmax value identify buried residues in the local environment (i.e.:     in the scale of the secondary structure, recommended) while a larger rmax     value identifies buried residues in the global scale (i.e.: in comparison with     the whole structure).     - The slope control sc value only has effect in sigmoid     identification_curve Function instances. A smaller value augments the     prevalence of distance information in the w1 weight calculation, while a     larger value defines a more strict cut-off (recommended);\n\nAn Atom is, therefore, considered buried if the number of neighbors  (multiplied by w1) is over a defined cut-off value Ω. Buried hydrophobic aminoacids receive an energetic reward, while exposed hydrophobic Residue instances receive a penalty (and vice-versa for hydrophylic aminoacids), defined in the provided hydrophobicity_map (hydrophobicity map examples can be found in Peptides.constants.jl) and multiplied by w2, calculated by the hydrophobicity_weight Function. This Function receives the neighbor count Ωi, the hydrophobicity_map_value and the cut-off value Ω, returning a w2 weight (as a float).  The hydrophobicity_weight signature is as follows:\n\nhydrophobicity_weight(Ωi::Union{Int, T}; hydrophobicity_map_value::T = 0.0, Ω::Union{Int, T} = 0.0) where {T <: AbstractFloat}\n\nIn order to use pre-defined hydrophobicity_weight Function instances defined in ProtoSyn, check nc_scalling_exposed_only, nc_non_scalling_exposed_only, nc_scalling_all_contributions (recommended) and nc_non_scalling_all_contributions.\n\nThe optional A parameter defines the acceleration mode used (SISD0, SIMD1 or CUDA2). If left undefined the default ProtoSyn.acceleration.active mode will be used. This function does not calculate forces (not applicable), and therefore the `updateforces` flag serves solely for uniformization with other energy-calculating functions.\n\nSee also\n\nneighbour_vector\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.neighbour_count(pose, false)\n(0.0, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#ProtoSyn.Peptides.Calculators.Caterpillar.neighbour_vector","page":"Caterpilar solvation model","title":"ProtoSyn.Peptides.Calculators.Caterpillar.neighbour_vector","text":"ProtoSyn.Peptides.Calculators.Caterpillar.neighbour_vector([::A], pose::Pose, selection::Opt{AbstractSelection}, [update_forces::Bool = false]; [identification_curve::Function = null_identification_curve], [hydrophobicity_weight::Function = null_hydrophobicity_weight], [rmax::T = 9.0], [sc::T = 1.0], [Ω::Union{Int, T} = 750.0], [hydrophobicity_map::Dict{String, T} = ProtoSyn.Peptides.doolitle_hydrophobicity]) where {A, T <: AbstractFloat}\n\nCalculate the given Pose pose caterpillar solvation energy using the Neighbour Vector (NV) algorithm (see this article). If an AbstractSelection selection is provided, consider only the selected Atom instances (any given selection will be promoted to be of Atom type, see ProtoSyn.promote). In this model, vectors ωi are defined between an Atom and all neighbouring Atom instances (within the defined rmax cut-off (in Angstrom Å)). Note that only the selected atoms by the selection are considered. A resulting vector Ωi is calculated by suming all ωi vectors, multiplied by a w1 weight, provided by the identification_curve Function. This Function receives the distance between each pair of neighbouring atoms (as a float), the rmax value and, optionally, a slope control sc value, and return a weight w1 (as a float). The identification_curve signature is as follows:\n\nidentification_curve(distance::T; rmax::T = 9.0, sc::T = 1.0) where {T <: AbstractFloat}\n\nIn order to use pre-defined identification_curve Function instances defined in ProtoSyn, check linear, sigmoid and sigmoid_normalized.\n\nNote that:\n\nShorter rmax value identify buried residues in the local environment (i.e.:\n\nin the scale of the secondary structure, recommended) while a larger rmax  value identifies buried residues in the global scale (i.e.: in comparison with  the whole structure).\n\nThe slope control sc value only has effect in sigmoid\n\nidentification_curve Function instances. A smaller value augments the  prevalence of distance information in the w1 weight calculation, while a  larger value defines a more strict cut-off (recommended);\n\nAn Atom is, therefore, considered buried if the magnitude of the resulting vector from the sum of the ωi (multiplied by w1) is within a defined cut-off value Ω. Buried hydrophobic aminoacids receive an energetic reward, while exposed hydrophobic Residue instances receive a penalty (and vice-versa for hydrophylic aminoacids), defined in the provided hydrophobicity_map (hydrophobicity map examples can be found in Peptides.constants.jl) and multiplied by w2, calculated by the hydrophobicity_weight Function. This Function receives the vector magnitude Ωi, the hydrophobicity_map_value and the cut-off value Ω, returning a w2 (as a float).  The hydrophobicity_weight signature is as follows:\n\nhydrophobicity_weight(Ωi::Union{Int, T}; hydrophobicity_map_value::T = 0.0, Ω::Union{Int, T} = 0.0) where {T <: AbstractFloat}\n\nIn order to use pre-defined hydrophobicity_weight Function instances defined in ProtoSyn, check nv_scalling_exposed_only, nv_non_scalling_exposed_only, nv_scalling_all_contributions (recommended) and nv_non_scalling_all_contributions.\n\nThe optional A parameter defines the acceleration mode used (SISD0, SIMD1 or CUDA2). If left undefined the default ProtoSyn.acceleration.active mode will be used. This function does not calculate forces (not applicable), and therefore the `updateforces` flag serves solely for uniformization with other energy-calculating functions.\n\nSee also\n\nneighbour_count\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.neighbour_vector(pose, false)\n(0.0, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"(Image: ProtoSyn Neighbour Count Neighbour Vector)","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"Figure 1 | Visualization of neighbour_count and neighbour_vector algorithms for burial degree calculation. A - Neighbour count - Since only the number of selected atoms within the rmax cutoff is accounted for, both depicted conformations are measured as having the same burial degree, even though atom B is more exposed to the system's solvent. B - Neighbour vector - Using the neighbour vector algorithm, the resulting vector from summing all individual vectors from the selected atom towards all neighbouring selected atoms (within rmax) provides a more clear distinction between exposed or non-exposed Atom instances: resulting vectors with higher magnitude are linearly and positively correlated with atoms with more exposed surfaces. Note that, on average, the NV algorithm was measured to be 4-5x slower than NC.","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#.2-Identification-curve","page":"Caterpilar solvation model","title":"1.2 Identification curve","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"The available identification curves are linear, sigmoid and normalized sigmoid (in NV algorithms only). Note that the definition of the identification curve controls the amount of distance information considered for the calculation of the burial degree: linear identification curves incorporate more distance information than sigmoid identification curves (normalized sigmoid, in NV algorithms, use the least distance information, similar to NC algorithms).","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"linear\nsigmoid\nsigmoid_normalized","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#ProtoSyn.Peptides.Calculators.Caterpillar.linear","page":"Caterpilar solvation model","title":"ProtoSyn.Peptides.Calculators.Caterpillar.linear","text":"linear(distance::T; rmax::T = 9.0, sc::T = 1.0) where {T <: AbstractFloat}\n\nReturns the linear identification curve weight w1 (max at distance 0.0, linearly decreasing until rmax). Note that slope control sc has no effect.\n\nSee also\n\nsigmoid sigmoid_normalized\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.linear(10.0, rmax = 20.0)\n0.5\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#ProtoSyn.Peptides.Calculators.Caterpillar.sigmoid","page":"Caterpilar solvation model","title":"ProtoSyn.Peptides.Calculators.Caterpillar.sigmoid","text":"sigmoid(distance::T; rmax::T = 9.0, sc::T = 1.0) where {T <: AbstractFloat}\n\nReturns the sigmoid identification curve weight w1 (max at distance 0.0, min at distance rmax). The slope control sc defines how sharp the sigmoid curve is.\n\nSee also\n\nlinear sigmoid_normalized\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.sigmoid(10.0, rmax = 20.0)\n0.9999546021312976\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#ProtoSyn.Peptides.Calculators.Caterpillar.sigmoid_normalized","page":"Caterpilar solvation model","title":"ProtoSyn.Peptides.Calculators.Caterpillar.sigmoid_normalized","text":"sigmoid_normalized(distance::T; rmax::T = 9.0, sc::T = 1.0) where {T <: AbstractFloat}\n\nReturns the sigmoid identification curve weight w1 (max at distance 0.0, min at distance rmax), normalized by the given distance (should only be  applied in Neighbor Vector (NV) algorithms). The slope control sc defines how sharp the sigmoid curve is.\n\nSee also\n\nlinear sigmoid\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.sigmoid_normalized(10.0, rmax = 20.0)\n0.09999546021312976\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#.3-Selection-atom","page":"Caterpilar solvation model","title":"1.3 Selection atom","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"This can be any selection that yields an atom. However, in most cases applied to proteins, either the Cα or Cβ atoms should be chosen.","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#.4-rmax-cutoff","page":"Caterpilar solvation model","title":"1.4 rmax cutoff","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"This can be any float number, however, the range between 9.0Å and 50.0Å was identified as yielding the best results. Note that short rmax values cause a much more localized identification of burial degrees (i.e.: in comparison with the rest of the local secondary structure) while larger rmax values identify a more global level of burial (i.e.: in comparison with all aminoacids in the structure).","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#.5-Slope-control-(sc)","page":"Caterpilar solvation model","title":"1.5 Slope control (sc)","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"This value controls the slope degree in sigmoid identification curves (only). Lower values yield less pronounced slopes (therefore taking more distance information into consideration) while higher sc values define more strict cut off lines.","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#.-Hydrophobicity-weight-calculation","page":"Caterpilar solvation model","title":"2. Hydrophobicity weight calculation","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"The final Caterpilar's solvation energy multiplies the calculated burial degree by an hydrophobicity weight: hydrophobic Residue instances receive a penalty when exposed and vice-versa. The buried/unburied distinction is defined by the user using the Ω field: buried degress bellow Ω are considered buried. The difference between burial degree and Ω is then multiplied by the hydrophobicity index. By default, ProtoSyn employs the Doolittle Hydrophobicity Index, when working with proteins and peptides.","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"get_default_caterpillar_solvation_energy","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#ProtoSyn.Peptides.Calculators.Caterpillar.get_default_caterpillar_solvation_energy","page":"Caterpilar solvation model","title":"ProtoSyn.Peptides.Calculators.Caterpillar.get_default_caterpillar_solvation_energy","text":"get_default_caterpillar_solvation_energy(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default Caterpillar solvation energy energy EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance, 1.0 by default). This function employs neighbour_vector as the :calc function.\n\nSettings\n\nhydrophobicity_weight::Function - Returns the hydrophobicity weight of a given burial degree based on a hydrophobicity map value and default buried state;\nidentification_curve::Function - Returns the burial degree weight given an inter-atomic distance, rmax and slope control value;\nΩ::Union{Int, T} - The default buried state (the average, buried degrees above this value are considered buried);\nsc::T = 1.0 - Slope control, used in sigmoid identification curves to control how sharp to consider an interaction as buried or not.\nhydrophobicity_map::Dict{String, T} - A 1-on-1 map between Residue types and hydrophobicity indexes;\nrmax::T - The cutoff value to consider some inter-atomic interaction as buriable; \n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.get_default_caterpillar_solvation_energy()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | Caterpillar_Solv                 |\n| Alpha (α)      | 1.0                              |\n| Update forces  | false                            |\n| Calculator     | neighbour_vector                 |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | hydrophobicity_weight         | nv_scalling_all_contributions                    |\n |    | identification_curve          | sigmoid                                          |\n |    | Ω                             | 24.0                                             |\n |    | sc                            | 1.0                                              |\n |    | hydrophobicity_map            | Dict{String, Float64}(21 components)             |\n |    | rmax                          | 9.0                                              |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ●  Selection:\n      └── BinarySelection ❯  | \"or\" (Atom)\n           ├── FieldSelection › Atom.name = CB\n           └── BinarySelection ❯  & \"and\" (Atom)\n                ├── FieldSelection › Atom.name = HA2\n                └── FieldSelection › Residue.name = GLY\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"(Image: ProtoSyn Caterpillar Solvation)","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpilar solvation model","title":"Caterpilar solvation model","text":"Figure 1 | A diagram representation of the Caterpillar Solvation EnergyFunctionComponent. The energy penalty is proportional to the hydrophobicity value (in the hydrophobicity map) multiplied by the excess number of Cα contacts (above Ω).","category":"page"},{"location":"protosyn-api/core/mutators/mutators-dihedral/","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"CurrentModule = ProtoSyn.Mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-dihedral/#Dihedral-Mutator","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-dihedral/","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"A DihedralMutator instance changes a Pose State by introducing one or more dihedral rotations.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-dihedral/","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"DihedralMutator","category":"page"},{"location":"protosyn-api/core/mutators/mutators-dihedral/#ProtoSyn.Mutators.DihedralMutator","page":"Dihedral Mutator","title":"ProtoSyn.Mutators.DihedralMutator","text":"DihedralMutator(angle_sampler::Function, p_mut::AbstractFloat, step_size::AbstractFloat, selection::Opt{AbstractSelection})\n\nReturn a new DihedralMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(dihedral_mutator::DihedralMutator)(pose::Pose)\n\nThe DihedralMutator AbstractMutator loops through all the Atom instances in a given Pose and applies a new dihedral angle if a random number (rand()) is bellow a given probability of mutation p_mut (therefore a higher p_mut value applies a larger number of dihedral rotations per call). The applied rotation is an angle value (in radians), sampled by calling angle_sampler and multiplied by the step_size value. The resulting value is then added to the selected Atom.Δϕ. Note that a new dihedral rotation is sampled for each selected Atom instance. If an AbstractSelection selection is provided, only the selected Atom instances are looped over. If the given AbstractSelection selection is not of selection type Atom, it will be promoted to this type (using promote with default aggregator any). Note that the DihedralMutator syncs any pending cartesian to internal coordinate conversion (using the c2i! method). Requests internal to cartesian coordinates conversion (using request_i2c! method). Does not sync! the given Pose afterwards.\n\nThe DihedralMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(dihedral_mutator::DihedralMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\nangle_sampler::Function - Should return a Float angle value (in radians). Is called with no input arguments;\np_mut::AbtractFloat - Compared against a rand() call, applies this Mutator to Atom instances where rand() < p_mut;\nstep_size::AbstractFloat - Multiplies the sampled angle by this value;\nselection::Opt{AbstractSelection} - If given, this Mutator will only loop over the selected Atom instances.\n\nSee also\n\nCrankshaftMutator\n\nExamples\n\njulia> ProtoSyn.Mutators.DihedralMutator(randn, 1.0, 1.0, nothing)\n⚯  Dihedral Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | angle_sampler               | Function randn                 |\n| 2     | p_mut                       | 1.0000                         |\n| 3     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ○  Selection: Not Set\n\njulia> ProtoSyn.Mutators.DihedralMutator(randn, 0.05, 1.0, an\"CA$|C$\"r)\n⚯  Dihedral Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | angle_sampler               | Function randn                 |\n| 2     | p_mut                       | 0.0500                         |\n| 3     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ● Selection: Set\n └── FieldSelection › Atom.name = r\"CA$|C$\"\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/mutators/mutators-dihedral/","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"(Image: ProtoSyn Dihedral Mutator)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-dihedral/","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"Figure 1 | A schematic representation of a DihedralMutator instance. In this example, the selection an\"C$\"r selects only the carbon atoms of the backbone of the peptide, excluding the alpha carbons. The :Δϕ field in this AtomState instance applies a given dihedral rotation to all children Atom instances, therefore setting, in this case, the psi dihedral angle of the backbone of this Residue. As such, by providing the DihedralMutator with this selection, only the psi dihedral angles are being sampled for rotation. Each of the selected Atom instances is looped over and one or more instances can be designated for dihedral angle sampling. This is performed by comparing a random number (by calling rand()) against the DihedralMutator.p_mut field, for each of the looped Atom instances. If the random number is lower, the current Atom instance is selected. A high value for p_mut therefore translates into a higher number of dihedral rotations in a single call to the DihedralMutator. As a general rule, using a p_mut value of 1/N will result in 1 rotation per call of the DihedralMutator, on average (where N is the number of atoms in the Pose or number of selected atoms by selection). To sample a new dihedral angle, the DihedralMutatorangle_sampler is called (with no input arguments) and multiplied by the DihedralMutator.step_size field. This value is added to the selected AtomState.Δϕ.","category":"page"},{"location":"getting-started/first-steps/#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"getting-started/first-steps/#Introduction","page":"First steps","title":"Introduction","text":"","category":"section"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"The rational placement of amino acids in a sequence directly correlates to the 3D structure of the peptide once folded. This folded structure, in turn, dictates the interactions with the environment and therefore the function of the peptide. Being able to design new peptides for specific functions would unlock the potential of unknown conformations not yet explored by nature, with applications in medical fields, agriculture, biological remediation, enzymatic synthesis, among others. ","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"This was traditionally explored by random blind mutagenesis which is an expensive and time intensive experimental practice. With the evolution of computational power over the last couple of decades, computational design of small proteins has become the focus of scientific breakthroughs. Using computer simulations saves precious time and monetary costs of experiments, focusing efforts on simulated prototypes that have shown promising results. As such, multiple software solutions have been proposed over the years. An example would be Rosetta (and its Python wrapper, PyRosetta), which has been indisputably invaluable as a platform for molecular manipulation and peptide design.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"However, as it happens with so many scientific-purposed software packages, Rosetta has fallen into the two-language problem. The core of the simulation code is written in C with a more user-friendly wrap in Python that exposes some of the functionality. This has gravelly impaired the community's ability to upgrade and modernize this package over the years, as well as imposing a steep learning curve to non-specialized would-be-users.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"ProtoSyn.jl, empowered by the Julia language ecosystem, aims to put forward a simple, easy to use and completly open-source framework for molecular manipulation and simulation, with a focus on peptide design. A Julia-based solution to this challenge would naturally benefit from the native features of the language, such as easy parallelization and distributed computing, GPU acceleration, machine learning tools, and a growing community of enthusiastic scientists, among others.","category":"page"},{"location":"getting-started/first-steps/#Under-the-hood:-how-is-ProtoSyn-organized?","page":"First steps","title":"Under the hood: how is ProtoSyn organized?","text":"","category":"section"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"(Image: organization)","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"ProtoSyn.jl's main struct is the Pose, which holds all the required information regarding a molecular system. This information is divided into a directional graph and a state.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"A directional graph is simply an hierarchical structuration of the molecular system: At the top level, a Topology can hold multiple Segment instances (which are contiguous chains of a molecule), which in turn can hold multiple Residue instances (such as amino acids, in the case of proteins and peptides), which, finally, hold one or multiple Atom instances.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"Each of these levels are called AbstractContainers and can have defining parameters. In the case of atoms, for example, an Atom instance is described by an :id, :symbol, :name, etc.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"This graph is called directional because each of these components has a parent and can have one or more children containers. In the case of Residue instances, for example, consider the sequence ALA-GLC-PRO. In such a molecule, ALA would be the parent of GLC which, in turn, would be the parent of PRO. The same logic applies to relationships between atoms. This structural organization allows ProtoSyn to easily travel the Graph of a structure during certain molecular manipulation processes. Perhaps more interestingly, when conjugated with the internal coordinates system, this data organization system allows for easy and fast manipulation of dihedral angles, bonds distances, etc.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"The information regarding these internal coordinates (and cartesian coordinates) is organized in the pose's State. This is subdivided into a list of AtomState instances and a StateMatrix. Both of these structures are interchangable, meaning that altering a value in StateMatrix updates the corresponding value in the correct AtomState and vice-versa. The rational behind having both structures lies in having the ease/speed of changing a large volume of coordinates in the StateMatrix at once, while still being able to control internal coordinates in single atoms using the AtomState. In sum: some manipulation processes benefict from using cartesian coordinates, while others are either faster or simpler using the internal coordiantes.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"In order to initialize the internal coordinate system, each Topology has an extra set of 3 pseudo atoms, called a Root, that sets-up the ascendents for the first few atoms of the molecule.","category":"page"},{"location":"getting-started/first-steps/#Mutators,-Energy-Functions-and-Drivers","page":"First steps","title":"Mutators, Energy Functions & Drivers","text":"","category":"section"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"(Image: organization)","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"ProtoSyn.jl offers some quick simulation functionalities, such as MonteCarlo, ILS and SteepestDescent simulations, using Driver instances (see Drivers section). A Driver is a function which drives the pose from one state to the next. As a general rule, these Drivers are usually comprised of two important components: one or more Mutator instances (see Mutators section) and an Energy Function (see Calculators section).","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"A Mutator is a function that performs a single change in the system. For example, a DihedralMutator will rotate a random dihedral by a random amount. These can be parametrized for more specific needs.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"An EnergyFunction evaluates the fitness of a given Pose based on a set of EnergyFunctionComponent instances. These can be distance-based restrictions, positional agreement with machine learning models (such as TorchANI), etc. ","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"ukw: Note:\nSome commonly used EnergyFunction instances can be found in the Common module.","category":"page"},{"location":"getting-started/first-steps/#Modular-system","page":"First steps","title":"Modular system","text":"","category":"section"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"ProtoSyn.jl package is organized in a modular fashion, with each new module adding specific methods and features relative to a given scientific area of expertise. All these modules build on top of the base Core module. For example, in the Core module, ProtoSyn.load is able to read a PDB file into a Pose struct, but calling ProtoSyn.Peptides.load (from the Peptides module) will also infer peptidic connections between amino acids, setting the correct parenthood relationships between residues in the pose's graph and rename Atom instances to the expected IUPAC convention used in peptides, returning a much more information complete Pose.","category":"page"},{"location":"getting-started/first-steps/#Next-steps","page":"First steps","title":"Next steps","text":"","category":"section"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"This section aimed to provide a very brief and general overview on how ProtoSyn is organized, but there so much more to learn and explore:","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"Check the Examples page for tutorials on how to use some of ProtoSyn.jl's functionalities.\nIf you want a deeper dive into the inner workings of this package, check the ProtoSyn.jl API section.\nCheck the ProtoSyn.jl blog and Dev log for a behind-the-scenes look into the decision-making process behind the project.\nCreate a new issue at the ProtoSyn.jl GitHub page if you have any question.\nFeel free to collaborate and commit new changes to ProtoSyn.jl.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/methods/graph/#core-graph-methods","page":"Graph","title":"Graph","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"This section lists functions that work on the system Graph, such as functions that deal with parent/child relations, indexes and bonds, among others. These are subdivided by topics, for organization purposes:","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Root vs Origin\nParenthood relationships\nContainer manipulation\nIndexation\nCounters and Iterators\nBonds\nTravelling the Graph","category":"page"},{"location":"protosyn-api/core/methods/graph/#Root-vs-Origin","page":"Graph","title":"Root vs Origin","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"The root of a Graph is a set of 3 pseudoatoms belonging to a Topology, acting as the anchor for internal coordinate calculations, while an origin is any Atom instance with no parent in any given container (for example, due to a cut). While a Pose can only have 1 root, it can have multiple origins (which usually need to be reconnected for most of the simulations of ProtoSyn).","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"origin\nroot\nRoot","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.origin","page":"Graph","title":"ProtoSyn.origin","text":"origin(container::AbstractContainer)\n\nReturn the first Atom in AbstractContainer container that has no parent. The iteration follows the Atom instance :id field, if correctly indexed. If no Atom instance without parent is found (i.e.: circular structures), return nothing. Note that the root atoms are not considered. Note that if multiple origin Atom instances exists, this method return only the first found, based on the current Atom order in the given AbstractContainer container.\n\nSee also\n\nroot reindex sort_atoms_by_graph!\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.root","page":"Graph","title":"ProtoSyn.root","text":"root(container::AbstractContainer)\n\nReturn the first Atom of the Root of the Graph that given AbstractContainer container belongs to. If the given AbstractContainer container is not a Topology instance and has :container field set to nothing, return nothing.\n\nroot(topology::Topology)\n\nReturn the first Atom of the Root of the given Topology topology instance.\n\nSee also\n\norigin\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.Root","page":"Graph","title":"ProtoSyn.Root","text":"Root()::Residue\n\nReturn a new Root residue. A Root residue in a pseudo-residue that serves the purpose of establishing an anchor for initial internal coordinates definition.\n\nExamples\n\njulia> root = ProtoSyn.Root()\nResidue{/ROOT:17124}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#Parenthood-relationships","page":"Graph","title":"Parenthood relationships","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Atom and Residue instances have parenthood relationships, in a directional Graph. Several methods allow the manipulation of such relationships, and are of additional importance when using internal coordinates to facilitate and speed up some calculations.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"hasparent\nisparent\nsetparent!\npopparent!\nascendents\nBase.detach\nis_contiguous\ninfer_parenthood!","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.hasparent","page":"Graph","title":"ProtoSyn.hasparent","text":"hasparent(c::AbstractContainer) -> Bool\n\nTest whether the given AbstractContainer c has a parent.\n\nSee Also\n\nisparent\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.isparent","page":"Graph","title":"ProtoSyn.isparent","text":"isparent(parent::AbstractContainer, child::AbstractContainer)\n\nTest whether parent is the parent of child.\n\nSee Also\n\nhasparent\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.setparent!","page":"Graph","title":"ProtoSyn.setparent!","text":"setparent!(child::T, parent::T) where {T <: AbstractContainer}\n\nSet parent as the parent of child, while adding child to parent.children.\n\nSee also\n\npopparent!\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.popparent!","page":"Graph","title":"ProtoSyn.popparent!","text":"popparent!(child::AbstractContainer}\n\nRemove the parent from child (sets it to nothing) while removing child from parent.children (only if child is a child of parent).\n\nSee also\n\nsetparent!\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.ascendents","page":"Graph","title":"ProtoSyn.ascendents","text":"ascedents(container::AbstractContainer, level::Int)\n\nReturn a Tuple containing the N (level) previous :id fields of the :parent AbstractContainer instances of the given container (recursivelly).\n\nExamples\n\njulia> ascendents(pose.graph[1][1][4], 4)\n(4, 3, 1, 0)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#Base.detach","page":"Graph","title":"Base.detach","text":"detach(segment::Segment)\n\nDetach and return the given Segment from it's container Graph, by:\n\nDetaching any Atom and Residue instance from the Graph's Root (by popping parenthood relationships), if said instances belong to the given Segment instance.\nDeleting this Segment from its container Topology. \n\nThis function is a Base module overload.\n\nukw: Note:\nThis function does not alter the State of the Pose containing the provided Segment. \n\nExamples\n\njulia> detach(pose.graph[1])\nSegment{/UNK:1}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.is_contiguous","page":"Graph","title":"ProtoSyn.is_contiguous","text":"is_contiguous(pose::Pose, selection::AbstractSelection)\n\nReturns true if all the Residue instances gathered from the selection applied to the given pose are contiguous (have a parenthood relationship connecting them all). Note that the given selection is always promoted to Residue level.\n\nSee also\n\nProtoSyn.promote\n\nExamples\n\njulia> ProtoSyn.is_contiguous(pose, rid\"1\" | rid\"3\")\nfalse\n\njulia> ProtoSyn.is_contiguous(pose, rid\"1:10\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.infer_parenthood!","page":"Graph","title":"ProtoSyn.infer_parenthood!","text":"infer_parenthood!(container::ProtoSyn.AbstractContainer; overwrite::Bool = false, start::Opt{Atom} = nothing)\n\nInfers parenthood of Atom instances on the given AbstractContainer container, from bond information, using a custom algorithm similar to breath first algorithm (atoms are sorted based on the size of the downstream graph and aromaticity). By default, the Graph origin is set to the first Atom instance in the container. This behaviour can be controlled by setting a start Atom as the origin of the new infered parenthood Graph. If overwrite is set to true (false, by default), will overwrite existing pranthood information. After infering parenthood, if changes to the Graph occurred, the existing internal coordinates match different cartesian coordinates. It's suggested to update internal coordinates (request_i2c! & sync!). For more details, see the Travelling the Graph section. If the linear_aromatics flag is set to true (is, by default), aromatic rings are treated as isolated structures is an otherwise linear Graph (for example, in some protein aminoacids). More complex structures (such as carbon sheets) have interlaced aromatic rings, and the linear_aromatics should be set to false to ensure all Atom instances are visited.\n\nSee also\n\ntravel_bonds infer_bonds!\n\nExamples\n\njulia> ProtoSyn.infer_parenthood!(pose.graph[1], overwrite = true)\nSegment{/2a3d:8625/A:1}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"(Image: ProtoSyn graph)","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Figure 1 | A diagram of a directional Graph in ProtoSyn.","category":"page"},{"location":"protosyn-api/core/methods/graph/#Container-manipulation","page":"Graph","title":"Container manipulation","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Atom instances have a :container field, setting the container AbstractContainer (usually a Residue instance). The same logic applies to Residue instances, inside Segment structs, and Segment instances inside Topology structs (according to the established hierarchy of AbstractContainer instances). The following methods allow for the correct manipulation of this relations, allowing to add and remove AbstractContainer instances from the respective :container field, as well as creating copies of them.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"hascontainer\nBase.push!(::AbstractContainer{T}, ::T) where {T<:AbstractContainer}\nBase.insert!(::AbstractContainer{T}, ::Integer, ::T) where {T <: AbstractContainer}\nBase.delete!(::AbstractContainer{T}, ::T) where {T<:AbstractContainer}\nBase.copy(::Atom)\nrename!\nAtom!\nResidue!\nSegment!","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.hascontainer","page":"Graph","title":"ProtoSyn.hascontainer","text":"hascontainer(c::AbstractContainer)\n\nReturn true if the given AbstractContainer.container is not nothing.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#Base.push!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T<:ProtoSyn.AbstractContainer","page":"Graph","title":"Base.push!","text":"push!(container::AbstractContainer{T}, item::T) where {T <: AbstractContainer}\n\nAdd an AbstractContainer item to the AbstractContainer container, updating the container size and setting the correct item.container. Return the altered container.\n\npush!(residue::Residue, atom::Atom)\n\nIn the specific case of adding an Atom atom to a Residue residue, also add the atom.name to the residue.itemsbyname dictionary for correct indexation by name. Return the altered Residue residue.\n\npush!(container::AbstractContainer{T}, items::Vector{T}) where {T <: AbstractContainer}\n\nAdd a vector of AbstractContainer items in the AbstractContainer container, updating the container size and setting the correct item.container for each item in the items. Note that this method keeps the order of items. Return the altered container.\n\nThis function is a Base module overload.\n\nukw: Note:\nThis function does not set any Bonds or Parenthood relationships to other items in the same container. This function does not set a complementary State.\n\nSee also\n\ninsert! delete!\n\nExamples\n\njulia> push!(pose.graph[1][1], Atom(\"CA\", -1, -1, \"C\"))\nResidue{/UNK:1/UNK:1/SER:1}\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/graph/#Base.insert!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, Integer, T}} where T<:ProtoSyn.AbstractContainer","page":"Graph","title":"Base.insert!","text":"insert!(container::AbstractContainer{T}, index::Integer, item::T) where {T <: AbstractContainer}\n\nInsert an AbstractContainer item in the AbstractContainer container at the given index, updating the container size and setting the correct item.container. Return the altered container.\n\ninsert!(container::Residue, index::Integer, item::Atom)\n\nIn the specific case of inserting an Atom atom in a Residue residue, also add the atom.name to the residue.itemsbyname dictionary for correct indexation by name. Return the altered Residue residue.\n\ninsert!(container::AbstractContainer{T}, index::Integer, items::Vector{T}) where {T <: AbstractContainer}\n\nInsert a vector of AbstractContainer items in the AbstractContainer container at the given index, updating the container size and setting the correct item.container for each item in the items. Note that this method keeps the order of items. Return the altered container.\n\nThis function is a Base module overload.\n\nukw: Note:\nThis function does not set any Bonds or Parenthood relationships to other items in the same container. This function does not set a complementary State.\n\nSee also\n\npush! delete!\n\nExamples\n\njulia> insert!(pose.graph[1][1], 3, Atom(\"CA\", -1, -1, \"C\"))\nResidue{/UNK:1/UNK:1/SER:1}\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/graph/#Base.delete!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T<:ProtoSyn.AbstractContainer","page":"Graph","title":"Base.delete!","text":"delete!(container::AbstractContainer{T}, item::T) where {T <: AbstractContainer}\n\nDelete the given AbstractContainer item from the AbstractContainer container, if found, while updating the container.size and item.container fields. In the specific case of deleting an Atom instance from a Residue, update container.itemsbyname as well. Return the altered container. If the given AbstractContainer item is not found in the AbstractContainer container, return nothing.\n\nSee also\n\npush! insert!\n\nExamples\n\njulia> delete!(pose.graph[1][1], pose.graph[1][1][\"CA\"])\nResidue{/UNK:1/UNK:1/SER:1}\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/graph/#Base.copy-Tuple{Atom}","page":"Graph","title":"Base.copy","text":"copy(container::AbstractContainer)\n\nReturn a copy of the given AbstractContainer container. Note that for Residue instances only the intra-residue Bonds and Parenthood relationships can be copied. The same logic applies to the intra-segment Graph.\n\nExample\n\njulia> copy(pose.graph[1, 1, 1])\nAtom{/N:1}\n\njulia> copy(pose.graph[1, 1])\nResidue{/SER:1}\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.rename!","page":"Graph","title":"ProtoSyn.rename!","text":"rename!(atom::Atom, name::String; force_rename::Bool = false)\n\nRename the selected Atom instance to the given name. Also updates the Atom container :itemsbyname field. If force_rename is set to true (false, by default), will change existing Atom instances with the same name trying to be introduced to adopt a temporary name (current name with \"_o\" appendix).\n\nExamples\n\njulia> ProtoSyn.rename!(pose.graph[1][1][\"N\"], \"N1\")\nAtom{/2a3d:51894/A:1/MET:1/N1:1}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.Atom!","page":"Graph","title":"ProtoSyn.Atom!","text":"Atom!(r::Residue, name::String, id::Int, index::Int, symbol::String)\n\nCreate a new Atom (with the given name, id, index and symbol) and add it to the given Residue residue. Returns the created Atom instance.\n\nExamples\n\njulia> atom = Atom!(pose.graph[1][1], \"H1\", 1, 1, \"H\")\nAtom{/UNK:1/UNK:1/SER:1/H1:1}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.Residue!","page":"Graph","title":"ProtoSyn.Residue!","text":"Residue!(segment::Segment, name::String, id::Int)::Residue\n\nCreate a new Residue (with the given name and id) and add it to the given Segment segment. Returns the created Residue instance.\n\nExamples\n\njulia> res = Residue!(pose.graph[1], \"ALA\", 1)\nResidue{/UNK:1/UNK:1/ALA:1}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.Segment!","page":"Graph","title":"ProtoSyn.Segment!","text":"Segment!(topology::Topology, name::String, id::Int)::Residue\n\nCreate a new Segment (with the given name and id) and add it to the given Topology topology. Returns the created Segment instance.\n\nExamples\n\njulia> seg = Segment!(pose.graph, \"UNK\", 1)\nSegment{/UNK:1/UNK:1}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#core-graph-methods-indexation","page":"Graph","title":"Indexation","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"An important initial detail when describing the Graph methods is describing the family of getindex methods overloaded by ProtoSyn when dealing with Graph structures. There is, in essence, 4 ways to access a specific instance in the Graph:","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Using the regular syntax;","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"using ProtoSyn\nusing ProtoSyn.Peptides\npose = ProtoSyn.build(Peptides.grammar, seq\"GME\")","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"pose.graph.items[1].items[1].items[1]\npose.graph.items[1].items[1]","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Using the short syntax with index;","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"pose.graph[1][1][1]\npose.graph[1][1]","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Using the condensed syntax with index;","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"pose.graph[1, 1, 1]\npose.graph[1, 1]","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Using the short or condensed syntax with atom name (for Atom instances only).","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"pose.graph[1][1][\"N\"]\npose.graph[1, 1, \"N\"]","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Note that queries by Atom.name are case sensitive. Besides using it to get Graph structures, Atom.name fields can also be used to query for existence:","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"\"N\" in pose.graph[1][1]","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"The following methods deal with the correct indexation of the Graph. Note that, altough not necessary, some simulation functions assume that both the Graph and State indexation of a Pose are synched and are equal.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"genid\nreindex(::Topology; ::Bool)\nids","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.genid","page":"Graph","title":"ProtoSyn.genid","text":"genid()\n\nReturn a random UInt16 number.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.reindex-Tuple{Topology}","page":"Graph","title":"ProtoSyn.reindex","text":"reindex(topology::Topology; set_ascendents = true)\n\nRe-indexes the whole Topology topology, setting both the :id and :index of instances inside the topology to the corresponding relative index in the container.items which they belong to. If set_ascendents is set to true (is, by default), each Atom instance :ascendents field will be updated to reflect the new indices.\n\nreindex(segment::Segment)\n\nRe-indexes a Segment segment, setting both the :id and :index of instances inside the topology to the corresponding relative index in the container.items which they belong to.\n\nSee also\n\nascendents reindex(::State)\n\nExamples\n\njulia> reindex(pose.graph)\nTopology{/UNK:1}\n\njulia> reindex(pose.graph[1])\nSegment{/UNK:1/UNK:1}\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.ids","page":"Graph","title":"ProtoSyn.ids","text":"ids(atoms::Vector{Atom})\n\nReturn a vector with the :id Int field for every Atom in the given atoms vector.\n\nSee also\n\ntravel_graph\n\nExamples\n\njulia> ProtoSyn.ids(an\"CA\"(pose, gather = true))\n21-element Vector{Int64}:\n   3\n  14\n  29\n  40\n  55\n  65\n   ⋮\n 243\n 257\n 281\n 300\n 317\n 327\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#Counters-and-Iterators","page":"Graph","title":"Counters and Iterators","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"ProtoSyn includes custom Counters and Iterators to analyze and loop over Graph structures. In one hand, by using Counters the user can count the number of sub AbstractContainer instances in a Graph component (for example, the number of Atom instances in a Segment or a Residue). This can be achieved by using the count_atoms, count_residues and count_segments methods.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"ProtoSyn.count_atoms(pose.graph)\nProtoSyn.count_atoms(pose.graph[1][1])\nProtoSyn.count_residues(pose.graph)","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"On the other hand, Iterators allow the user to iterate over all sub AbstractContainer instances in a Graph component, by using the eachatom, eachresidue and eachsegment methods.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"eachatom(pose.graph)\nfor residue in eachresidue(pose.graph[1])\n    println(residue);\nend","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"For Residue instances in specific, a more direct way to list all instances in a given Pose or AbstractContainer is to use the sequence method.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"sequence","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.sequence","page":"Graph","title":"ProtoSyn.sequence","text":"sequence(container::ProtoSyn.AbstractContainer)::String\nsequence(pose::Pose)::String\n\nReturn the sequence of residues (in 1 letter code) of the given container/ Pose as a String. Checks the ProtoSyn.three_2_one dictionary for name to 1 letter code translation, uses '?' if no entry was found.\n\nExamples\n\njulia> ProtoSyn.Peptides.sequence(pose)\n\"SESEAEFKQRLAAIKTRLQAL\"\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#Bonds","page":"Graph","title":"Bonds","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"The following methods deal with the bonding/unbonding of atoms (and respective Parenthood relationships when using the join function).","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"bond\nunbond!\njoin\ninfer_bonds!","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.bond","page":"Graph","title":"ProtoSyn.bond","text":"bond(at1::Atom, at2::Atom)\n\nBond both given Atom instances (adds at2 to at1.bonds and vice-versa). Both Atom instances need to be in the same Segment.\n\nSee also\n\njoin unbond!\n\nExamples\n\njulia> ProtoSyn.bond(pose.graph[1][1][\"C\"], pose.graph[1][2][\"CA\"])\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.unbond!","page":"Graph","title":"ProtoSyn.unbond!","text":"unbond!(pose::Pose, at1::Atom, at2::Atom; [keep_downstream_position::Bool = true])::Pose\n\nReturn a Pose instance with both given Atom instances unbonded (removed from eachother bonds list, pops parenthood and sets the downstream Residue.parent field to be the Root of the upstream Topology). If keep_downstream_position is set to true (is, by default), the downstream Residue position is maintained (by calling request_c2i! and sync! methods). \n\nukw: Note:\nUnbonding two atoms also removes any parenthood relationship, therefore making the returned Pose from this function un-usable without further changes (the internal coordinates graph is severed on the unbonding site).\n\nExamples\n\njulia> unbond!(pose, pose.graph[1][2][\"C\"], pose.graph[1][3][\"N\"])\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.join","page":"Graph","title":"ProtoSyn.join","text":"join(at1::Atom, at2::Atom)\n\nJoin Atom at1 with Atom at2.\n\njoin(r1::Residue, s1::String, r2::Residue, s2::String)\n\nJoin Atom named s1 from Residue r1 with Atom named s2 from Residue r2.\n\nBond (add eachother to other.bonds field) and set parent/children relationship of both the Atom instances and respective atom.container (Residue). Note that at2 Atom will become parent at at1 (and at2.container Residue will become parent of at1.container).\n\nSee also\n\nbond unbond!\n\nExamples\n\njulia> Residue!(pose.graph[1], ProtoSyn.ResidueName(\"ALA\"), 1);\n\njulia> Atom!(pose.graph[1][end], \"N\", 1, 1, \"N\");\n\njulia> ProtoSyn.join(pose.graph[1][1], \"C\", pose.graph[1][end], \"N\")\nResidue{/UNK:1/UNK:1/ALA:1}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.infer_bonds!","page":"Graph","title":"ProtoSyn.infer_bonds!","text":"infer_bonds!(pose::Pose; [threshold::T = 0.1]) where {T <: AbstractFloat}\n\nInfers bonds for all Atom instances of the given Pose. A new bond is assigned when a pair of Atom instances are within a given distance, as defined in ProtoSyn.Units.bond_lengths. The threshold value is multiplied by the standard bond distance and added to the comparison value to allow some leeway in the bond distance (0.1, by default).\n\nSee also\n\ntravel_bonds infer_parenthood!\n\nExamples\n\njulia> ProtoSyn.infer_bonds!(pose)\nPose{Topology}(Topology{/CRV:54976}, State{Float64}:\n Size: 201\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#Travelling-the-Graph","page":"Graph","title":"Travelling the Graph","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"As further explored in the Graph section, the directed nature of the Pose's Graph allows for easy travelling of the system. The following methods facilitate that process.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"get_graph_size\nsort_children\ntravel_graph\ntravel_bonds\nidentify_atom_by_bonding_pattern","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.get_graph_size","page":"Graph","title":"ProtoSyn.get_graph_size","text":"get_graph_size(atom::Atom; depth::Int = 1, max_depth::Int = 10)\n\nRecursivelly search the the Graph starting from Atom atom (inclusive) until no children are identified or the depth > max_depth (10, by default).\n\nExamples\n\njulia> ProtoSyn.get_graph_size(pose.graph[1][73][\"CA\"])\n13\n\njulia> ProtoSyn.get_graph_size(pose.graph[1][73][\"C\"])\n3\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.sort_children","page":"Graph","title":"ProtoSyn.sort_children","text":"sort_children(atom::Atom; rev::Bool = false)\n\nSort the given Atom atom children, by the following criteria:\n\nBy Graph size (follow Graph by employing the get_graph_size, small chains first)\nBy Atom name (in case all children chains have the same size; alphabetical order)\n\nBy setting rev to true (false, by default), reverses the provided order.\n\nsort_children!(atom::Atom; rev::Bool = false)\n\nSort the given Atom atom children and save the newly sorted childen in atom.bonds.\n\nExamples\n\njulia> ProtoSyn.sort_children!(pose.graph[1][72][\"CA\"])\n3-element Vector{Atom}:\n Atom{/2a3d:31788/A:1/HIS:72/HA:1112}\n Atom{/2a3d:31788/A:1/HIS:72/CB:1113}\n Atom{/2a3d:31788/A:1/HIS:72/C:1124}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.travel_graph","page":"Graph","title":"ProtoSyn.travel_graph","text":"travel_graph(start::Atom; [stop::Opt{Atom} = nothing], [search_algorithm::F = ProtoSyn.BFS]) where {F <: SearchAlgorithm})\n\nReturn a Vector{Atom} with all atom instances between Atom start and stop (inclusive), while following the structure's Graph. If no stop Atom instance is provided or if it isn't found as a downstream parent of the start Atom, all instances until no children Atom instances are found are returned (for example, until the end of the current Pose of Segment). By default, uses Breath First Search (BFS) algorithm (all Atom instances at the same \"graph-distance\" to the start Atom are consumed before the next level is considered, order is given by sort_children). Optionally, by setting search_algorithm to ProtoSyn.DFS, can employ Depth First Algorithm (DFS) (the largest chain of atom.children is recursively exhausted before consuming the smaller chains, order is given by sort_children).\n\nSee also\n\nis_contiguous hasparent setparent!\n\nExamples\n\njulia> ProtoSyn.travel_graph(pose.graph[1][5][\"N\"], stop = pose.graph[1][6][\"N\"], search_algorithm = ProtoSyn.BFS)\n11-element Vector{Atom}:\n Atom{/2a3d:31788/A:1/ALA:5/N:62}\n Atom{/2a3d:31788/A:1/ALA:5/H:63}\n Atom{/2a3d:31788/A:1/ALA:5/CA:64}\n Atom{/2a3d:31788/A:1/ALA:5/HA:65}\n Atom{/2a3d:31788/A:1/ALA:5/CB:66}\n Atom{/2a3d:31788/A:1/ALA:5/C:70}\n Atom{/2a3d:31788/A:1/ALA:5/HB3:69}\n Atom{/2a3d:31788/A:1/ALA:5/HB2:68}\n Atom{/2a3d:31788/A:1/ALA:5/HB1:67}\n Atom{/2a3d:31788/A:1/ALA:5/O:71}\n Atom{/2a3d:31788/A:1/GLU:6/N:72}\n\njulia> ProtoSyn.travel_graph(pose.graph[1][5][\"N\"], stop = pose.graph[1][6][\"N\"], search_algorithm = ProtoSyn.DFS)\n4-element Vector{Atom}:\n Atom{/2a3d:31788/A:1/ALA:5/N:62}\n Atom{/2a3d:31788/A:1/ALA:5/CA:64}\n Atom{/2a3d:31788/A:1/ALA:5/C:70}\n Atom{/2a3d:31788/A:1/GLU:6/N:72}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.travel_bonds","page":"Graph","title":"ProtoSyn.travel_bonds","text":"travel_graph(start::Atom; [stop::Opt{Atom} = nothing], [search_algorithm::F = ProtoSyn.BFS]) where {F <: SearchAlgorithm})\n\nReturn a Vector{Atom} with all atom instances between Atom start and stop (inclusive), while following the structure's Graph. If no stop Atom instance is provided or if it isn't found as a downstream parent of the start Atom, all instances until no children Atom instances are found are returned (for example, until the end of the current Pose of Segment). By default, uses Breath First Search (BFS) algorithm (all Atom instances at the same \"graph-distance\" to the start Atom are consumed before the next level is considered, order is given by sort_children). Optionally, by setting search_algorithm to ProtoSyn.DFS, can employ Depth First Algorithm (DFS) (the largest chain of atom.children is recursively exhausted before consuming the smaller chains, order is given by sort_children).\n\nSee also\n\nis_contiguous hasparent setparent!\n\nExamples\n\njulia> ProtoSyn.travel_graph(pose.graph[1][5][\"N\"], stop = pose.graph[1][6][\"N\"], search_algorithm = ProtoSyn.BFS)\n11-element Vector{Atom}:\n Atom{/2a3d:31788/A:1/ALA:5/N:62}\n Atom{/2a3d:31788/A:1/ALA:5/H:63}\n Atom{/2a3d:31788/A:1/ALA:5/CA:64}\n Atom{/2a3d:31788/A:1/ALA:5/HA:65}\n Atom{/2a3d:31788/A:1/ALA:5/CB:66}\n Atom{/2a3d:31788/A:1/ALA:5/C:70}\n Atom{/2a3d:31788/A:1/ALA:5/HB3:69}\n Atom{/2a3d:31788/A:1/ALA:5/HB2:68}\n Atom{/2a3d:31788/A:1/ALA:5/HB1:67}\n Atom{/2a3d:31788/A:1/ALA:5/O:71}\n Atom{/2a3d:31788/A:1/GLU:6/N:72}\n\njulia> ProtoSyn.travel_graph(pose.graph[1][5][\"N\"], stop = pose.graph[1][6][\"N\"], search_algorithm = ProtoSyn.DFS)\n4-element Vector{Atom}:\n Atom{/2a3d:31788/A:1/ALA:5/N:62}\n Atom{/2a3d:31788/A:1/ALA:5/CA:64}\n Atom{/2a3d:31788/A:1/ALA:5/C:70}\n Atom{/2a3d:31788/A:1/GLU:6/N:72}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.identify_atom_by_bonding_pattern","page":"Graph","title":"ProtoSyn.identify_atom_by_bonding_pattern","text":"identify_atom_by_bonding_pattern(container::AbstractContainer, pattern::Vector{String})\n\nReturns one or more candidate Atom instances from the given AbstractContainer container that match the provided pattern (a Vector of Atom elements). This method follows the following hierarchical criteria:\n\nExamples\n\njulia> ProtoSyn.identify_atom_by_bonding_pattern(pose.graph[1][1], [\"H\", \"N\", \"C\", \"C\"])\n3-element Vector{Atom}:\n Atom{/2a3d:3900/A:1/MET:1/H1:2}\n Atom{/2a3d:3900/A:1/MET:1/H2:3}\n Atom{/2a3d:3900/A:1/MET:1/H3:4}\n\njulia> ProtoSyn.identify_atom_by_bonding_pattern(pose.graph[1][1], [\"C\", \"C\", \"C\", \"C\", \"H\"])\nAtom{/2a3d:3900/A:1/MET:1/C:18}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"As explained above, certain methods in ProtoSyn travel the directed graph. There are, however, multiple ways to follow the same graph (as longs as its ramified), depending on the criteria used on bifurcations. In the Core module, ProtoSyn makes available for the BFS (breath-first search) and DFs (depth-first search) algorithms, a type of SearchAlgorithm.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"BFS\nDFS","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.BFS","page":"Graph","title":"ProtoSyn.BFS","text":"(ProtoSyn.BFS)(atom::Atom, stack::Vector{Atom})\n\nBreath first search algorithm for travel_graph. Correctly sorts the given Atom atom children instances and concatenates with the current stack.\n\nExamples\n\njulia> ProtoSyn.BFS(pose.graph[1][1][\"CA\"], Vector{Atom}())\n3-element Vector{Atom}:\n Atom{/test:36441/A:1/MET:1/HA:6}\n Atom{/test:36441/A:1/MET:1/C:7}\n Atom{/test:36441/A:1/MET:1/CB:8}\n\n\n\n\n\n","category":"constant"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.DFS","page":"Graph","title":"ProtoSyn.DFS","text":"(ProtoSyn.DFS)(atom::Atom, stack::Vector{Atom})\n\nDepth first search algorithm for travel_graph. Correctly sorts the given Atom atom children instances and concatenates with the current stack.\n\nExamples\n\njulia> ProtoSyn.DFS(pose.graph[1][1][\"CA\"], Vector{Atom}())\n3-element Vector{Atom}:\n Atom{/test:36441/A:1/MET:1/CB:8}\n Atom{/test:36441/A:1/MET:1/C:7}\n Atom{/test:36441/A:1/MET:1/HA:6}\n\n\n\n\n\n","category":"constant"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"CurrentModule = ProtoSyn.Calculators","category":"page"},{"location":"protosyn-api/core/calculators/torchani/#TorchANI","page":"TorchANI","title":"TorchANI","text":"","category":"section"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"TorchANI is a Python implementation of ANI machine learning model for energy calculation. Trained on a large dataset of DFT calculation results, TorchANI is able to obtain DFT-level accuracy in energy calculation in a fraction of the time. For more details, read the original paper. Making use of the PyCall package and Julia's native methods for code integration, ProtoSyn incorporates TorchANI as an EnergyFunctionComponent. The following section explains this integration in more detail, sub-divided in the following topics:","category":"page"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"TorchANI EnergyFunctionComponent\nTorchANI XML-RPC server\nTorchANI reference energy EnergyFunctionComponent","category":"page"},{"location":"protosyn-api/core/calculators/torchani/#TorchANI-EnergyFunctionComponent","page":"TorchANI","title":"TorchANI EnergyFunctionComponent","text":"","category":"section"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"Calculators.TorchANI.get_ani_species\nCalculators.TorchANI.calc_torchani_ensemble\nCalculators.TorchANI.calc_torchani_model\nCalculators.TorchANI.get_default_torchani_ensemble\nCalculators.TorchANI.get_default_torchani_model","category":"page"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.get_ani_species","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.get_ani_species","text":"get_ani_species(container::ProtoSyn.AbstractContainer)\n\nReturn a Vector{Int} with the atomic number of each Atom instance in the given AbstractContainer container, according to a periodic table.\n\nSee also\n\ncalc_torchani_model calc_torchani_ensemble\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.get_ani_species(pose.graph[1][1])\n11-element Vector{Int64}:\n 7\n 1\n 6\n 1\n 6\n 1\n 1\n 8\n 1\n 6\n 8\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.calc_torchani_ensemble","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.calc_torchani_ensemble","text":"Calculators.calc_torchani_ensemble([::A], pose::Pose, update_forces::Bool = false) where {A <: ProtoSyn.AbstractAccelerationType}\n\nCalculate and return the Pose pose energy according to the whole TorchANI neural network ensemble. The optional A parameter defines the acceleration type used. If left undefined the default ProtoSyn.acceleration.active mode will be used. By setting the update_forces flag to true (false by default), this function will also calculate and return the forces acting on each atom based on the whole TorchANI neural network ensemble.\n\nSee also:\n\ncalc_torchani_model\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_ensemble(pose)\n(-0.12801790237426758, nothing)\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_ensemble(pose, true)\n(-0.12801788747310638, [ ... ])\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.calc_torchani_model","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.calc_torchani_model","text":"calc_torchani_model([::A], pose::Pose, selection::Opt{AbstractSelection}, update_forces::Bool = false; model::Int = 3) where {A}\n\nCalculate and return the Pose pose energy according to a single TorchANI model neural network. The model can be defined using model_index (from model 1 to 8, default is 3).The optional A parameter defines the acceleration type used. If left undefined the default ProtoSyn.acceleration.active mode will be used. By setting the update_forces flag to true (false by default), this function will also calculate and return the forces acting on each atom based on a single TorchANI model neural network.\n\nukw: Note:\nEach model will return a slightly different value for the energy of the molecular system. Use calc_torchani_ensemble for a more accurate (and slow) energy prediction. However, as in most cases the energy value is used in comparison with multiple states/frames, calc_torchani_ensemble prediction may be suficient.\n\nSee also:\n\ncalc_torchani_ensemble calc_torchani_model_xmlrpc\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_model(pose)\n(-0.12573561072349548, nothing)\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_model(pose, true)\n(-0.12573561072349548, [ ... ])\n\nukw: Note:\nIn ProtoSyn >= 1.0, this function has a memory leak on the Python call. Multiple calls to calc_torchani_model require often GC.gc(false) calls to impede the 'CUDA out of memory' error. In order to prevent/automate this process, consider the following options:(1) - Use an EnergyFunction struct (with automatic calls to GC.gc(false), as in:EnergyFunction([ProtoSyn.Calculators.TorchANI.get_default_torchani_model()])(2) - Use calc_torchani_model_xmlrpc instead.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.get_default_torchani_ensemble","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.get_default_torchani_ensemble","text":"get_default_torchani_ensemble(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default TorchANI ensemble EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). This component employs the calc_torchani_ensemble method, therefore predicting a structure's TorchANI energy based on the whole TorchANI ensemble (Note: This can be very slow).\n\nSee also\n\ncalc_torchani_ensemble get_default_torchani_model\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.get_default_torchani_ensemble()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | TorchANI_ML_Ensemble             |\n| Alpha (α)      | 1.0                              |\n| Update forces  | true                             |\n| Calculator     | calc_torchani_ensemble           |\n+---------------------------------------------------+\n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.get_default_torchani_model","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.get_default_torchani_model","text":"get_default_torchani_model(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default TorchANI model EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). This component employs the calc_torchani_model method, therefore predicting a structure's TorchANI energy based on a single model.\n\nSettings\n\nmodel::Int - Defines which model of the TorchANI ensemble to use.\n\nSee also\n\ncalc_torchani_model get_default_torchani_ensemble\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.get_default_torchani_model()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | TorchANI_ML_Model                |\n| Alpha (α)      | 1.0                              |\n| Update forces  | true                             |\n| Calculator     | calc_torchani_model              |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | model                         | 3                                                |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"(Image: ProtoSyn TorchANI Components)","category":"page"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"Figure 1 | A diagram representation of the default TorchANI ML Ensemble and TorchANI ML Model EnergyFunctionComponent instances, obtained by usign the get_default_torchani_ensemble and get_default_torchani_model methods, respectively. While the TorchANI ML Ensemble is more accurate, it's also significantly slower. Depending on the application, employing a single model of the ensemble (of 8 models) might be sufficient.","category":"page"},{"location":"protosyn-api/core/calculators/torchani/#TorchANI-XML-RPC-server","page":"TorchANI","title":"TorchANI XML-RPC server","text":"","category":"section"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"ProtoSyn also makes available the TorchANI ML Model EnergyFunctionComponent instance as a call to an XML-RPC server. This protocol spawns a Python server in parallel, running TorchANI, who receives XML requests from Julia and returns the calculated energy and forces. This functionality might be useful in certain systems and machines.","category":"page"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"Calculators.TorchANI.start_torchANI_server\nCalculators.TorchANI.stop_torchANI_server\nCalculators.TorchANI.calc_torchani_model_xmlrpc\nCalculators.TorchANI.get_default_torchani_model_xmlrpc","category":"page"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.start_torchANI_server","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.start_torchANI_server","text":"start_torchANI_server()\n\nIf TorchANI.server is set to nothing, start a new TorchANI XML-RPC server. Return a XMLRPC.ClientProxy (used to send XML requests to the created server).\n\nSee also:\n\nstop_torchANI_server\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.start_torchANI_server()\nStarting TorchANI XML-RPC server ...\nTorchANI XML-RPC server is online!\nProtoSyn.XMLRPC.ClientProxy(\"http://localhost\", 50000, \"http://localhost:50000\")\n\njulia> ProtoSyn.Calculators.TorchANI.start_torchANI_server()\n┌ Warning: TorchANI XML-RPC server is already online!\n└ @ ProtoSyn.Calculators.TorchANI ~/project_c/ProtoSyn.jl/src/Core/Calculators/torchani_xmlrpc.jl:25\nProtoSyn.XMLRPC.ClientProxy(\"http://localhost\", 50000, \"http://localhost:50000\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.stop_torchANI_server","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.stop_torchANI_server","text":"stop_torchANI_server()\n\nIf TorchANI.server is not set to nothing, kill the current TorchANI XML-RPC server.\n\nSee also:\n\nstart_torchANI_server\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.stop_torchANI_server()\n\njulia> ProtoSyn.Calculators.TorchANI.stop_torchANI_server()\n┌ Warning: No online TorchANI XML-RPC server was found.\n└ @ ...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.calc_torchani_model_xmlrpc","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.calc_torchani_model_xmlrpc","text":"Calculators.calc_torchani_model_xmlrpc([::A], pose::Pose, selection::Opt{AbstractSelection}, [update_forces::Bool = false]; [model::Int = 3]) where {A}\n\nCalculate the pose energy according to a single TorchANI model neural network, using the XML-RPC protocol. If no TorchANI XML-RPC server is found, a new one is spawned (in parallel) from file torchani_server.py. The model can be defined using model (from model 1 to 8, default is 3). The optional A parameter defines the acceleration mode used (only CUDA_2 is available, any other acceleration type will result in an error). If left undefined the default ProtoSyn.acceleration.active type will be used. If update_forces is set to true (false, by default), return the calculated forces on each atom as well.\n\nSee also\n\ncalc_torchani_ensemble calc_torchani_model\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_model_xmlrpc(pose)\n(4.698066234588623, nothing)\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_model_xmlrpc(pose, true)\n(4.698066234588623, [ ... ])\n\nukw: Note:\nIf you use this function in a script, it is recommended to add ProtoSyn.Calculators.TorchANI.stop_torchANI_server() at the end of the script, as the automatic stopping of TorchANI XML-RPC server is not yet implemented, as of ProtoSyn >= 1.0.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.get_default_torchani_model_xmlrpc","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.get_default_torchani_model_xmlrpc","text":"get_default_torchani_model_xmlrpc(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default TorchANI model EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). This component employs the calc_torchani_model_xmlrpc method, therefore predicting a structure's TorchANI energy based on a single model and starting a new XMLRPC server (in parallel) if necessary.\n\nSettings\n\nmodel::Int - Defines which model of the TorchANI ensemble to use.\n\nSee also\n\ncalc_torchani_model_xmlrpc\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.get_default_torchani_model_xmlrpc()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | TorchANI_ML_Model_XMLRPC         |\n| Alpha (α)      | 1.0                              |\n| Update forces  | true                             |\n| Calculator     | calc_torchani_model_xmlrpc       |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | model                         | 3                                                |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#TorchANI-reference-energy-EnergyFunctionComponent","page":"TorchANI","title":"TorchANI reference energy EnergyFunctionComponent","text":"","category":"section"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"In design protocols (where one or more Residue mutations occur), it is often more important to measure the ΔΔG of mutation, that is, the change in the system's energy with the change of nature (and number) of particles that comprise it. Since the TorchANI EnergyFunctionComponent is, inherently, a sumation of all individual atomic energetic contributions, a change in the number of particles always comes with a change in energy (as an example, in any environment, a bigger aminoacid with almost always induce an increase in the overall system's energy, even if the interactions it creates estabilize this mutation). In fact, when using the TorchANI EnergyFunctionComponent, both the internal and interacting energy of a Residue instance are being measured. By subtracting the TorchANI reference energy EnergyFunctionComponent (that is, only a measure of the internal energy of a Residue), it is possible to have a better gauge at the interacting energies that mutation or change induces, and therefore a better estimation of the ΔΔG value.","category":"page"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"Calculators.TorchANI.calc_torchani_internal_energy\nCalculators.TorchANI.get_default_torchani_internal_energy\nCalculators.TorchANI.fixate_static_ref_energy!","category":"page"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.calc_torchani_internal_energy","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.calc_torchani_internal_energy","text":"calc_torchani_internal_energy(M::Type{<: ProtoSyn.AbstractAccelerationType}, pose::Pose, selection::AbstractSelection, [update_forces::Bool = false]; [static_ref_energy::T = 0.0], [use_ensemble::Bool = false], [model::Int = 3]) where {T <: AbstractFloat}\n\nCalculate and return the Pose pose internal energy according to a single TorchANI model neural network. The internal energy is the TorchANI energy value for intra-residue interactions only. This should be used in conjuntion with the calc_torchani_model and calc_torchani_ensemble in design efforts (thus providing a correct ΔΔG of mutation). The employed model can be defined using the model parameter (from model 1 to 8, default is 3). Optionally, if the use_ensemble flag is set to true, the whole TorchANI ensemble will be used to calculate the internal energy. The optional A parameter defines the acceleration type used. If left undefined the default ProtoSyn.acceleration.active mode will be used. By setting the update_forces flag to true (false by default), this function will also calculate and return the forces acting on each atom based on a single TorchANI model neural network. If provided, an AbstractSelection selection defines a sub-set of Residue instances to calculate the internal energy on (if the provided AbstractSelection selection is not of Residue type, it will be promoted using the promote method). The parameter static_ref_energy defines an energy value that is summed to the calculated energy. In order to improve performance: it is often the case where a single Residue instance is being design at a time. In such cases, by applying an AbstractSelection selection and defining the static_ref_energy as the internal energy of all non-mutated Residue instances, a faster internal energy calculation can be accurately reproduced. \n\nSee also:\n\ncalc_torchani_model calc_torchani_ensemble get_default_torchani_internal_energy\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_internal_energy(pose, nothing)\n(-1.9374065455049276, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.get_default_torchani_internal_energy","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.get_default_torchani_internal_energy","text":"get_default_torchani_internal_energy(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default TorchANI internal energy model EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). This component employs the calc_torchani_internal_energy method, therefore predicting a structure's TorchANI internal energy based on a single model or ensemble.\n\nSettings\n\nuse_ensemble::Bool - Defines whether to use a single model or the whole TorchANI ensemble to calculate the structure's internal energy;\nmodel::Int - If using a single model to calculate the structure's internal energy, define which model (from 1 to 8);\nstatic_ref_energy::T - Define a static energy value to add to the calculated internal energy (where T <: AbstractFloat);\n\nSee also\n\ncalc_torchani_model get_default_torchani_ensemble\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.get_default_torchani_internal_energy()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | TorchANI_Ref_Energy              |\n| Alpha (α)      | 1.0                              |\n| Update forces  | true                             |\n| Calculator     | calc_torchani_internal_energy    |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | static_ref_energy             | 0.0                                              |\n |    | use_ensemble                  | false                                            |\n |    | model                         | 3                                                |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.fixate_static_ref_energy!","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.fixate_static_ref_energy!","text":"fixate_static_ref_energy!(efc::EnergyFunctionComponent, pose::Pose, [selection::Opt{AbstractSelection} = nothing])\n\nIf the given EnergyFunctionComponent efc is a TorchANI Reference Energy EnergyFunctionComponent, calculate a new static_ref_energy on the given Pose pose and apply it as a static internal energy value (improved performance). If an AbstractSelection selection is provided, the internal energy is only calculated in the subset of selected Residue instances.\n\nSee also\n\nget_default_torchani_internal_energy\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.fixate_static_ref_energy!(efc, pose, rid\"1:20\")\n-0.3799925707280636\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/carbons/","page":"Carbons","title":"Carbons","text":"CurrentModule = ProtoSyn.Materials","category":"page"},{"location":"protosyn-api/materials/methods/carbons/#Carbons","page":"Carbons","title":"Carbons","text":"","category":"section"},{"location":"protosyn-api/materials/methods/carbons/","page":"Carbons","title":"Carbons","text":"In the next section, a brief description of the available methods to generate carbon models is provided. Following the previous work developed on CarbGen (you can check the Python version on the project's GitHub page), ProtoSyn implements methods to generate functionalized microcrystallites of multi-layered carbon sheets.","category":"page"},{"location":"protosyn-api/materials/methods/carbons/","page":"Carbons","title":"Carbons","text":"(Image: ProtoSyn Carbons)","category":"page"},{"location":"protosyn-api/materials/methods/carbons/","page":"Carbons","title":"Carbons","text":"Figure 1 | Example showcase of ProtoSyn's carbon microcrystallite generation methods. 1 | Single carbon sheet. 2 | Multi-layered carbon microcrystallite. 3 | Micro-porosity generation. 4 | Functionalization. ProtoSyn includes several common functional groups, by default, on the ProtoSyn.modification_grammar. The shown example includes ether groups, carboxyls, carbonyls, hydroxyls, amine-N groups, graphitic-N, oxidized-N groups and pyridines.","category":"page"},{"location":"protosyn-api/materials/methods/carbons/","page":"Carbons","title":"Carbons","text":"generate_carbon_layer\ngenerate_carbon\ngenerate_porosity\nperlin\nperlinoctaves\nfunctionalize!\nadd_functionalization!\nadd_hydrogens!\ngenerate_carbon_from_file","category":"page"},{"location":"protosyn-api/materials/methods/carbons/#ProtoSyn.Materials.generate_carbon_layer","page":"Carbons","title":"ProtoSyn.Materials.generate_carbon_layer","text":"generate_carbon_layer(x::Int, y::Int; [r::T = 1.4]) where {T <: AbstractFloat}\n\nThe carbon layer is generated using internal coordinates: all atoms are always placed at a distance r and angle of 120° from the parent atom, either with a clockwise or counter-clockwise rotation in the dihedral angle. For each ring added, 4 parameters need to be defined:\n\nThe number of atoms to add (N);\nThe selected atom to continue X expansion (X);\nThe selected atom to continue Y expansion (Y);\nThe bonds to add (B).\n\nSuch parameters are first compiled in 4 matrixes (1 for each) which are then consumed to generate the actual atom positions and bonds. This algorithm is, therefore, sensitive to the order of addition of layers (whether to add Y axis or X axis first, changes the N, X, Y and B matrixes, as well as rotation of dihedral angles). For this particular implementation, the X axis is added first, and all expansion is then added from this layer in the Y axis. As atoms are added, the next anchor atoms (as selected by the X and Y matrixes) are added to the A matrix. Each new ring checks this matrix for the next anchor/parent atom. All dihedral angles on the first atom of each new ring added are rotated by 180° (default is 0°), except on the first layer where the second atom added is also rotated by 180°. 6 possible bonding patterns are available:\n\nBond 4th atom to start atom\nBond 4th atom to 3rd atom of previous ring\nBond 1st atom to 3rd atom of previous ring\nBond 4th atom to parent of start atom\nPerform both 3 and 4 patterns simultaneously\nBond 2nd atom to 1st atom of previous ring\n\nBesides this \"extra\" bonds, all added atoms are bonded to the respective parent atom. Note that it's guaranteed that the main plane of the generated layer lies in the x-y plane (z cartesian coordinate = 0.0).\n\nSee also\n\ngenerate_carbon\n\nExamples\n\njulia> pose = ProtoSyn.Materials.generate_carbon_layer(5, 5)\nPose{Topology}(Topology{/CRV:65069}, State{Float64}:\n Size: 70\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/carbons/#ProtoSyn.Materials.generate_carbon","page":"Carbons","title":"ProtoSyn.Materials.generate_carbon","text":"generate_carbon(x::Int, y::Int, [z::Int = 0]; [r::T = 1.4], [d::T = 3.4]) where {T <: AbstractFloat}\n\nGenerate a carbon microcrystallite with multiple carbon sheet layers (built using generate_carbon_layer with x and y dimensions for the number of carbon rings in the x- and y-axis, respectivelly, and r distance between atoms, in Å). The generated layers are copied z times (in the x-axis) with a distance of d Å. Every odd layer is displaced to match π-π stacking chemistry in carbon sheets.\n\nSee also\n\ngenerate_porosity generate_carbon_from_file\n\nExamples\n\njulia> pose = ProtoSyn.Materials.generate_carbon(5, 5, 5)\nPose{Topology}(Topology{/CRV:23442}, State{Float64}:\n Size: 350\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/carbons/#ProtoSyn.Materials.generate_porosity","page":"Carbons","title":"ProtoSyn.Materials.generate_porosity","text":"generate_porosity(pose::Pose, pore_fraction::T; [clean_sweeps::Int = 15], [random::Bool = false], [neat_indexation::Bool = false]) where {T <: AbstractFloat}\n\nGenerate porosity on the given Pose pose by removing Atom instances according to a generated Perlin noise (see the perlin method). The pore_fraction field ajusts the amount of Atom instances removed, as a value between 0.0 and 1.0.\n\nukw: Note:\nThe pose_fraction field cannot be roughly translated as a direct percentage value of Atom instances to remove. Instead, this value refers to the perlin noise level to consider for atom removal, and as such scales exponentially. As a baseline, a pore_fraction of 0.4 removes approximately 50% of the Atom instances in the given Pose. \n\nFor high pore_fraction values, the Atom removal may leave unconnected chains of Atom instances in each Segment. Such cases should be manually verified. Since this function is intended to be applied to carbon microcrystallites, these hanging atoms may constitute carbon atoms with wrong valency numbers. This method automatically performs clean_sweeps and removes any atom with 1 or 0 bonds. If random is set to true (false, by default), the generated noise is randomized. If neat_indexation is set to true (false, by default), the sort_atoms_by_graph! method is applied to reindex Atom instances and sort them according to the new graph (after removing Atom instances).\n\nSee also\n\ngenerate_carbon\n\nExamples\n\njulia> ProtoSyn.Materials.generate_porosity(pose, 0.405)\nPose{Topology}(Topology{/CRV:36031}, State{Float64}:\n Size: 190\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/carbons/#ProtoSyn.Materials.perlin","page":"Carbons","title":"ProtoSyn.Materials.perlin","text":"perlin(x::T, y::T, z::T)\n\nCompute the perlin noise value at coordinates x, y and z. Taken from https://github.com/ararslan/ProceduralNoise.jl. All credit goes to ararslan. Based on https://gist.github.com/Flafla2/f0260a861be0ebdeef76. Hash lookup table as defined by Ken Perlin.\n\nExamples\n\njulia> ProtoSyn.Materials.perlin(0.5, 0.5, 0.5)\n0.375\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/carbons/#ProtoSyn.Materials.perlinoctaves","page":"Carbons","title":"ProtoSyn.Materials.perlinoctaves","text":"perlinoctaves(x::T, y::T, z::T, octaves::Int = 1, persistence::T = 1.0)\n\nCompute the perlin noise value at coordinates x, y and z with the given octaves. In sum, generates a perlin noise with some randomization. Taken from https://github.com/ararslan/ProceduralNoise.jl. All credit goes to ararslan. Based on https://gist.github.com/Flafla2/f0260a861be0ebdeef76. Hash lookup table as defined by Ken Perlin.\n\nExamples\n\njulia> ProtoSyn.Materials.perlinoctaves(0.5, 0.5, 0.5, 8)\n0.484375\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/carbons/#ProtoSyn.Materials.functionalize!","page":"Carbons","title":"ProtoSyn.Materials.functionalize!","text":"functionalize!(pose::Pose, functional_groups::Dict{Fragment, T}; normalize_frequencies::Bool = false) where {T <: AbstractFloat}\n\nAdd N functional groups to the given Pose pose. The number of added functional groups is given by the functional groups dictionary, mapping Fragment instances (for example, from the default ProtoSyn.modification_grammar) to a percentage of achoring points available. By default, anchoring points are non-charged carbon Atom instances. If the normalize_frequencies flag is set to true (false, by default), ProtoSyn normalizes the input functional_groups dictionary so that all possible non-charged carbon Atom instances are functionalized (in proportional percentages to the input dictionary). Note that this method expects correctly ordered Segment instances (1 is bottom, :end is top).\n\nukw: Note:\nThe reason only non-charged carbon Atom instances are considered for functionalization is because ProtoSyn automatically assigns a charge when adding a functional group. Therefore, only non-charged Atom instances are left \"open\" for functionalization.\n\n\n\nfunctionalize!(pose::Pose, functional_groups::Dict{Fragment, Int})\n\nIn an alternative syntax, the functional_groups fictionary directly maps Fragment instances to the actual number of desired functional groups to add.\n\nSee also\n\nadd_functionalization!\n\nExamples\n\njulia> ProtoSyn.Materials.functionalize!(pose, Dict(ProtoSyn.modification_grammar.variables[\"XYL\"] => 10))\n\njulia> pose\nPose{Topology}(Topology{/CRV:42474}, State{Float64}:\n Size: 380\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/carbons/#ProtoSyn.Materials.add_functionalization!","page":"Carbons","title":"ProtoSyn.Materials.add_functionalization!","text":"add_functionalization!(pose::Pose, fcn::Fragment, atom::Atom)\n\nAdd a single functional group fcn (a Fragment instance) to the given Atom instance atom in the Pose pose. The Atom instance atom is replaced (using the replace_by_fragment! method).\n\nSee also\n\nfunctionalize!\n\nExamples\n\njulia> ProtoSyn.Materials.add_functionalization!(pose, ProtoSyn.modification_grammar.variables[\"XYL\"], pose.graph[1, 1, 16])\n\njulia> pose\nPose{Topology}(Topology{/CRV:14425}, State{Float64}:\n Size: 353\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/carbons/#ProtoSyn.Materials.add_hydrogens!","page":"Carbons","title":"ProtoSyn.Materials.add_hydrogens!","text":"\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/carbons/#ProtoSyn.Materials.generate_carbon_from_file","page":"Carbons","title":"ProtoSyn.Materials.generate_carbon_from_file","text":"generate_carbon_from_file(filename::String, output::Opt{String} = nothing)\n\nGenerate a functionalized carbon model from a .yml input file (named filename). If output is set to a String (nothing, by default), outputs the generated carbon model to a file. For an input file example, check the resources/Materials/carbon.yml file.\n\nSee also\n\nfunctionalize!\n\nExamples\n\njulia> pose = ProtoSyn.Materials.generate_carbon_from_file(\"carbon.yml\")\nPose{Topology}(Topology{/CRV:40141}, State{Float64}:\n Size: 960\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"CurrentModule = ProtoSyn.Materials","category":"page"},{"location":"protosyn-api/materials/methods/lattices/#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"In the next section, a brief description of the available methods to generate new atomic lattices is provided. These lattices can be useful, among other things, to benchmark and test new EnergyFunction and EnergyFunctionComponent instances, for example. ","category":"page"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"primitive","category":"page"},{"location":"protosyn-api/materials/methods/lattices/#ProtoSyn.Materials.primitive","page":"Lattices","title":"ProtoSyn.Materials.primitive","text":"primitive([unit_cell_dims::Vector{T} = [1.0, 1.0, 1.0]]) where {T <: AbstractFloat}\n\nCreates a primitive lattice Pose. If given, the unit_cell_dims vector determines the size of the unit cell. This must be a 1x3 Vector{T} of X, Y and Z lengths of the cubic unit cell (in Angstrom, [1.0, 1.0, 1.0] by default, using the ProtoSyn.Units.defaultFloat as type T).\n\nSee also:\n\nmerge! symexp!\n\nExamples\n\njulia> pose = ProtoSyn.Materials.primitive()\nPose{Topology}(Topology{/primitive:12909}, State{Float64}:\n Size: 1\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"(Image: ProtoSyn Primitive Lattice)","category":"page"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"Figure 1 | An example of the primitive lattice.","category":"page"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"body_centered","category":"page"},{"location":"protosyn-api/materials/methods/lattices/#ProtoSyn.Materials.body_centered","page":"Lattices","title":"ProtoSyn.Materials.body_centered","text":"body_centered([unit_cell_dims::Vector{T} = [1.0, 1.0, 1.0]]) where {T <: AbstractFloat}\n\nCreates a body-centered lattice Pose. If given, the unit_cell_dims determine the position of the body-centered Atom (half of it in all dimensions). This must be a 1x3 Vector{T} of X, Y and Z lengths of the cubic unit cell (in Angstrom, [1.0, 1.0, 1.0] by default, using the ProtoSyn.Units.defaultFloat as type T).\n\nSee also:\n\nmerge! symexp!\n\nExamples\n\njulia> ProtoSyn.Materials.body_centered()\nPose{Topology}(Topology{/primitive:51728}, State{Float64}:\n    Size: 2\n    i2c: false | c2i: false\n    Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"(Image: ProtoSyn Body Centered Lattice)","category":"page"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"Figure 2 | An example of the body_centered lattice.","category":"page"},{"location":"protosyn-api/core/calculators/ref15/","page":"REF-15","title":"REF-15","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/calculators/ref15/#REF-15","page":"REF-15","title":"REF-15","text":"","category":"section"},{"location":"protosyn-api/core/calculators/ref15/","page":"REF-15","title":"REF-15","text":"The Rosetta ( and python wrapper PyRosetta) software has been on the forefront of technological advances in the scope of molecular simulations and energy function development in the past few decades. One such leap was the development of REF-15, an all-atom energy function for macromolecular modeling and design. ProtoSyn directly links to PyRosetta to make use of the REF-15 energy function in its simulations, as an EnergyFunctionComponent.","category":"page"},{"location":"protosyn-api/core/calculators/ref15/","page":"REF-15","title":"REF-15","text":"ukw: Note:\nGiven the natural differences between the way the ProtoSyn and PyRoseta packages handle a Pose, currently, the only way to convert between the two data structures in through the file system. This process, as expected, carries a high computational cost. If no mutation/design process is being performed, it's possible to re-use the sabe PyRosetta pose by simply updating the atomic coordinates. Consider employing the fixate_rosetta_pose! method.","category":"page"},{"location":"protosyn-api/core/calculators/ref15/","page":"REF-15","title":"REF-15","text":"ProtoSyn.Calculators.REF15.calc_ref15\nProtoSyn.Calculators.REF15.get_default_ref15\nProtoSyn.Calculators.REF15.fixate_rosetta_pose!","category":"page"},{"location":"protosyn-api/core/calculators/ref15/#ProtoSyn.Calculators.REF15.calc_ref15","page":"REF-15","title":"ProtoSyn.Calculators.REF15.calc_ref15","text":"calc_ref15(::Type{<: ProtoSyn.AbstractAccelerationType}, pose::Pose, selection::Opt{AbstractSelection}, update_forces::Bool = false; rosetta_pose::Opt{PyCall.PyObject} = nothing)\n\nCalculate the Pose pose energy according to the external REF15 energy function from the PyRosetta Python package. calc_ref15 uses the filesystem to write the given Pose pose to a file and load it using PyRosetta, for the calculation. This is performed each call. Optionally, a static PyCall.PyObject rosetta_pose can be provided. In this case, if the number of Atom instances match, only the cartesian coordinates are updated (improved performance, note that any design effort prevents the usage of the same rosetta_pose). The AbstractSelection in this Calculator doesn't have any effect, and exists only for standardization with other Calculators. The parameter A (Type{<: AbstractAccelerationType}) doesn't have any effect in this Calculator doesn't have any effect, and exists only for standardization with other Calculators.\n\nSee also\n\nget_default_ref15\n\nExamples\n\njulia> ProtoSyn.Calculators.REF15.calc_ref15(pose, nothing, false)\n(574.367631516687, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/ref15/#ProtoSyn.Calculators.REF15.get_default_ref15","page":"REF-15","title":"ProtoSyn.Calculators.REF15.get_default_ref15","text":"get_default_ref15(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default PyRosetta's REF15 EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). This component employs the calc_ref15 method, therefore defining a Pose energy based on PyRosetta's REF15 energy function. By default, this EnergyFunctionComponent uses the filesystem to write the current Pose to a file and load in PyRosetta. Optionally, a static PyCall.Object can be used by setting efc.settings[:rosetta_pose] = static_pose, where static_pose is a previously loaded PyRosetta Pose. Any subsequent calculation only updates the cartesian coordinates (the number of Atom instances must, therefore, match).\n\nSee also\n\nfixate_rosetta_pose!\n\nSettings\n\nrosetta_pose::Opt{PyCall.PyObject} - Defines the static Rosetta Pose to update cartesian coordinates. If set to nothing, will use filesystem to create a new PyRosetta Pose;\n\nExamples\n\njulia> ProtoSyn.Calculators.REF15.get_default_ref15()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | REF15                            |\n| Alpha (α)      | 1.0                              |\n| Update forces  | true                             |\n| Calculator     | calc_ref15                       |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | rosetta_pose                  | nothing                                          |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/ref15/#ProtoSyn.Calculators.REF15.fixate_rosetta_pose!","page":"REF-15","title":"ProtoSyn.Calculators.REF15.fixate_rosetta_pose!","text":"fixate_rosetta_pose!(efc::EnergyFunctionComponent{T}, pose::Pose) where {T <: AbstractFloat}\n\nUses the filesystem to write the given Pose pose to a file and load as a PyRosetta Pose. Sets the provided EnergyFunctionComponent efc :rosetta_pose setting to this newly defined PyCall.Object.\n\nSee also\n\nget_default_ref15\n\nExamples\n\njulia> ProtoSyn.Calculators.REF15.fixate_rosetta_pose!(efc, pose)\nPyObject <pyrosetta.rosetta.core.pose.Pose object at 0x7f89417d1ab0>\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"(Image: logo)","category":"page"},{"location":"#Welcome-to-the-ProtoSyn.jl-documentation!","page":"Home","title":"Welcome to the ProtoSyn.jl documentation!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ProtoSyn.jl is a platform for molecular manipulation and simulation, with an emphasis on peptide design.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main goal of ProtoSyn is to be a basis on top of which new tools and protocols can be experimented and prototyped. Taking advantage of Julia’s environment, ProtoSyn has been built with emergent technologies in mind, such as distributed computing, GPU and SIMD acceleration and machine learning models usage.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Edit a peptide structure by removing, adding and mutating any number of residues\nCreate peptides from scratch by providing the desired sequence\nCopy parts of other molecules and graft them together to create something new\nExplore Ramachandran maps to introduce secondary structure variations \nRun Monte Carlo simulations to optimize a structure or a sequence\nCalculate energies and forces using native potentials (such as SASA/GB, Coulomb or simple harmonics) or commonly used tools now integrated in Julia (such as TorchANI or REF15 from PyRosetta).\nPerform Steepest Descent optimizations\nExplore rotamer libraries to optimize sidechain packaging\nSelect residues based on name, index, distance and other parameters, with a rich combinatory selection syntax\nPerform rigid body docking of ligands\nInclude ramified carbohydrates and glycoproteins in your simulations, with support for sugar residues\nInclude non-canonical aminoacids (NCAAs) and post-translational modifications, such as methylation or phosporylation\nGenerate functionalized carbon models, including multi-layer & pore generation support","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Installation\nFirst steps\nExamples","category":"page"},{"location":"#Publications","page":"Home","title":"Publications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A scientific paper about ProtoSyn.jl package is being written and should be available soon.","category":"page"},{"location":"#Contacts","page":"Home","title":"Contacts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: jose.manuel.pereira@ua.pt)","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Acknowledgments)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This work was developed within the scope of the project CICECO-Aveiro Institute of Materials, UIDB/50011/2020 & UIDP/50011/2020, financed by national funds through the Portuguese Foundation for Science and Technology/MCTES. José Pereira further acknowledges FCT financial support on the scope of the PhD scholarship SFRH/BD/138820/2018.","category":"page"},{"location":"protosyn-api/common/introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/common/introduction/#Common","page":"Introduction","title":"Common","text":"","category":"section"},{"location":"protosyn-api/common/introduction/","page":"Introduction","title":"Introduction","text":"The Common module is a special type of module, in ProtoSyn. Its objective is to group commonly performed tasks, such as defining a default EnergyFunction instances or defining commonly used Callback instances.","category":"page"},{"location":"protosyn-api/common/introduction/#Default-Energy-Function","page":"Introduction","title":"Default Energy Function","text":"","category":"section"},{"location":"protosyn-api/common/introduction/","page":"Introduction","title":"Introduction","text":"Common.default_energy_function","category":"page"},{"location":"protosyn-api/common/introduction/#ProtoSyn.Common.default_energy_function","page":"Introduction","title":"ProtoSyn.Common.default_energy_function","text":"default_energy_function(::Type{T}) where {T <: AbstractFloat}\ndefault_energy_function()\n\nReturns a default EnergyFunction for ProtoSyn. If no Type{T} is provided, will use ProtoSyn.Units.defaultFloat. This EnergyFunction is optimized for evaluating protein systems.\n\nExamples\n\njulia> ProtoSyn.Common.default_energy_function()\n🗲  Energy Function (7 components):\n+----------------------------------------------------------------------+\n| Index | Component name                                | Weight (α)   |\n+----------------------------------------------------------------------+\n| 1     | TorchANI_ML_Model                             |       1.00   |\n| 2     | All_Atom_Clash_Rest                           |       1.00   |\n| 3     | Hydrogen_Bonds                                |       0.50   |\n| 4     | Coulomb                                       |       0.60   |\n| 5     | TorchANI_Ref_Energy                           |       1.00   |\n| 6     | GB_Solvation                                  |       1.00   |\n| 7     | SASA_Solvation                                |   5.00e-04   |\n+----------------------------------------------------------------------+\n ● Update forces: false\n ● Selection: Set\n └── TrueSelection (Atom)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/common/introduction/#Default-Callbacks","page":"Introduction","title":"Default Callbacks","text":"","category":"section"},{"location":"protosyn-api/common/introduction/","page":"Introduction","title":"Introduction","text":"Common.default_energy_step_callback\nCommon.default_energy_step_frame_callback\nCommon.default_energy_step_detailed\nCommon.default_energy_step_frame_detailed\nCommon.detailed_message","category":"page"},{"location":"protosyn-api/common/introduction/#ProtoSyn.Common.default_energy_step_callback","page":"Introduction","title":"ProtoSyn.Common.default_energy_step_callback","text":"default_energy_step_callback(n::Int)::Callback\n\nReturns a simple Callback that prints the current step and total energy value of the Pose every n steps.\n\nExamples\n\njulia> ProtoSyn.Common.default_energy_step_callback(100)\n✉  Callback:\n+----------------------------------------------------------------------+\n| Index | Field                     | Value                            |\n+----------------------------------------------------------------------+\n| 1     | Event                     | energy_step                      |\n| 2     | Frequency                 | 100                              |\n+----------------------------------------------------------------------+\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/common/introduction/#ProtoSyn.Common.default_energy_step_frame_callback","page":"Introduction","title":"ProtoSyn.Common.default_energy_step_frame_callback","text":"default_energy_step_frame_callback(n::Int, filename::String)::Callback\n\nReturns a simple Callback that prints the current step and total energy value of the Pose every n steps, while printing the current structure to the given filename (format infered from filename extension).\n\nExamples\n\njulia> ProtoSyn.Common.default_energy_step_frame_callback(100, \"test.pdb\")\n✉  Callback:\n+----------------------------------------------------------------------+\n| Index | Field                     | Value                            |\n+----------------------------------------------------------------------+\n| 1     | Event                     | energy_step_frame                |\n| 2     | Frequency                 | 100                              |\n+----------------------------------------------------------------------+\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/common/introduction/#ProtoSyn.Common.default_energy_step_detailed","page":"Introduction","title":"ProtoSyn.Common.default_energy_step_detailed","text":"default_energy_step_detailed(n::Int, msg::String = \"Callback\", color::Symbol = :none, file_out::Opt{String} = nothing, print_to_sdtout::Bool = true)::Callback\n\nReturns a detailed Callback that prints the current step and all energy components of the Pose every n steps. An optional msg String can be provided as a header. Output can be colored by setting the color flag. For a list of available colors, check the printstyled documentation. By default, default_energy_step_detailed prints the output to the stdout. This can be toggled by setting the print_to_sdtout flag. Optionally, if a file_out is provided (as a String), output is also printed to that file.\n\nExamples\n\njulia> ProtoSyn.Common.default_energy_step_detailed(1)\n✉  Callback:\n+----------------------------------------------------------------------+\n| Index | Field                     | Value                            |\n+----------------------------------------------------------------------+\n| 1     | Event                     | energy_step_detailed             |\n| 2     | Frequency                 | 1                                |\n+----------------------------------------------------------------------+\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/common/introduction/#ProtoSyn.Common.default_energy_step_frame_detailed","page":"Introduction","title":"ProtoSyn.Common.default_energy_step_frame_detailed","text":"default_energy_step_frame_detailed(n::Int, output_frame::String, msg::String = \"Callback\", color::Symbol = :none, output_log::Opt{String} = nothing, print_to_sdtout::Bool = true)::Callback\n\nReturns a detailed Callback that prints the current step and all energy components of the Pose every n steps, while printing the current structure to the given filename (format infered from filename extension). An optional msg String can be provided as a header. Output can be colored by setting the color flag. For a list of available colors, check the printstyled documentation. By default, default_energy_step_detailed prints the output to the stdout. This can be toggled by setting the print_to_sdtout flag. Optionally, if a file_out is provided (as a String), output is also printed to that file.\n\nExamples\n\njulia> ProtoSyn.Common.default_energy_step_detailed(1)\n✉  Callback:\n+----------------------------------------------------------------------+\n| Index | Field                     | Value                            |\n+----------------------------------------------------------------------+\n| 1     | Event                     | energy_step_detailed             |\n| 2     | Frequency                 | 1                                |\n+----------------------------------------------------------------------+\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/common/introduction/#ProtoSyn.Common.detailed_message","page":"Introduction","title":"ProtoSyn.Common.detailed_message","text":"detailed_message(msg::String; color::Symbol = :none, file_out::Opt{String} = nothing, print_to_sdtout::Bool = true, N::Int = 100)\n\nPrint a detailed message msg in the same style as default_energy_step_detailed, with the given color (uses the  printstyled method). If file_out is set to a String (nothing, by default), also print to a file with the given file name. If print_to_stdout is set to false (true, by default), skip printing to the stdout. N sets the length of the final stylized message.\n\nExamples\n\njulia> ProtoSyn.Common.detailed_message(\"Simulation (Stage 3) ...\", color = :blue, N = 120)\n| --------------------------------------------- Simulation (Stage 3) ... --------------------------------------------- |\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"CurrentModule = ProtoSyn.Mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/#Rigid-Body-Mutators","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"ProtoSyn Core module makes available two Rigid Body Mutators: the RotationRigidBodyMutator, which changes a Pose State by introducing a rigid body rotation; and the TranslationRigidBodyMutator, which changes a Pose State by introducing a rigid body translation.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"RotationRigidBodyMutator","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/#ProtoSyn.Mutators.RotationRigidBodyMutator","page":"Rigid Body Mutators","title":"ProtoSyn.Mutators.RotationRigidBodyMutator","text":"RotationRigidBodyMutator(axis_sampler::Function, angle_sampler::Function, pivot_sampler::Function, step_size::AbstractFloat, selection::Opt{AbstractSelection})\n\nReturn a new RotationRigidBodyMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(rigid_body_mutator::RotationRigidBodyMutator)(pose::Pose)\n\nThe RotationRigidBodyMutator AbstractMutator applies a rotation to all Atom instances in a given Pose based on a given angle and axis, and centered around a pivot position (See rotation_matrix_from_axis_angle). The applied rotation's angle is sampled by calling angle_sampler (receives no input arguments and should return a Float angle value in radians) and multiplied by the step_size value. The rotation's axis is sampled from the axis_sampler (receives no input arguments and should return a Vector{Float} with size 3, the X, Y and Z dimensions). Finally, this rotation is centered in a pivot position, sampled from pivot_sampler (receives the Pose and a list of selected Atom indexes as the input arguments and should return a Vector{Float} with size 3, the X, Y and Z dimensions). If an AbstractSelection selection is provided, only the selected Atom instances are rotated and used as input for pivot_sampler. Note that the RotationRigidBodyMutator syncs any pending internal to cartesian coordinate conversion (using the i2c! method). Requests cartesian to internal coordinates conversion (using request_c2i! method). Does not sync! the given Pose afterwards.\n\nThe RotationRigidBodyMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(rigid_body_mutator::RotationRigidBodyMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\naxis_sampler::Function - Should return a Vector{Float} axis (X, Y and Z dimensions). Is called with no input arguments;\nangle_sampler::Function - Should return a Float angle value (in radians). Is called with no input arguments;\npivot_sampler::Function - Should return a Vector{Float} position (X, Y and Z dimensions). Is called with 2 input arguments: a Pose instance and a Vector{Int} with the indexes of the selected Atom instances;\nstep_size::AbstractFloat - Multiplies the sampled angle by this value;\nselection::Opt{AbstractSelection} - If given, this Mutator will only be applied to the selected Atom instances.\n\nSee also\n\nTranslationRigidBodyMutator\n\nExamples\n\njulia> m = ProtoSyn.Mutators.RotationRigidBodyMutator(ProtoSyn.rand_vector_in_sphere, randn, ProtoSyn.center_of_mass, 1.0, rn\"CBZ\")\n⚯  Rotation Rigid Body Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | axis_sampler                | Function rand_vector_in_sphere |\n| 2     | angle_sampler               | Function randn                 |\n| 3     | pivot_sampler               | Function center_of_mass        |\n| 4     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ● Selection: Set\n └── FieldSelection › Residue.name = CBZ\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"(Image: ProtoSyn Rotation Rigid Body Mutator)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"Figure 1 | A schematic representation of a RotationRigidBodyMutator instance. In this example, showcasing a 2 molecule simulation, a RotationRigidBodyMutator is applied to a carbamazepine (CBZ) ligand, by selecting it based on the Residue.name (rn\"CBZ\"). The axis for the rotation is sampled from rand_vector_in_sphere, the angle is sampled from randn and the pivot position if the Pose center_of_mass.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"TranslationRigidBodyMutator","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/#ProtoSyn.Mutators.TranslationRigidBodyMutator","page":"Rigid Body Mutators","title":"ProtoSyn.Mutators.TranslationRigidBodyMutator","text":"TranslationRigidBodyMutator(translation_vector_sampler::Function, step_size::AbstractFloat, selection::Opt{AbstractSelection})\n\nReturn a new TranslationRigidBodyMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(rigid_body_mutator::TranslationRigidBodyMutator)(pose::Pose)\n\nThe TranslationRigidBodyMutator AbstractMutator applies a translation to all Atom instances in a given Pose based on a given axis. This axis is sampled from translation_vector_sampler (who receives no input arguments and should return a Vector{Float} with size 3, the X, Y and Z dimensions). Although not necessary, this Vector{Float} should have norm 1.0. The translation vector is then multiplied by step_size. If an AbstractSelection selection is provided, only the selected Atom instances are translated. Note that the TranslationRigidBodyMutator syncs any pending internal to cartesian coordinate conversion (using the i2c! method). Requests cartesian to internal coordinates conversion (using request_c2i! method). Does not sync! the given Pose afterwards.\n\nThe TranslationRigidBodyMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(rigid_body_mutator::TranslationRigidBodyMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\ntranslation_vector_sampler::Function - Should return a Vector{Float} axis (X, Y and Z dimensions). Is called with no input arguments;\nstep_size::AbstractFloat - Multiplies the sampled axis by this value;\nselection::Opt{AbstractSelection} - If given, this Mutator will only translate the selected Atom instances;\n\nSee also\n\nTranslationRigidBodyMutator\n\nExamples\n\njulia> m = ProtoSyn.Mutators.TranslationRigidBodyMutator(ProtoSyn.rand_vector_in_sphere, 1.0, rn\"CBZ\")\n⚯  Translation Rigid Body Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | translation_vector_sampler  | Function rand_vector_in_sphere |\n| 2     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ● Selection: Set\n └── FieldSelection › Residue.name = CBZ\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"(Image: ProtoSyn Translation Rigid Body Mutator)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"Figure 2 | A schematic representation of a TranslationRigidBodyMutator instance. In this example, the Mutator is applied to a carbamazepine (CBZ) ligand, by selecting it based on the Residue.name (rn\"CBZ\"). The translation vector is sampled from rand_vector_in_sphere. All the selected atoms will suffer this translation.","category":"page"},{"location":"protosyn-api/core/calculators/electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/calculators/electrostatics/#calculators-electrostatics","page":"Electrostatics","title":"Electrostatics","text":"","category":"section"},{"location":"protosyn-api/core/calculators/electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"The following section goes into detail on how ProtoSyn aims to evaluate electrostatic interactions, divided in the following topics:","category":"page"},{"location":"protosyn-api/core/calculators/electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"Adding charges\nCoulomb EnergyFunctionComponent","category":"page"},{"location":"protosyn-api/core/calculators/electrostatics/#Adding-charges","page":"Electrostatics","title":"Adding charges","text":"","category":"section"},{"location":"protosyn-api/core/calculators/electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"The first step in any eletrostatic energy calculation is the attribution of charges to each point-like particle (i.e.: each Atom instance). Users are free to manually define each Atom's charge (by setting the corresponting pose.state[atom].δ field). More automation purposes, ProtoSyn makes available several methods to automatically set-up charges in a Pose:","category":"page"},{"location":"protosyn-api/core/calculators/electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"Calculators.Electrostatics.assign_default_charges!\nCalculators.Electrostatics.assign_acc2_eem_charges_from_file!","category":"page"},{"location":"protosyn-api/core/calculators/electrostatics/#ProtoSyn.Calculators.Electrostatics.assign_default_charges!","page":"Electrostatics","title":"ProtoSyn.Calculators.Electrostatics.assign_default_charges!","text":"assign_default_charges!(pose::Pose, res_lib::LGrammar, [selection::Opt{AbstractSelection}]; [supress_warn::Bool = false])\n\nAssign default charges to Pose pose from the given LGrammar res_lib entry, by Atom name. If an AbstractSelection selection is provided, only apply charges to the selected Atom instances. For non-canonical aminoacids and ligands (any Residue without an entry on ProtoSyn.three_2_one dictionary) and any Residue whose template have different Atom names, a warning is shown. Set supress_warn to an AbstractSelection (or a boolean true) to ignore these warnings for the selected Atom instances (or all atoms, if true, is set to false, by default).\n\nukw: Note:\nConsider setting default atom names (from the same LGrammar), for example, using the assign_default_atom_names! method.\n\nSee also\n\nassign_acc2_eem_charges_from_file!\n\nExamples\n\njulia> ProtoSyn.Calculators.Electrostatics.assign_default_charges!(pose, ProtoSyn.Peptides.grammar)\n1143-element Vector{Float64}:\n -0.025115728872692304\n -0.025115728872692304\n -0.025115728872692304\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/electrostatics/#ProtoSyn.Calculators.Electrostatics.assign_acc2_eem_charges_from_file!","page":"Electrostatics","title":"ProtoSyn.Calculators.Electrostatics.assign_acc2_eem_charges_from_file!","text":"assign_acc2_eem_charges_from_file!(pose::Pose, filename::String, [selection::Opt{AbstractSelection}])\n\nOpen and load ACC2 charges from a file filename, apply them to the given Pose pose. If an AbstractSelection selection is provided, the loaded charge are only applied to the selected Atom instances (note that both the number of loaded charge values and number of selected atoms must match). For more information on ACC2 charges, check https://acc2.ncbr.muni.cz/\n\nSee also\n\nassign_default_charges!\n\nExamples\n\njulia> ProtoSyn.Calculators.Electrostatics.assign_acc2_eem_charges_from_file!(pose, \"charges.txt\", aid\"1:30\")\n30-element Vector{Float64}:\n  0.26429\n -0.1422\n -0.17175\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/electrostatics/#Coulomb-EnergyFunctionComponent","page":"Electrostatics","title":"Coulomb EnergyFunctionComponent","text":"","category":"section"},{"location":"protosyn-api/core/calculators/electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"As long as a Pose has charges attributed, the default Electrostatics coulomb EnergyFunctionComponent can be applied.","category":"page"},{"location":"protosyn-api/core/calculators/electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"Calculators.Electrostatics.calc_coulomb\nCalculators.Electrostatics.get_default_coulomb","category":"page"},{"location":"protosyn-api/core/calculators/electrostatics/#ProtoSyn.Calculators.Electrostatics.calc_coulomb","page":"Electrostatics","title":"ProtoSyn.Calculators.Electrostatics.calc_coulomb","text":"calc_coulomb([::A], pose::Pose, selection::Opt{AbstractSelection}, update_forces::Bool = false; [mask::MaskMap = nothing], [vlist::Opt{VerletList} = nothing], [potential::Function = (x) -> 0.0]) where {A}\n\nCalculate the Pose pose Coulomb energy according to the given potential function, based on the cartesian coordinates (make sure the Pose pose is synched, see sync!). By default, the potential returns 0.0 for each atom-pair. This function iterates over all Atom instances in the provided Pose pose (See Counters and Iterators), unless an AbstractSelection selection is provided, limiting the selected Atom instances. If the update_forces flag is set to true (false, by default), also return the calculated forces based on this potential. Note that this function assumes Atom.id entries are synched between the Graph and State (See Indexation). An optional parameter Type{<: AbstractAccelerationType} can be provided, stating the acceleration type used to calculate this energetic contribution (See ProtoSyn acceleration types). Uses ProtoSyn.acceleration.active by default. This function makes use of the apply_potential! framework. As such, an optional mask and VerletList vlist can be provided to limit the calculation. Make sure the Pose pose has charges assigned (see assign_acc2_eem_charges_from_file! and assign_default_charges!).\n\nSee also\n\nget_default_coulomb\n\nExamples\n\njulia> ProtoSyn.Calculators.Electrostatics.calc_coulomb(pose, nothing, false)\n(0.0, [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0])\n\njulia> ProtoSyn.Calculators.Electrostatics.calc_coulomb(pose, nothing, false, mask = ProtoSyn.Calculators.get_intra_residue_mask, potential = ProtoSyn.Calculators.get_bump_potential_charges(c = 0.0, r = 20.0))\n(-2.6046789109428206, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/electrostatics/#ProtoSyn.Calculators.Electrostatics.get_default_coulomb","page":"Electrostatics","title":"ProtoSyn.Calculators.Electrostatics.get_default_coulomb","text":"get_default_coulomb(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default Coulomb EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). This component employs the calc_coulomb method, therefore defining a Pose energy based on a given potential. By default, this  EnergyFunctionComponent uses the get_bump_potential_charges potential, with an intra-residue mask (see get_intra_residue_mask).\n\nSettings\n\nmask::Function - Defines which atom-pairs to mask out of the result;\nvlist::VerletList - If defined, the apply_potential! method will only calculate the given atom-pairs in the VerletList;\npotential::Function - Which potential to apply to each atom-pair;\n\nExamples\n\njulia> ProtoSyn.Calculators.Electrostatics.get_default_coulomb()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | Coulomb                          |\n| Alpha (α)      | 1.0                              |\n| Update forces  | true                             |\n| Calculator     | calc_coulomb                     |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | potential                     | bump_potential_charges                           |\n |    | vlist                         | nothing                                          |\n |    | mask                          | get_intra_residue_mask                           |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/#peptides-builder","page":"Builder","title":"Builder","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"The Builder is a submodule of ProtoSyn.Peptides module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"As an expansion of the Core module Builder, this submodule introduces the peptidic LGrammar type, as well as the necessary methods to append and insert Fragment instances from a derivation, organized in the following topics:","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"Loading the default Peptides Stochastic L-Grammar\nBuilding a molecular structure\nManipulating a molecular structure by adding new residues from templates","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/#peptides-builder-1","page":"Builder","title":"Loading the default Peptides Stochastic L-Grammar","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"The default Peptides grammar is loaded when ProtoSyn is loaded, and can be accessed at Peptides.grammar.","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"load_default_grammar\nload_grammar_from_file\nload_grammar_from_file!\njoin_grammars!\nload_grammar_extras_from_file!","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.load_default_grammar","page":"Builder","title":"ProtoSyn.Peptides.load_default_grammar","text":"load_default_grammar([::Type{T}])\n\nLoad the default Peptides LGrammar (from the default resources/Peptides/ directory, types as T <: AbstractFloat, if not provided will use ProtoSyn.Units.defaultFloat).\n\nukw: Note:\nThe default Peptides LGrammar is automatically loaded when using ProtoSyn. It can be found at Peptides.grammar.\n\nExamples\n\njulia> ProtoSyn.Peptides.load_default_grammar()\nLGrammar{Float64, String, Vector{String}}:\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.load_grammar_from_file","page":"Builder","title":"ProtoSyn.Peptides.load_grammar_from_file","text":"load_grammar_from_file([::Type{T}], filename::AbstractString, key::String) where {T <: AbstractFloat}\n\nLoad a LGrammar from the given filename (this should in .yml format, only loads the given key), typed to be of type T <: AbstractFloat. If not provided, will use ProtoSyn.Units.defaultFloat.\n\nSee also\n\nload_grammar_from_file!\n\nExamples\n\njulia> ProtoSyn.Peptides.load_grammar_from_file(\"grammars.yml\", \"default\")\nLGrammar{Float64, String, Vector{String}}:\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.load_grammar_from_file!","page":"Builder","title":"ProtoSyn.Peptides.load_grammar_from_file!","text":"load_grammar_from_file!([::Type{T}], grammar::LGrammar{T, K, V}, filename::AbstractString, key::String) where {T <: AbstractFloat, K, V}\n\nLoad a LGrammar from the given filename (this should in .yml format, only loads the given key), typed to be of type T <: AbstractFloat. If not provided, will use ProtoSyn.Units.defaultFloat. Automatically add the loaded LGrammar instance to the given grammar (using the join_grammars! method).\n\nSee also\n\nload_grammar_from_file\n\nExamples\n\njulia> g1 = ProtoSyn.Peptides.load_grammar_from_file(\"grammars.yml\", \"default\");\n\njulia> g2 = ProtoSyn.Peptides.load_grammar_from_file!(g1, \"grammars.yml\", \"ncaa\")\nLGrammar{Float64, String, Vector{String}}:\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.join_grammars!","page":"Builder","title":"ProtoSyn.Peptides.join_grammars!","text":"join_grammars!(g1::LGrammar{T, K, V}, g2::LGrammar{T, K, V}) where {T <: AbstractFloat, K, V}\n\nAdd LGrammar g2 rules, variables and operators to LGrammar g1, joining both instances.\n\nExamples\n\njulia> g1 = ProtoSyn.Peptides.load_grammar_from_file(\"grammars.yml\", \"default\");\n\njulia> g2 = ProtoSyn.Peptides.load_grammar_from_file(\"grammars.yml\", \"ncaa\");\n\njulia> ProtoSyn.Peptides.join_grammars!(g1, g2)\nLGrammar{Float64, String, Vector{String}}:\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.load_grammar_extras_from_file!","page":"Builder","title":"ProtoSyn.Peptides.load_grammar_extras_from_file!","text":"load_grammar_extras_from_file!([::Type{T}], filename::AbstractString, key::String) where {T <: AbstractFloat}\n\nFill missing information in the following ProtoSyn constants with extra details from the loaded LGrammar .yml filename (under the key entry, typed as T <: AbstractFloat, if not provided will use ProtoSyn.Units.defaultFloat):\n\nProtoSyn.Peptides.chi_dict\nProtoSyn.Peptides.available_aminoacids\nProtoSyn.three_2_one\nProtoSyn.one_2_three\n\nSee also\n\nload_grammar_from_file\n\nExamples\n\njulia> ProtoSyn.Peptides.load_grammar_extras_from_file!(\"grammars.yml\", \"default\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/builder/#peptides-builder-2","page":"Builder","title":"Building a molecular structure","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"build(::LGrammar{T}, ::Any, ::SecondaryStructureTemplate) where {T <: AbstractFloat}","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.build-Union{Tuple{T}, Tuple{LGrammar{T}, Any, SecondaryStructureTemplate}} where T<:AbstractFloat","page":"Builder","title":"ProtoSyn.Peptides.build","text":"build(grammar::LGrammar{T}, derivation, ss::NTuple{3,Number} = SecondaryStructure[:linear]) where {T <: AbstractFloat}\n\nBuild a Pose using the given derivation sequence on the provided grammar instructions. If an ss is provided, automatically apply it to the built pose (linear secondary structure, by default).\n\nukw: Note:\nThis function is an extension of ProtoSyn.build.\n\nSee also\n\nsetss!\n\nExamples\n\njulia> pose = ProtoSyn.Peptides.build(res_lib, seq\"QQQ\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 51\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/peptides/submodules/builder/#peptides-builder-3","page":"Builder","title":"Manipulating a molecular structure by adding new residues from templates","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"append_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Any; ::Opt{SecondaryStructureTemplate}, ::Any)\ninsert_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Any; ::Opt{SecondaryStructureTemplate}, ::Any)","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.append_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Any}","page":"Builder","title":"ProtoSyn.Peptides.append_fragment!","text":"append_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation; [ss::Opt{SecondaryStructureTemplate} = nothing], [op = \"α\"])\n\nAdd the a Fragment built from the given derivation to the provided Pose pose, appending it after the given Residue residue. This residue and the new Fragment frag will be connected using operation op (\"α\" by default) of the given LGrammar grammar. If given, a SecondaryStructureTemplate ss can be applied to the new appendage (using the setss! method). In either case, the C=O bond position is re-calculated and set (in the anchor for the first residue of the appendage). Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nukw: Note:\nThis function is an extension of ProtoSyn.append_fragment!.\n\nSee also\n\ninsert_fragment!\n\nExamples\n\njulia> ProtoSyn.Peptides.append_fragment!(pose, pose.graph[1][end], res_lib, seq\"AAA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.insert_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Any}","page":"Builder","title":"ProtoSyn.Peptides.insert_fragment!","text":"insert_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation; ss::Opt{SecondaryStructureTemplate} = nothing, op = \"α\")\n\nInsert the Fragment built from the given derivation in the provided pose, on the position of the provided Residue instance residue (the residue gets shifted downstream). This first downstream Residue and the new Fragment will be connected using operation op (\"α\" by default) from [LGrammar] grammar. Also connects to the upstream Residue instance, using the same operation. If given, a SecondaryStructureTemplate ss can be applied to the new appendage (using the setss! method). If the appendage is not being inserted at the root, the C=O bond position is re-calculated and set (in the anchor for the first residue of the appendage). If the appendage is being inserted at the root, perform a soft uncap of the terminal hydrogen atoms (removes \"H2\" and \"H3\", leaves \"H1\", renames it to \"H\") and recalculate the N-H bond position (at the first downstream Residue). Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nukw: Note:\nThis function is an extension of ProtoSyn.insert_fragment!.\n\nSee also\n\nappend_fragment!\n\nExamples\n\njulia> ProtoSyn.Peptides.insert_fragment!(pose, pose.graph[1][1], res_lib, seq\"AAA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"CurrentModule = ProtoSyn.Sugars","category":"page"},{"location":"protosyn-api/sugars/submodules/builder/#sugars-builder","page":"Builder","title":"Builder","text":"","category":"section"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"The Builder is a submodule of ProtoSyn.Sugars module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"As an expansion of the Core module Builder, this submodule introduces the carbohydrates LGrammar type, as well as the necessary methods to append and insert Fragment instances from a derivation.","category":"page"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"grammar","category":"page"},{"location":"protosyn-api/sugars/submodules/builder/#ProtoSyn.Sugars.grammar","page":"Builder","title":"ProtoSyn.Sugars.grammar","text":"grammar([::Type{T}, polyname::String]) where {T <: AbstractFloat}\n\nBuild a LGrammar for polysaccharide polyname from the grammars.yml file available in the Sugars resource directory (\"amylose\", by default). The returned LGrammar can then be used by the ProtoSyn.build function to build the polymer.\n\nExamples\n\njulia> g = Sugars.grammar();\n\njulia> pose = ProtoSyn.build(g, seq\"AAAβB[ɣCɣCɣC]AAA\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"(Image: ProtoSyn Ramified Sugar)","category":"page"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"Figure 1 | Small example of a ramified sugar (such as amylopectin), built in ProtoSyn.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"CurrentModule = ProtoSyn.Drivers","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Drivers-section","page":"Drivers Section","title":"Drivers section","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"A Driver is a piece of code that drives the simulation forward. Usually, it includes a set of one or more AbstractMutator instances and an EnergyFunction. As such, a Driver (in contrast with a simple AbstractMutator) is able to make decisions or change the course of the simulation based on the evaluation of the current State. For example, a MonteCarlo simulation may accept or reject a given conformational change (produced by one of more AbstractMutator instances) based on the evaluation of the system State by a given EnergyFunction. The current status of a simulation is stored in a DriverState instance (each Driver type has a corresponding DriverState type). For example, this can hold the current step or temperature of the simulation. Each module in ProtoSyn may include a Drivers section, adding new Driver types and methods. In the next sections, a deeper look into the inner workings of the available Driver instances is provided, organized in the following sections:","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Callbacks\nCreating custom callbacks\nCreating custom drivers\nAvailable drivers\nCreating custom thermostats\nAvailable thermostats","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"(Image: ProtoSyn driver)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Figure 1 | A diagram of a MonteCarlo Driver. This Driver type requests an eval! component (in this case, an EnergyFunction, with a TorchANI Ensmeble as the single component - see get_default_torchani_ensemble) and a sample! component (in this example, a single DihedralMutator). As the naming implies, an eval! component evaluates the system's energy at any given moment in the simulation, while the sample! component drives the system from a State to the next. Optionally, a Callback callback can be provided, whose purpose is to periodically return information to the user about the current state of the simulation (i.e.: current step, temperature, energy, etc). In this example, as defined in the MonteCarlo Driver settings, the simulation will run for 5000 steps, with a constant temperature (see Available thermostats and Creating custom thermostats on how to control the temperature of a simulation).","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Callbacks","page":"Drivers Section","title":"Callbacks","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Callback instances are responsible for returning information from a simulation during its runtime. This object type is usually used in Driver instances in order to print information to the user relative to the inner workings of a simulation: the current step, temperature, energy, etc.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Callback","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#ProtoSyn.Drivers.Callback","page":"Drivers Section","title":"ProtoSyn.Drivers.Callback","text":"Callback(event::Function, frequency::Int)\n\nA Callback instance is a functor, called with the following signature:\n\n(callback::Callback)(pose::Pose, driver_state::ProtoSyn.Drivers.DriverState)\n\nA Callback expects the given DriverState driver_state to have a :step field. The input Pose pose and DriverState driver_state are passed as arguments to the event method every callback.frequency steps.\n\nFields\n\nevent::Function - Receives a Pose pose and DriverState driver_state as input arguments, should print some useful information to the user;\nfrequency::Int - the :event method is called every :frequency steps (when comapred to the given DriverState driver_state.step).\n\nExamples\n\njulia> cb = ProtoSyn.Drivers.Callback((pose::Pose, driver_state::ProtoSyn.Drivers.DriverState) -> println(\"Status OK\"), 1)\n✉  Callback:\n+----------------------------------------------------------------------+\n| Index | Field                     | Value                            |\n+----------------------------------------------------------------------+\n| 1     | Event                     | #1                               |\n| 2     | Frequency                 | 1                                |\n+----------------------------------------------------------------------+\n\njulia> cb(pose, driver_state)\nStatus OK\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-section/#Creating-custom-callbacks","page":"Drivers Section","title":"Creating custom callbacks","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"As stated above, Callback instances are functors, usually called from within the body of a Driver instance. As such, a specific signature is expected for the :event function:","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"callback.event(pose::Pose, driver_state::DriverState)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"As an example:","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"using ProtoSyn","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"function event_example(pose::Pose, driver_state::ProtoSyn.Drivers.DriverState)\n    println(\"Step: $(driver_state.step) | Energy: $(pose.state.e[:Total])\")\nend\n\ncallback = ProtoSyn.Drivers.Callback(event_example, 1)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"ukw: Note:\nAlthough possible, changing the input Pose pose or DriverState driver_state during the Callback call can have unexpected results, and should be used carefully.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Creating-custom-drivers","page":"Drivers Section","title":"Creating custom drivers","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Since certain Driver instances may call other Driver instances, Protosyn expects a certain signature for custom drivers and the accompanying DriverState. A Driver is a functor, meaning it is a callable object, with the following signature:","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Base.@kwdef mutable struct ExampleDriverState{T <: AbstractFloat} <: DriverState\n    step::Int = 0\n    # content\nend\n\nmutable struct ExampleDriver <: Driver\n    callback::Opt{Callback}\n    # content\nend\n\nfunction (driver::MonteCarlo)(pose::Pose)\n    T = eltype(pose.state)\n    driver_state = ExampleDriverState{T}()\n    driver.callback !== nothing && driver.callback(pose, driver_state)\n\n    # content\n    return pose\nend","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"From the previous snippet of code, three important bits can be highlighted: first, the usage of Base.kwdef to define default values for the DriverState object. Altough not necessary, this eases the creation of starting DriverState instances. Second, the initial call to the :callback field in the Driver, giving as input arguments a Pose pose and DriverState driver_state, as expected. Note that this is an optional component of a standard Driver in ProtoSyn. Finally, although not necessary, some other Driver instances might expect a custom Driver to return the modified Pose pose.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Available-drivers","page":"Drivers Section","title":"Available drivers","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"In this seb-section, the default Driver instances made available by the Core module of ProtoSyn are further explored. Note that additional Driver types might be made available in other modules (such as Peptides).","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"MonteCarlo\nSteepestDescent\nILS\nCompoundDriver","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Creating-custom-thermostats","page":"Drivers Section","title":"Creating custom thermostats","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Some Driver instances have a :temperature::Function field, where the temperature function takes the current :step of the simulation. This function is often referred to as a thermostat, since it regulates the temperature of the simulation, thus controlling the likelihood of acceptance of higher energy states, etc. As such, in order to create a custom thermostat, the following signature should be followed (taking a step`Int as the single input argument and returning a temperature value, usually as a Float):","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"return function custom_thermostat(step::Int)\n\n    # content\n\n    return temperature_value\nend","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Available-thermostats","page":"Drivers Section","title":"Available thermostats","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"get_constant_temperature\nget_linear_quench\nget_quadratic_quench","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"get_constant_temperature\nget_linear_quench\nget_quadratic_quench","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#ProtoSyn.Drivers.get_constant_temperature","page":"Drivers Section","title":"ProtoSyn.Drivers.get_constant_temperature","text":"get_constant_temperature(init_temp::T) where {T <: AbstractFloat}\n\nReturn a constant temperature thermostat function, set at temperature init_temp.\n\nSee also\n\nget_linear_quench get_quadratic_quench\n\nExamples\n\njulia> thermostat = ProtoSyn.Drivers.get_constant_temperature(1.0)\n(::ProtoSyn.Drivers.var\"#constant_temperature#9\"{Float64}) (generic function with 1 method)\n\njulia> thermostat(100)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/drivers/drivers-section/#ProtoSyn.Drivers.get_linear_quench","page":"Drivers Section","title":"ProtoSyn.Drivers.get_linear_quench","text":"get_linear_quench(init_temp::T, n_steps::Int) where {T <: AbstractFloat}\n\nReturn a linear temperature quench thermostat function, beggining at temperature init_temp and reducing linearly to 0.0 during n_steps.\n\nSee also\n\nget_constant_temperature get_quadratic_quench\n\nExamples\n\njulia> thermostat = ProtoSyn.Drivers.get_linear_quench(1.0, 100)\n(::ProtoSyn.Drivers.var\"#linear_quench#10\"{Float64, Int64}) (generic function with 1 method)\n\njulia> thermostat(0)\n1.0\n\njulia> thermostat(50)\n0.5\n\njulia> thermostat(100)\n0.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/drivers/drivers-section/#ProtoSyn.Drivers.get_quadratic_quench","page":"Drivers Section","title":"ProtoSyn.Drivers.get_quadratic_quench","text":"get_quadratic_quench(init_temp::T, n_steps::Int, min_temp::T) where {T <: AbstractFloat}\n\nReturn a quadratic temperature quench thermostat function, beginning at temperature init_temp and reducing to min_temp during n_steps following a quadratic curve.\n\nSee also\n\nget_constant_temperature get_linear_quench\n\nExamples\n\njulia> thermostat = ProtoSyn.Drivers.get_quadratic_quench(1.0, 100, 0.0)\n(::ProtoSyn.Drivers.var\"#quadratic_quench#11\"{Float64, Int64, Float64}) (generic function with 1 method)\n\njulia> thermostat(0)\n1.0\n\njulia> thermostat(50)\n0.25\n\njulia> thermostat(100)\n0.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/radius-gyration/","page":"Radius of gyration","title":"Radius of gyration","text":"CurrentModule = ProtoSyn.Calculators","category":"page"},{"location":"protosyn-api/core/calculators/radius-gyration/#Radius-of-gyration","page":"Radius of gyration","title":"Radius of gyration","text":"","category":"section"},{"location":"protosyn-api/core/calculators/radius-gyration/","page":"Radius of gyration","title":"Radius of gyration","text":"The radius of gyration of a molecule is, in short, a measure of how \"elongated\" that structure is in each of the 3 dimensions (x, y and z). This can be useful, for example, in globular systems where an elongation in any of the dimensions is usually not likely to be a stabilizing conformational change. The following methods allow ProtoSyn to calculate the radius of gyration of a Pose and attribute a tentative energy value.","category":"page"},{"location":"protosyn-api/core/calculators/radius-gyration/","page":"Radius of gyration","title":"Radius of gyration","text":"Calculators.RG.calc_radius_gyration\nCalculators.RG.calc_radius_gyration_energy\nCalculators.RG.get_default_rg","category":"page"},{"location":"protosyn-api/core/calculators/radius-gyration/#ProtoSyn.Calculators.RG.calc_radius_gyration","page":"Radius of gyration","title":"ProtoSyn.Calculators.RG.calc_radius_gyration","text":"calcradiusgyration(pose::Pose, [selection::Opt{AbstractSelection} = nothing])\n\nCalculate each dimension (X, Y and Z) radius of gyration (the root mean square deviation to all of the structure's Atom instances from the Pose pose center_of_mass). Each Atom type mass is retrieved from ProtoSyn.Units.mass.\n\nSee also\n\ncalc_radius_gyration_energy get_default_rg\n\nExamples\n\njulia> ProtoSyn.Calculators.SASA.calc_radius_gyration(pose)\n3×1 Matrix{Float64}:\n4.976766149665673\n5.501503499039599\n10.74091335737219\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/radius-gyration/#ProtoSyn.Calculators.RG.calc_radius_gyration_energy","page":"Radius of gyration","title":"ProtoSyn.Calculators.RG.calc_radius_gyration_energy","text":"calc_radius_gyration_energy(pose::Pose, selection::Opt{AbstractSelection}, update_forces::Bool)\n\nCalculate the sum of all dimensions (X, Y and Z) radius of gyration. This Calculator does not calculate forces. As such, update_forces has no effect and exists only in order to standardize calls between Calculators.\n\nSee also\n\ncalc_radius_gyration get_default_rg\n\nExamples\n\njulia> ProtoSyn.Calculators.SASA.calc_radius_gyration_energy(pose, nothing, false)\n(21.21918300607746, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/radius-gyration/#ProtoSyn.Calculators.RG.get_default_rg","page":"Radius of gyration","title":"ProtoSyn.Calculators.RG.get_default_rg","text":"get_default_rg(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default Radius of Gyration energy EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance, 1.0 by default). This function employs calc_radius_gyration_energy as the :calc function.\n\nSee also\n\ncalc_radius_gyration_energy\n\nExamples\n\njulia> ProtoSyn.Calculators.SASA.get_default_sasa_energy()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | Radius_Gyration                  |\n| Alpha (α)      | 1.0                              |\n| Update forces  | false                            |\n| Calculator     | calc_radius_gyration_energy      |\n+---------------------------------------------------+\n└──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"CurrentModule = ProtoSyn.Mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/#Mutators-section","page":"Mutators Section","title":"Mutators section","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Each module in ProtoSyn may include a Mutators section, containing types and methods allowing ProtoSyn to change a Pose instance's from one State to another. In other words, a Mutator (of type AbstractMutator) is responsible for implementing a given conformational change in a Pose (for example, implementing Dihedral rotations, among others). In the context of a simulation, this is usually refered as \"sampling\". In the next section, a further exploration of the available AbstractMutator instances is provided, organized in the following sections:","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Creating custom mutators\nAvailable mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"(Image: ProtoSyn Mutators)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Figure 1 | A diagram of an example CompoundMutator, bringing together multiple AbstractMutator instances. In this example, both the DihedralMutator and the CrankshaftMutator are represented. Each AbstractMutator can be parametrized by a collection of settings, explained in each Mutator's page in this manual. In the case of the exemplified AbstractMutator instances, these can receive an optional selection (in the example the FieldSelection and UnarySelection are shown).","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/#Creating-custom-mutators","page":"Mutators Section","title":"Creating custom mutators","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Mutators are most useful when employed in a Driver instance (see Drivers section), who expects the following signature. Note that the Mutator instances are struct instances (of type <: AbstractMutator), but are also functors, meaning that are callable by the encompassing Driver. For this call, only a Pose pose instance is given as input, and all conformational changes should be in-place (no output is expected and any internal to cartesian coordinate conversion, or vice-versa, should be requested at the end of the function call). Note that, as a general rule, AbstractMutator instances should sync! any required internal to cartesian coordinate conversion (or vice-versa) at the start of the function call (using i2c! or c2i! methods). As an example, DihedralMutator syncs any pending cartesian to internal coordinate conversion before applying itself, as it will apply changes to the internal coordinates. In the same fashion, at the end of the function call, AbstractMutators should request any internal to cartesian coordinate conversion (or vice-versa), depending on the change performed, therefore requesting a pending sync!. However, AbstractMutators should not sync!, in most cases. As an example, ten sequential DihedralMutator calls do not require a sync! between each of them.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"struct NewMutator <: AbstractMutator\n    # content\nend\n\nfunction (mutator::NewMutator)(pose::Pose)\n    # content\nend","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"In order to be able to incorporate any new custom mutator in a CompoundMutator, an extra signature needs to be present, receiving a subset list of Atom instances. In this case, the mutator should only be applied to the Atom instances in this subset.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"function (mutator::NewMutator)(pose::Pose, atoms::Vector{Atom})\n    # content\nend","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/#Available-mutators","page":"Mutators Section","title":"Available mutators","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Besides all the machinery to create custom mutators, ProtoSyn's Core module makes available some simple AbstractMutator instances. Since this is not a specialized module, available mutators should be indiferent to the type of molecular structure being sampled. As of ProtoSyn 1.1, the following AbstractMutator instances are made available from the Core module, and can be further explored in the respectivelly dedicated pages of this manual:","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Dihedral Mutator\nCrankshaft Mutator\nRigid Body Mutators\nBackrub Mutator\nCompound Mutator","category":"page"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/","page":"Steepest Descent","title":"Steepest Descent","text":"CurrentModule = ProtoSyn.Drivers","category":"page"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/#Steepest-Descent-Driver","page":"Steepest Descent","title":"Steepest Descent Driver","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/","page":"Steepest Descent","title":"Steepest Descent","text":"The Steepest Descent Driver introduces a simple gradient descent, calculating the forces acting on each atom and applying a relaxing translational movement, until convergence or end of simulation.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/","page":"Steepest Descent","title":"Steepest Descent","text":"SteepestDescent\nSteepestDescentState","category":"page"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/#ProtoSyn.Drivers.SteepestDescent","page":"Steepest Descent","title":"ProtoSyn.Drivers.SteepestDescent","text":"SteepestDescent(eval!::Union{Function, EnergyFunction}, callback::Opt{Callback}, max_steps::Int, force_tolerance::Float64, max_displacement::Float64)\n\nA SteepestDescent Driver instance. As such, this object is callable as a functor with the following signature:\n\n(driver::SteepestDescent)(pose::Pose)\n\nThis simulation employs the calculation of forces by an evaluating function or EnergyFunction instance (eval!) to relax and optimize a given Pose pose. This process will run for a maximum of max_steps iterations, or until the simulation has stalled or converged. Convergence is achieved when the maximum force felt on the system is bellow a given threshold force_tolerance, while a simulation is stalled when the current scaling factor is bellow the machine precision. In each step, the displacement is calculated as a factor of the force applied to an atom multiplied by a step size (or learning rate), up to a maximum max_displacement. As an heuristic for the definition of this step size, this value increases while when the system's energy is lowering, and rapidly decreases if an higher energy State is generated. This allows the simulation to traverse for some degree of energy barriers. Each step, a call to an optional Callback callback is performed. A companion SteepestDescentState DriverState instance is also updated each step and provided to the Callback callback.\n\nFields\n\neval!::Union{Function, EnergyFunction} - The evaluator EnergyFunction or custom function, receives a Pose pose as the single argument;\ncallback::Opt{Callback} - An optional Callback instance, receives two input arguments: the current Pose pose and the current DriverState driver_state;\nmax_steps::Int - The total number of simulation steps to be performed;\nforce_tolerance::Float64 - The minimum force tolerated by the simulation, any State with a max force below this threshold will converge the simulation;\nmax_displacement::Float64 - The maximum displacement each step (a.u.).\n\nSee also\n\nSteepestDescentState\n\nExamples\n\njulia> sd = ProtoSyn.Drivers.SteepestDescent(energy_function, cb, 1000, 0.001, 0.1)\n⚒  Steepest Descent Driver:\n ├──  ●  Evaluator:\n |    └── 🗲  Energy Function (4 components):\n |        +----------------------------------------------------------------------+\n |        | Index | Component name                                | Weight (α)   |\n |        +----------------------------------------------------------------------+\n |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |        +----------------------------------------------------------------------+\n |   \n ├──  ● Callback:\n |    └── ✉  Callback:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                     | Value                            |\n |        +----------------------------------------------------------------------+\n |        | 1     | Event                     | energy_step_frame                |\n |        | 2     | Frequency                 | 10                               |\n |        +----------------------------------------------------------------------+\n |   \n └──  ● Settings:\n            Max steps: 1000\n      Force tolerance: 0.001\n     Max displacement: 0.1\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/#ProtoSyn.Drivers.SteepestDescentState","page":"Steepest Descent","title":"ProtoSyn.Drivers.SteepestDescentState","text":"SteepestDescentState{T <: AbstractFloat}(step::Int = 0, converged::Bool = false, completed::Bool = false, stalled::Bool = false, stepsize::T = T(1), max_force::Tuple{T,Int} = (T(-1),0))\nSteepestDescentState{T <: AbstractFloat}()\n\nA SteepestDescentState instance is a DriverState that keeps track of a SteepestDescent simulation status. Besides the default :step, :converged, :completed and :stalled fields, a SteepestDescentState instance adds the following tracking fields specific for SteepestDescent simulations:\n\nstepsize::T - The current learning rate of the simulation;\nmax_force::Tuple{T,Int} - The maximum force felt by the system and the atom index where the force is felt.\n\nSee also\n\nSteepestDescent\n\nExamples\n\njulia> ProtoSyn.Drivers.SteepestDescentState{Float64}()\nProtoSyn.Drivers.SteepestDescentState{Float64}(0, false, false, false, 1.0, (-1.0, 0))\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/","page":"Steepest Descent","title":"Steepest Descent","text":"(Image: ProtoSyn steepest-descent-driver)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/","page":"Steepest Descent","title":"Steepest Descent","text":"Figure 1 | A schematic overview of the different stages in a SteepestDescent Driver: (1) - Calculate the forces being felt on the system; (2) - Apply the forces, multiplied by the current stepsize; (3) - Adjust the stepsize, based on the new system's energy.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"CurrentModule = ProtoSyn.Mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/#Crankshaft-Mutator","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"A CrankshaftMutator instance changes a Pose State by introducing one or more crankshaft movements: a concerted rotation, by a given axis, around a virtual axis between two Atom instances.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"CrankshaftMutator","category":"page"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/#ProtoSyn.Mutators.CrankshaftMutator","page":"Crankshaft Mutator","title":"ProtoSyn.Mutators.CrankshaftMutator","text":"CrankshaftMutator(angle_sampler::Function, p_mut::AbstractFloat, step_size::AbstractFloat, selection::Opt{AbstractSelection}, inc_last_res::Opt{AbstractSelection})\n\nReturn a CrankshaftMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(crankshaft_mutator::CrankshaftMutator)(pose::Pose)\n\nThe CrankshaftMutator AbstractMutator loops through all pairs of two atoms possible, in the given Pose. For each pair, if a random number (rand()) is bellow a given probability of mutation p_mut, both atoms are selected for a crankshaft movement (therefore a higher p_mut value applies a larger number of crankshaft movements per call). A crankshaft movement is a concerted rotation around a virtual axis formed between the two selected atoms, by a certain angle given by the angle_sampler function and multiplied by the step_size value. The rotation is applied to the region between the two atoms, by travelling the Pose Graph (See travel_graph), by calculating and applying a rotation matrix (See rotation_matrix_from_axis_angle). Note that a new angle for the crankshaft movement is sampled for each selected pair of Atom instances. If an AbstractSelection selection is provided, only the selected Atom instances are looped over. If an AbstractSelection selection is provided, only the selected Atom instances are looped over. If the given AbstractSelection selection is not of selection type Atom, it will be promoted to this type (using promote with default aggregator any). If an AbstractSelection inc_last_res is provided, all atoms in this AbstractSelection and in the last residue considered for the crankshaft movement will be included in the rotation. As an example, for a correct crankshaft movement in peptidic structures, the sidechain of the last residue should also be included in the rotation. In this example, inc_last_res should be !(an\"^CA$|^N$|^C$|^H$|^O$\"r). Note that the CrankshaftMutator syncs any pending internal to cartesian coordinate conversion (using the i2c! method). Requests cartesian to internal coordinates conversion (using request_c2i! method). Does not sync! the given Pose afterwards.\n\nThe CrankshaftMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(crankshaft_mutator::CrankshaftMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\nangle_sampler::Function - Should return a Float angle value (in radians). Is called with no input arguments;\np_mut::AbtractFloat - Compared against a rand() call, applies this Mutator to Atom instance pairs where rand() < p_mut;\nstep_size::AbstractFloat - Multiplies the sampled angle by this value;\nselection::Opt{AbstractSelection} - If given, this Mutator will only loop over the selected Atom instances;\ninc_last_res::Opt{AbstractSelection} - If given, all atoms in this Mutator and in the last residue considered for the crankshaft movement will be included in the rotation.\n\nSee also\n\nDihedralMutator\n\nExamples\n\njulia> ProtoSyn.Mutators.CrankshaftMutator(randn, 1.0, 1.0, nothing, nothing)\n⚯  Crankshaft Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | angle_sampler               | Function randn                 |\n| 2     | p_mut                       | 1.0000                         |\n| 3     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ○  Selection: Not Set\n ○  Include on last residue: Not Set\n\njulia> ProtoSyn.Mutators.CrankshaftMutator(randn, 0.01, 1.0, an\"CA\", !(an\"^CA$|^N$|^C$|^H$|^O$\"r))\n⚯  Crankshaft Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | angle_sampler               | Function randn                 |\n| 2     | p_mut                       | 0.0100                         |\n| 3     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ● Selection: Set\n └── FieldSelection › Atom.name = CA\n ● Include on last residue: Set\n └── UnarySelection ❯ ! \"not\" (Atom)\n      └── FieldSelection › Atom.name = r\"^CA$|^N$|^C$|^H$|^O$\"\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"(Image: ProtoSyn Crankshaft Mutator)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"Figure 1 | A schematic representation of a CrankshaftMutator instance. In this example, the selection an\"CA\" selects only pairs of carbon alpha Atom instances. For each pair of Atom instances possible, a random number (obtained by calling rand()) is compared against the CrankshaftMutator.p_mut field. If the random number is lower, the current Atom instance pair is selected for a crankshaft movement. A high value for p_mut therefore translates into a higher number of crankshaft rotations in a single call to the CrankshaftMutator. As a general rule, using a p_mut value of 2/N(N-1) will result in 1 rotation per call of the CrankshaftMutator, on average (where N is the number of atoms in the Pose or number of selected atoms by selection). A crankshaft movement is a concerted rotation of all Atom instances in the Graph between the two selected Atom instances, around an axis formed between the two selected Atom instances. The angle of the rotation is calculates from the CrankshaftMutator.angle_sampler call (with no input arguments), multiplied by CrankshaftMutator.step_size.","category":"page"},{"location":"protosyn-api/core/submodules/external-packages/","page":"External packages","title":"External packages","text":"CurrentModule = ProtoSyn.GMX","category":"page"},{"location":"protosyn-api/core/submodules/external-packages/#external-packages","page":"External packages","title":"External packages","text":"","category":"section"},{"location":"protosyn-api/core/submodules/external-packages/","page":"External packages","title":"External packages","text":"Because ProtoSyn does not exist in an isolated bubble but, instead, in a flourishing and ever-growing sea of novel applications and tools for computational chemistry, the External packages submodules attempts to link structures (and simulations) from ProtoSyn to any file format or input type for common and useful external packages.","category":"page"},{"location":"protosyn-api/core/submodules/external-packages/#Gromacs","page":"External packages","title":"Gromacs","text":"","category":"section"},{"location":"protosyn-api/core/submodules/external-packages/","page":"External packages","title":"External packages","text":"Gromacs is \"a free and open-source software suite for high-performance molecular dynamics and output analysis\". ProtoSyn makes available tools to automatically export Pose structures to the correct input formats for Gromacs (including the definition of .itp files with the forcefield parameters for molecular dynamics), or even employ Gromacs tools to manipulate structures directly.","category":"page"},{"location":"protosyn-api/core/submodules/external-packages/","page":"External packages","title":"External packages","text":"generate_gmx_itp\nadd_bounding_box\nadd_solvent\nadd_ions","category":"page"},{"location":"protosyn-api/core/submodules/external-packages/#ProtoSyn.GMX.generate_gmx_itp","page":"External packages","title":"ProtoSyn.GMX.generate_gmx_itp","text":"generate_gmx_itp(pose::Pose, selection::Opt{AbstractSelection}; atomtypes_itp_filename::String = \"atomtypes.itp\", molecule_itp_filename::String = \"molecule.itp\", overwrite::Bool = true, keep_temp_files::Bool = false)\n\nGenerate an .itp file for the Fragment given by applying the AbstractSelection selection on the given Pose pose. If no selection is provided, the whole Pose pose will be considered as a single entity for .itp generation. This function assumes the selected Fragment is an unusual organic chemical compound and uses acpype external software to identify atomtypes and write an .itp with AMBER forcefield parameters for usage in GROMACS simulations. By default, acpype prints 2 files: the requested .itp (to a file named molecule_itp_filename) and an .itp file with all atomtypes retrieved (to a file named atomtypes_itp_filename). These atomtypes can sometimes be useful to verify the acpype automatic attribution or to include in the final topology. In any of these files are found in the current working directory, the function raises an error. If overwrite is set to true (is, by default), the existing files are overwritten instead. Any temporary files (starting with \"jl\") and directories and deleted after completion, unless `keeptemp_filesis set totrue(false, by default). It is reccomended that this function is not used to specific organic polymers, such as proteins. Specific ProtoSyn modules (such asPeptides, in this example) should provide more accurate.itp` generation methods.\n\nukw: Note:\nOther modules, such as Peptides, may provide generate_gmx_itp methods for specific molecule types (proteins and peptides, in this example).\n\nExamples\n\njulia> ProtoSyn.GMX.generate_gmx_itp(pose, rn\"CBZ\")\n(...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/external-packages/#ProtoSyn.GMX.add_bounding_box","page":"External packages","title":"ProtoSyn.GMX.add_bounding_box","text":"add_bounding_box(input_filename::String, output_filename::String, size::T, [shape::String = \"cubic\"], [verbose::Bool = true]) where {T <: AbstractFloat}\n\nEmploy gmx editconf to add a bouding box to a given input file (input_filename), outputs to output_filename. The box has the provided shape and size (in nm). If verbose is set to false (true, by default), hide the GROMACS output.\n\nExamples\n\njulia> ProtoSyn.GMX.add_bounding_box(\"md.pdb\", \"md_box.pdb\", 1.0)\n(...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/external-packages/#ProtoSyn.GMX.add_solvent","page":"External packages","title":"ProtoSyn.GMX.add_solvent","text":"add_solvent(input_filename::String, output_filename::String, [solvent_type::String = \"spc216\"], [topol_filename::String = \"topol.top\"], [verbose::Bool = true])\n\nEmploy gmx solvate to add a solvent to a given input file (input_filename), outputs to output_filename. The file contents should be incorporated in a bounding box (see add_bounding_box). The solvent used in given by solvent_type (GROMCAS searchs the current working directory and the default instalation directory for .gro files with this name containing structural information of the solvent molecule). Add solvent information (such as number of added molecules) to the given topol_filename. If verbose is set to false (true, by default), hide the GROMACS output.\n\nExamples\n\njulia> ProtoSyn.GMX.add_solvent(\"md_box.pdb\", \"md_sol.pdb\")\n(...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/external-packages/#ProtoSyn.GMX.add_ions","page":"External packages","title":"ProtoSyn.GMX.add_ions","text":"add_ions(input_filename::String, output_filename::String; [mdp::String = joinpath(ProtoSyn.resource_dir, \"ExternalPackages/GROMACS/mdps/ions.mdp\")], [topol_filename::String = \"topol.top\"], [tpr_filename::String = \"ions.tpr\"], [positive_ion::String = \"NA\"], [negative_ion::String = \"CL\"], [number_of_positive_ions::Int = 0], [number_of_negative_ions::Int = 0], [neutral::Bool = true], [attempt_auto::Opt{Int} = nothing], [verbose::Bool = true])\n\nEmploy `gmx genion` to add ions to a given input file\n\n(input_filename), outputs to output_filename. The file contents should be incorporated in a solvated bounding box (see add_bounding_box and add_solvent). Adds number_of_negative_ions of negative_ion and number_of_positive_ions of positive_ion. Optionally, if neutral is set to true, gmx genion will add either positive_ion or negative_ion instances until neutral charge is achieved (reccomended). As a middle step, gmx genion uses the given ions mdp file and writes a temporary tpr_filename. Add ions information (such as number of added molecules) to the given topol_filename. If verbose is set to false (true, by default), hide the GROMACS output. If an attempt_auto is given, automatically chooses the SOL group for ion replacement (interactive, by default). Note that depending on the system, the SOL group number changes. For example, for a protein with ligand, the SOL group should be 15.\n\nExamples\n\njulia> ProtoSyn.GMX.add_ions(\"md_sol.pdb\", \"md_ready.pdb\", attempt_auto = 15)\n(...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/graph/","page":"Graph","title":"Graph","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/methods/graph/#peptides-graph-methods","page":"Graph","title":"Graph","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/graph/","page":"Graph","title":"Graph","text":"This section lists functions that work on the system Graph, expanding on the Core methods (See Graph methods).","category":"page"},{"location":"protosyn-api/peptides/methods/graph/","page":"Graph","title":"Graph","text":"assign_default_atom_names!\nunbond!\ntravel_graph\nIUPAC","category":"page"},{"location":"protosyn-api/peptides/methods/graph/#ProtoSyn.Peptides.assign_default_atom_names!","page":"Graph","title":"ProtoSyn.Peptides.assign_default_atom_names!","text":"assign_default_atom_names!(pose::Pose, [selection::Opt{AbstractSelection} = nothing], [grammar::LGrammar = Peptides.grammar]; [force_rename::Bool = false])\n\nAssigns the default Atom names to the given Pose pose. If an AbstractSelection selection is provided, only rename the selected Residue instances (any given selection will be promoted to be of Residue level using ProtoSyn.promote). The Atom default names are retrieved from the given LGrammar grammar (Peptides.grammar, by default). Both the given Pose and the built template from the grammar's Graph are travelled to generate a 1-to-1 correspondence between Atom instances (the Pose Atom names are then renamed to match the template, uses the ProtoSyn.travel_graph method with the ProtoSyn.Peptides.IUPAC search algorithm). This approach may sometimes fail, for example, when tautomers are present, in wich case this method attempts to find tautomer candidates in a Residue by Residue case. This method also attempts to verify if terminal Residue instances are capped, in which case the correct naming attribution is automatically taken into consideration.\n\nukw: Note:\nSome methods (such as, for example, the assign_default_charges! method) expect default atom names. Consider using ProtoSyn.Peptides.diagnose to check whether the current Atom names are known.\n\nSee also\n\nrename!\n\nExamples\n\njulia> ProtoSyn.Peptides.assign_default_atom_names!(pose)\nPose{Topology}(Topology{/2a3d:42429}, State{Float64}:\n Size: 1140\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/graph/#ProtoSyn.Peptides.unbond!","page":"Graph","title":"ProtoSyn.Peptides.unbond!","text":"unbond!(pose::Pose, residue_1::Residue, residue_2::Residue; [keep_downstream_position::Bool = true])\n\nUnbond the two provided residues by severing the peptidic bond between the C atom of residue_1 and the N atom of residue_2. In order to do this, perform the following steps: unset parent/children, unbond neighbours, remove from Graph, remove from State, update the containers itemsbyname field. If keep_downstream_position is set to true (is, by default), the downstream Residue position is maintained (by calling request_c2i! and sync! methods).\n\nExamples\n\njulia> ProtoSyn.Peptides.unbond!(pose, pose.graph[1][2], pose.graph[1][3]; keep_downstream_position = true)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/graph/#ProtoSyn.Peptides.travel_graph","page":"Graph","title":"ProtoSyn.Peptides.travel_graph","text":"travel_graph(start::Atom; [stop::Opt{Atom} = nothing], [search_algorithm::F = Peptides.IUPAC]) where {F <: SearchAlgorithm})\n\nOverload of the travel_graph method, where the default search_algorithm is IUPAC.\n\nExamples\n\njulia> Peptides.travel_graph(pose.graph[1][1][\"CA\"])\n15-element Vector{Atom}:\n Atom{/test:37905/A:1/MET:1/CA:5}\n Atom{/test:37905/A:1/MET:1/HA:6}\n Atom{/test:37905/A:1/MET:1/CB:8}\n Atom{/test:37905/A:1/MET:1/HB3:10}\n Atom{/test:37905/A:1/MET:1/HB2:11}\n Atom{/test:37905/A:1/MET:1/CG:12}\n Atom{/test:37905/A:1/MET:1/HG3:13}\n Atom{/test:37905/A:1/MET:1/HG2:14}\n Atom{/test:37905/A:1/MET:1/SD:15}\n Atom{/test:37905/A:1/MET:1/CE:16}\n Atom{/test:37905/A:1/MET:1/HE3:17}\n Atom{/test:37905/A:1/MET:1/HE2:18}\n Atom{/test:37905/A:1/MET:1/HE1:19}\n Atom{/test:37905/A:1/MET:1/C:7}\n Atom{/test:37905/A:1/MET:1/O:9}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/graph/#ProtoSyn.Peptides.IUPAC","page":"Graph","title":"ProtoSyn.Peptides.IUPAC","text":"(ProtoSyn.IUPAC)(atom::Atom, stack::Vector{Atom})\n\nIUPAC-like search algorithm for travel_graph. Correctly sorts the given Atom atom children instances and concatenates with the current stack. This method attempts to identify each Residue sidechain (from alpha-carbon CA children names) and sorts sidechain before the remaining backbone (C=O & N, etc). Consider using assign_default_atom_names! to make sure all Atom names are as expected.\n\nExamples\n\njulia> ProtoSyn.Peptides.IUPAC(pose.graph[1][1][\"CA\"], Vector{Atom}())\n3-element Vector{Atom}:\n Atom{/test:36441/A:1/MET:1/HA:6}\n Atom{/test:36441/A:1/MET:1/CB:8}\n Atom{/test:36441/A:1/MET:1/C:7}\n\n\n\n\n\n","category":"constant"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/methods/state/#core-state-methods","page":"State","title":"State","text":"","category":"section"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"This section lists functions that work on the system State. These methods are subdivided by topics, for organization purposes:","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Cartesian and internal coordinates conversion\nDihedral rotations\nMeasuring distances, angles and dihedrals\nIndexation","category":"page"},{"location":"protosyn-api/core/methods/state/#Cartesian-and-internal-coordinates-conversion","page":"State","title":"Cartesian and internal coordinates conversion","text":"","category":"section"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"The following functions deal with the conversion from internal to cartesian coordinates and vice-versa.","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"ukw: Note:\nInternal to cartesian conversion functions (and vice-versa) only apply to AtomState instances that have been modified (and therefore have the :changed field set to true). In the case of internal to cartesian coordinates conversion, updating any AtomState automatically forces downstream AtomState instances to be changed, and therefore updated. Note that the :changed flag is automatically set to true when modifying any AtomState field (including when changing the paired state.x StateMatrix), but the container state.i2c flag is not altered until explicitly request by request_i2c! or request_c2i! methods.","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"request_c2i!\nrequest_i2c!\nc2i!\ni2c!\nsync!","category":"page"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.request_c2i!","page":"State","title":"ProtoSyn.request_c2i!","text":"request_c2i!(state::State; [all::Bool = false])\n\nSets state.c2i to true. If all is set to true (false, by default), update all AtomState instances in the given State state to have :changed field set to true. Return the altered State state.\n\nSee also\n\nrequest_i2c! c2i!\n\nExamples\n\njulia> ProtoSyn.request_c2i!(pose.state)\nState{Float64}:\n Size: 343\n i2c: false | c2i: true\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.request_i2c!","page":"State","title":"ProtoSyn.request_i2c!","text":"request_i2c!(state::State; [all::Bool = false])\n\nSets state.i2c to true. If all is set to true (false, by default), update the first AtomState instance in the given State state (in the Root) to have :changed field set to true. Return the altered State state.\n\nSee also\n\nrequest_c2i! i2c!\n\nExamples\n\njulia> ProtoSyn.request_i2c!(pose.state)\nState{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.c2i!","page":"State","title":"ProtoSyn.c2i!","text":"c2i!(state::State{T}, top::Topology)\n\nUpdate the internal coordinates to match the measured cartesian coordinates, in the given State state. Note that only the AtomState instances with :changed field set to true will be updated, and the flag is therefore changed to false. Return the altered State state instance. If state.c2i is not set to true, return the original State state instance, without changes.\n\nSee also\n\ni2c! request_c2i!\n\nExamples\n\njulia> ProtoSyn.c2i!(pose.state, pose.graph)\nState{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.i2c!","page":"State","title":"ProtoSyn.i2c!","text":"i2c!(state::State{T}, top::Topology)\n\nUpdate the cartesian coordinates to match the measured internal coordinates, in the given State state. Note that only the AtomState instances with :changed field set to true will be updated, and the flag is therefore changed to false. Return the altered State state instance. If state.c2i is not set to true, return the original State state instance, without changes.\n\nukw: Note:\nAny AtomState that requires an update (has :changed flag set to true) will cause all downstream residues to be updated as well (in the same Graph).\n\nSee also\n\nc2i! request_i2c!\n\nExamples\n\njulia> ProtoSyn.i2c!(pose.state, pose.graph)\nState{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.sync!","page":"State","title":"ProtoSyn.sync!","text":"sync!(state::State, topology::Topology)\n\nCheck whether the given State state instance has either i2c or c2i flag set to true and if so update the cartesian/internal coordinates accordingly. Return the altered State instance. \n\nsync!(pose::Pose)\n\nCheck whether the given Pose instance has either i2c or c2i flag set to true in its pose.state field and if so update the cartesian/internal coordinates accordingly. Return the altered Pose instance. \n\nukw: Note:\nRequesting both i2c and c2i conversions simultaneously is not possible and will result in an error. Consider calling i2c! or c2i! to choose one of the coordinate systems to be synched. \n\nSee also\n\ni2c! c2i!\n\nExamples\n\njulia> sync!(pose.state, pose.graph)\nState{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"(Image: ProtoSyn c&i)","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Figure 1 | A diagram depicting the differences between the cartesian and internal coordinate systems. In the case of cartesian coordinates, each AtomState position is described by 3 numbers, the X, Y and Z coordinates. A StateMatrix compiles all cartesian coordinates and is useful when applying certain types of conformation changes. Employing the c2i! function allows for the synchronization of cartesian coordinates to internal coordinates. In this coordinate system, the position of each atom is still described by 3 numbers, but these are now the distance (b), angle (θ) and dihedral angle (ϕ) values relative to the parent/grand-parents. As an example, the position of the highlighted atom 12 is described by the distance to atom 11, the angle between atoms 9, 11 and itself, and finally by the dihedral angle of the atoms 8, 9, 11 and itself. Since a set of ascendents is necessary to establish the position of an AtomState, a set of 3 pseudoatoms (know as root) is necessary at the beggining of a Topology. Using this type of coordinates, it becomes extremly simple and efficient to perform large scale rotations of dihedral angles, since all positions are calculated based on the relative position to the ascendents. Employing the i2c! function allows for the synchronization from internal coordinates to cartesian coordinates.","category":"page"},{"location":"protosyn-api/core/methods/state/#Dihedral-rotations","page":"State","title":"Dihedral rotations","text":"","category":"section"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"The next functions deal with setting and rotating dihedral angles.","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"getdihedral\nsetdihedral!\nrotate_dihedral!\nsetoffset!","category":"page"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.getdihedral","page":"State","title":"ProtoSyn.getdihedral","text":"getdihedral(state::State, atom::Atom)\n\nGet the current dihedral value for Atom atom of State state (in radians, based on the internal coordinates). This value is the sum of the intrisic dihedral angle ϕ and the second ascendent Δϕ.\n\nSee also\n\nascendents setdihedral! dihedral\n\nExamples\n\njulia> getdihedral(pose.state, pose.graph[1][2][\"N\"])\n3.141592653589793\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.setdihedral!","page":"State","title":"ProtoSyn.setdihedral!","text":"setdihedral!(state::State, atom::Atom, value::T) where {T <: AbstractFloat}\n\nSet the dihedral in Atom atom of State state to be exactly value (in radians). Automatically requests internal to cartesian coordinate conversion (by setting state.i2c as true). Return the altered State state.\n\nsetdihedral!(pose::Pose, sele::AbstractSelection, value::T) where {T <: AbstractFloat}\n\nAlternativelly, set the dihedral in the (first) selected Atom instance given by the AbstractSelection sele in the given Pose pose to the provided value. Return the altered Pose pose.\n\nSee also\n\nascendents request_i2c! getdihedral rotate_dihedral!\n\nExamples\n\njulia> setdihedral!(pose.state, pose.graph[1][1][end], Float64(π))\nState{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.rotate_dihedral!","page":"State","title":"ProtoSyn.rotate_dihedral!","text":"rotate_dihedral!(state::State, atom::Atom, value::T) where {T <: AbstractFloat}\n\nRotate the dihedral in Atom atom of State state by value (in radians, adds to the current dihedral angle). Automatically requests internal to cartesian coordinate conversion (by setting state.i2c as true). Return the altered State state.\n\nSee also\n\nascendents request_i2c! getdihedral setdihedral!\n\nExamples\n\njulia> rotate_dihedral!(pose.state, pose.graph[1][1][end], Float64(π))\nState{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.setoffset!","page":"State","title":"ProtoSyn.setoffset!","text":"setoffset!(state::State{T}, at::Atom, default::Number) where {T <: AbstractFloat}\n\nRotate all sibling dihedrals of Atom atom in the given State state so that the dihedral angle identified by atom is equal to default. Set the i2c flag to true and return the altered State state.\n\nSee also\n\nLGrammar\n\nExamples\n\njulia> ProtoSyn.setoffset!(pose.state, pose.graph[1][2][\"CA\"], 3.14)\nState{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"(Image: ProtoSyn c&i)","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Figure 2 | An illustration of rotate_dihedral! method in action. This method (as well as setdihedral!) rotate a dihedral by altering the :Δφ field in the correct AtomState instance. For this example, the rotate_dihedral! was applied to atom C. The position of this atom, according to the internal coordinates system, is dictated by 3 numbers: the distance, angle and dihedral angle to its ascendents. This last value, the dihedral angle, can be further decomposed in 2 contributions: the AtomState intrinsic dihedral field (:φ) plus the parent AtomState :Δφ field. Since this logic applies to all AtomState instances, both atoms CB and HA of this example also have their position dictated by its parent AtomState :Δφ field, which, in this case, is CA. This means that altering :Δφ in CA will affect the position of C, CB and HA by the same measure, in a concerted manner. This, in essence, means rotating the C-N-CA-C dihedral (or Phi dihedral of the aminoacid, in this example). Note that since we are using internal coordinates, this rotation is also applied to all children AtomState instances, since their position is relative to the parent.","category":"page"},{"location":"protosyn-api/core/methods/state/#Measuring-distances,-angles-and-dihedrals","page":"State","title":"Measuring distances, angles and dihedrals","text":"","category":"section"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"distance\nangle\ndihedral","category":"page"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.distance","page":"State","title":"ProtoSyn.distance","text":"distance(at1::AtomState, at2::AtomState)\n\nCalculates the distance between the two AtomState instances (at1 and at2), based on the cartesian coordinates. Note: Make sure the corresponding Pose instance has been synched (using the sync! method). Returns result in Angstrom (Å).\n\nSee also\n\nangle dihedral\n\nExamples\n\njulia> d = ProtoSyn.distance(pose.state[1], pose.state[2])\n1.0093879999999997\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.angle","page":"State","title":"ProtoSyn.angle","text":"angle(at1::AtomState, at2::AtomState, at3::AtomState)\n\nCalculates the angle between the three AtomState instances (at1, at2 and at3), based on the cartesian coordinates. Note: Make sure the corresponding Pose instance has been synched (using the sync! method). Returns result in radians.\n\nSee also\n\ndistance dihedral\n\nExamples\n\njulia> a = ProtoSyn.angle(pose.state[1], pose.state[2], pose.state[3])\n0.6444967663659441\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.dihedral","page":"State","title":"ProtoSyn.dihedral","text":"dihedral(at1::AtomState, at2::AtomState, at3::AtomState, at4::AtomState)\n\nCalculates the dihedral angle between the four AtomState instances (at1, at2, at3 and at4), based on the cartesian coordinates. Note: Make sure the corresponding Pose instance has been synched (using the sync! method). Returns result in radians.\n\nExamples\n\njulia> a = ProtoSyn.dihedral(pose.state[1], pose.state[2], pose.state[3], pose.state[4])\n-1.2318251145557122\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#core-state-methods-indexation","page":"State","title":"Indexation","text":"","category":"section"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"In order to access an AtomState instance in a State, ProtoSyn makes available, essentially, three methods:","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Using the regular syntax;","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"pose.state.items[4]","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"ukw: Note:\nIn the items field, AtomState instances are indexed including the Root (which occupies the first three positions). Atom 1 is therefore at index 4. This is taken into account when using the short syntax (recommended).","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Using the short syntax with index;","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"pose.state[1]","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Using the short syntax with an Atom instance;","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"atom = pose.graph[1, 1, 1]\npose.state[atom]","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Indexation methods make sure the Pose State structure remains coherent with the Graph structure, in terms of order.","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"reindex(::State)","category":"page"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.reindex-Tuple{State}","page":"State","title":"ProtoSyn.reindex","text":"reindex(state::State)\n\nRe-indexes the whole State state (excluding the Root), setting the :index field of AtomState instances. Return the altered State state.\n\nukw: Note:\nSince we are altering a field of AtomState structs, the :changed field will automatically be set to true and therefore be updated in a future sync! call (if either :i2c or :c2i flag in the corresponding state is set to true).\n\nSee also\n\nreindex(::Topology, ::Bool)\n\nExamples\n\njulia> reindex(pose.state)\nState{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/methods/io/#core-io","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"","category":"section"},{"location":"protosyn-api/core/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"The following methods allow the user to load and export models and data from and to files.","category":"page"},{"location":"protosyn-api/core/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"By default, ProtoSyn supports the following file formats. This may change in future versions of ProtoSyn!","category":"page"},{"location":"protosyn-api/core/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"Format extension Read Write\n.pdb Yes Yes\n.yml Yes Yes\n.pqr No Yes\n.xyz No Yes","category":"page"},{"location":"protosyn-api/core/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"load\ndownload\nwrite\nappend","category":"page"},{"location":"protosyn-api/core/methods/io/#ProtoSyn.load","page":"Input and Output (IO)","title":"ProtoSyn.load","text":"load([::Type{T}], filename::AbstractString, [bonds_by_distance::Bool = false], [alternative_location::String = \"A\"], [ignore_residues::Vector{String} = Vector{String}()], [ignore_chains::Vector{String} = Vector{String}()]) where {T <: AbstractFloat}\n\nLoad the given filename into a Pose, parametrized by T. If this is not provided, the default ProtoSyn.Units.defaultFloat is used. The file format is infered from the extension (See ProtoSyn.supported_formats for all supported formats). If bonds_by_distance is set to true (false, by default), the CONECT records will be complemented with bonds infered by distance. The distances for each pair of atoms is defined in ProtoSyn.Units.bond_lengths (in Angstrom Å, with a standard deviation threshold of 0.1 Å). Return the resulting Pose instance. By default, and when available, ProtoSyn will use alternative_location A, unless specified in the flag alternative_location. If the input file if of type PDB and a trajectory, returns a vector of Pose instances instead. Optionally, by setting ignore_residues and ignore_chains, ProtoSyn will skip the load of any atom belonging to either the given residues or chains (by name).\n\nSee also\n\ndistance\n\nukw: Note:\nThis function tries to infer information of the parenthood and ascendents of each atom, using the CONECT records or infered bonds_by_distance. The parents are arbitrarily defined as the first bond found, by order, and any atom without parent is connected to the root. All Residue instances have the root.container as parent. Note that this infered information may need to be manually corrected.\n\nExamples\n\njulia> ProtoSyn.load(\"2a3d.pdb\")\nPose{Topology}(Topology{/2a3d:6263}, State{Float64}:\n Size: 1140\n i2c: false | c2i: true\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/io/#Downloads.download","page":"Input and Output (IO)","title":"Downloads.download","text":"ProtoSyn.download([::T], pdb_code::String) where {T <: AbstractFloat}\n\nDownload the PDB file (for the given PDB code) from the RCSB Protein Data Bank into a Pose. The downloaded file can be found in the current working directory. If T is specified, the downloaded file will be loaded into a Pose parametrized by T, otherwise uses the default ProtoSyn.Units.defaultFloat.\n\nSee also\n\nload\n\nExamples\n\njulia> ProtoSyn.download(\"2A3D\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/io/#ProtoSyn.write","page":"Input and Output (IO)","title":"ProtoSyn.write","text":"ProtoSyn.write(pose::Pose, filename::String)\n\nWrite to file the given Pose pose. The file format is infered from the filename extension (See ProtoSyn.supported_formats for all supported formats). The Pose pose structure is automatically synched (using the sync! method) when writting to file, as only the cartesian coordinates are used.\n\nSee also\n\nappend\n\nExamples\n\njulia> ProtoSyn.write(pose, \"new_file.pdb\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/io/#ProtoSyn.append","page":"Input and Output (IO)","title":"ProtoSyn.append","text":"ProtoSyn.append(pose::Pose, filename::String, [model::Int = 1])\n\nAppend to file the given Pose pose (as a new frame, identified by the model number model: default is 1). The file format is infered from the filename extension (See ProtoSyn.supported_formats for all supported formats). The Pose pose structure is automatically synched (using the sync! method) when writting to file, as only the cartesian coordinates are used.\n\nSee also\n\nwrite\n\nExamples\n\njulia> ProtoSyn.append(pose, \"new_file.pdb\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"The following methods are used by ProtoSyn in the load function automatically, but are displayed here for documentation purposes only.","category":"page"},{"location":"protosyn-api/core/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"is_trajectory\nsplice_trajectory\nload_trajectory","category":"page"},{"location":"protosyn-api/core/methods/io/#ProtoSyn.is_trajectory","page":"Input and Output (IO)","title":"ProtoSyn.is_trajectory","text":"is_trajectory(filename::String)\n\nRead the given filename and check if multiple \"MODEL\" entries are found. File must be in PDB format.\n\nExamples\n\njulia> ProtoSyn.is_trajectory(\"teste.pdb\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/io/#ProtoSyn.splice_trajectory","page":"Input and Output (IO)","title":"ProtoSyn.splice_trajectory","text":"splice_trajectory(filename::String)\n\nCreate a new temporary folder holding all the \"MODEL\" entries in a given filename separated (one per file, input should be in PDB format).\n\nExamples\n\njulia> ProtoSyn.splice_trajectory(\"teste.pdb\")\n\"teste_spliced\"\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/io/#ProtoSyn.load_trajectory","page":"Input and Output (IO)","title":"ProtoSyn.load_trajectory","text":"load_trajectory([::Type{T}], filename::AbstractString, ::Type{K}; [bonds_by_distance = false], [alternative_location::String = \"A\"], [ignore_residues::Vector{String} = Vector{String}()], [ignore_chains::Vector{String} = Vector{String}()]) where {T <: AbstractFloat, K}\n\nLoad the given filename into a vector of Pose instances, parametrized by T, separated by new \"MODEL\" entries. If T is not provided, the default ProtoSyn.Units.defaultFloat is used. The file format is infered from the extension (Supported: .pdb only). If bonds_by_distance is set to true (false, by default), the CONECT records will be complemented with bonds infered by distance. The distances for each pair of atoms is defined in ProtoSyn.Units.bond_lengths (in Angstrom Å, with a standard deviation threshold of 0.1 Å). Return the resulting vector of Pose instances. By default, and when available, ProtoSyn will use alternative_location A, unless specified in the flag alternative_location. Optionally, by setting ignore_residues and ignore_chains, ProtoSyn will skip the load of any atom belonging to either the given residues or chains (by name).\n\nSee also\n\nis_trajectory splice_trajectory\n\nExamples\n\njulia> ProtoSyn.load_trajectory(\"teste.pdb\")\n2-element Vector{Pose}:\n Pose{Topology}(Topology{/1:5584}, State{Float64}:\n Size: 39\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n Pose{Topology}(Topology{/2:48484}, State{Float64}:\n Size: 39\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/","page":"Bond distance Restraint","title":"Bond distance Restraint","text":"CurrentModule = ProtoSyn.Calculators.Restraints","category":"page"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/#Bond-Distance-Restraint","page":"Bond distance Restraint","title":"Bond Distance Restraint","text":"","category":"section"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/","page":"Bond distance Restraint","title":"Bond distance Restraint","text":"The Bond Distance Restraint is a potential restraint. However, in contrast with other Potential Restraints in ProtoSyn, a distance_matrix is not calculated. Instead, the Pose's Graph is iterated (See Counters and Iterators), and all bonds of an Atom are measured and evaluated according to a given potential.","category":"page"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/","page":"Bond distance Restraint","title":"Bond distance Restraint","text":"calc_bond_distance_restraint\nget_default_bond_distance_restraint","category":"page"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/#ProtoSyn.Calculators.Restraints.calc_bond_distance_restraint","page":"Bond distance Restraint","title":"ProtoSyn.Calculators.Restraints.calc_bond_distance_restraint","text":"calc_bond_distance_restraint([::Type{A}], pose::Pose, update_forces::Bool = false; x0::T = 2.0) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat}\n\nCalculate the Pose pose bond distance restraint energy according to a quadratic potential, based on the cartesian coordinates (make sure the Pose pose is synched, see sync!). This potential defines a maximum distance for the bond, based on the elements involved in the bond (See ProtoSyn.max_bond_lengths). If the pair of elements is not found, a default x0 value is used instead. This function iterates over all Atom instances in the provided Pose pose (See Counters and Iterators) and checks all bonds in each Atom. This means that bonds energy and forces are usually checked twice, as both Atom instances involved in a bond have records on one another. This is usually not a problem, as the energy value is compared between frames in a simulation environment and therefore the scale of the value is not important. If the update_forces flag is set to true (false, by default), also return the calculated forces based on this potential. Note that this function assumes Atom.id entries are synched between the Graph and State (See Indexation). An optional parameter Type{<: AbstractAccelerationType} can be provided, stating the acceleration type used to calculate this energetic contribution (See ProtoSyn acceleration types).\n\nukw: Note:\nAs of ProtoSyn 1.0, this function's acceleration type defaults to SIMD_0 regardless of the requested acceleration type. This may be changed in future iterations.\n\nSee also\n\nget_default_bond_distance_restraint\n\nExamples\n\njulia> ProtoSyn.Calculators.Restraints.calc_bond_distance_restraint(pose)\n(0.0, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/#ProtoSyn.Calculators.Restraints.get_default_bond_distance_restraint","page":"Bond distance Restraint","title":"ProtoSyn.Calculators.Restraints.get_default_bond_distance_restraint","text":"get_default_bond_distance_restraint(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default bond distance restraint EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance, 1.0 by default). This function employs calc_bond_distance_restraint as the :calc function.\n\nSettings\n\nx0::Float64 - The maximum allowed bond distance. Any bond with a longer distance will be subjected to a quadratic energy penalty. This value is normally extracted from ProtoSyn.Units.max_bond_lengths. If the pair of Atom instances identified in a bond is not found in this table, use this default x0 value (Default: 2.0).\n\nSee also\n\ncalc_bond_distance_restraint\n\nExamples\n\njulia> ProtoSyn.Calculators.Restraints.get_default_bond_distance_restraint()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | Bond_Distance_Rest               |\n| Alpha (α)      | 1.0                              |\n| Update forces  | true                             |\n| Calculator     | calc_bond_distance_restraint     |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | x0                            | 2.0                                              |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/","page":"Bond distance Restraint","title":"Bond distance Restraint","text":"(Image: ProtoSyn Bond Distance Restraint)","category":"page"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/","page":"Bond distance Restraint","title":"Bond distance Restraint","text":"Figure 1 | A diagram representation of the Bond Distance Restraint EnergyFunctionComponent. The applied potential is a quadratic function, with domain between [x0, +∞]. The x0 setting is parametrized based on observed distances between paits of Atom instances, according to the provided table (saved in ProtoSyn.Units.max_bond_lengths). If any given pair of atoms is not found in this table, the default x0 value of the EnergyFunctionComponent is used instead (2.0 Å, by default).","category":"page"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"CurrentModule = ProtoSyn.Peptides.Mutators","category":"page"},{"location":"protosyn-api/peptides/mutators/design/#Design-Mutator","page":"Design Mutator","title":"Design Mutator","text":"","category":"section"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"One of the AbstractMutator types made available by the ProtoSyn.Peptides module is the DesignMutator, whose objective is to select one or more random Residue instances (optionally, in a selection) for design, changing the aminoacid nature (and, consequentially, the sidechain Atom instances). ","category":"page"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"DesignMutator","category":"page"},{"location":"protosyn-api/peptides/mutators/design/#ProtoSyn.Peptides.Mutators.DesignMutator","page":"Design Mutator","title":"ProtoSyn.Peptides.Mutators.DesignMutator","text":"DesignMutator(p_mut::AbstractFloat, grammar::LGrammar, selection::Opt{AbstractSelection}; [searchable_aminoacids::Dict{Char, Bool} = Peptides.available_aminoacids])\n\nReturn a DesignMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(design_mutator::DesignMutator)(pose::Pose)\n\nThe DesignMutator AbstractMutator loops through all Atom instances in the given Pose and applies a mutation (using the mutate! method) if a random number (rand()) is bellow a given probability of mutation p_mut. A different mutation is attempted for each Atom instance looped over (therefore, for a single attempt at a mutation per Residue, unique Atom names should be selected, as an\"CA\", for example). If an AbstractSelection selection is provided, only Atom instances marked as true in this selection are considered for mutation. The applied mutation is sampled from the given searchable_aminoacids dictionary (only for entries marked as true), and uses the given LGrammar grammar to perform the mutation. If no searchable_aminoacids dictionary is provided, will use the default Peptides.available_aminoacids dictionary (contains all aminoacids set as true). Note that the DesignMutator syncs any pending cartesian to internal coordinate conversion (using the c2i! method). Requests internal to cartesian coordinates conversion (using the request_i2c! method). Does not sync! the given Pose afterwards.\n\nThe DesignMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(design_mutator::DesignMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\np_mut::AbtractFloat - Compared against a rand() call, applies this Mutator to Atom instances where rand() < p_mut;\ngrammar::LGrammar - The LGrammar instance with the aminoacid templates;\nselection::Opt{AbstractSelection} - If given, this Mutator will only loop over the selected Atom instances;\nsearchable_aminoacids::Dict{Char, Bool} - The dictionary of available aminoacids, where each entry sets the availability of that aminoacid type to be the result of the mutation.\n\nSee also\n\nRotamerMutator\n\nExamples\n\njulia> dm = ProtoSyn.Peptides.Mutators.DesignMutator(1.0, res_lib, an\"CA\")\n⚯  Design Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | grammar                     | Set ✓                          |\n| 2     | p_mut                       | 1.000                          |\n+----------------------------------------------------------------------+\n ● Searchable aminoacids: M 🗹 | K 🗹 | P 🗹 | N 🗹 | I 🗹 | H 🗹 | E 🗹 | W 🗹 | S 🗹 | T 🗹 | C 🗹 | D 🗹 | A 🗹 | L 🗹 | Y 🗹 | V 🗹 | R 🗹 | G 🗹 | Q 🗹 | F 🗹 \n ● Selection: Set\n └── FieldSelection › Atom.name = CA\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"(Image: ProtoSyn Design Mutator Card)","category":"page"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"Figure 1 | Schematic description of the DesignMutator. ","category":"page"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"(Image: ProtoSyn Design Mutator)","category":"page"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"Figure 2 | Example of the application of DesignMutator to simulateously mutate of all Residue instances. ","category":"page"},{"location":"getting-started/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"A major focus of ProtoSyn was the compilation of an extensive list of tutorials and examples. The main list of example notebook files can be found at the Examples folder, in the GitHub repository. In the next section, a quick description and link to each individual example can be found.","category":"page"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"1 - Getting started\n2 - Selections\n3 - Molecular manipulation\n4 - Energy calculation\n5 - Monte Carlo\n6 - Steepest Descent\n7 - ILS\n8 - Design\n9 - Sidechain packaging\n10 - Rigid body docking\n11 - Distributed computing\n12 - Ramified polymers & sugars\n13 - Advanced mutators\n14 - Non-canonical aminoacids (NCAAs)\n15 - Post-translational modifications\n16 - Materials & carbons","category":"page"},{"location":"getting-started/examples/#examples-getting-started","page":"Examples","title":"1 - Getting started","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. In this first example script, we will explore how ProtoSyn.jl is organized and what are the available data structures. The example script is divided in 4 parts: loading a PDB file, exploring the graph structure, exploring the state structure and exporting a Pose into a PDB file. For more details, check the Core Types section of this manual.","category":"page"},{"location":"getting-started/examples/#Selections","page":"Examples","title":"2 - Selections","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. ProtoSyn comes equipped with a powerful selecting syntax, useful for highlighting and specifying targets for the several manipulation tools of ProtoSyn. In this example, we will take a closer look at the different type of selections and how to apply them. For more information, check the Selections section of this manual.","category":"page"},{"location":"getting-started/examples/#Molecular-manipulation","page":"Examples","title":"3 - Molecular manipulation","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. One of the main applications of ProtoSyn is the easy manipulation of molecular structures: add and remove residues and whole loops, mutate aminoacids, bond and unbond atoms or completly remove them from the structure, and even create completly new sequences of aminoacids from scratch. These are just some examples of the manipulations possible with the ProtoSyn framework. In the next examples we will explore a few of these tasks. For more details, check the Core Pose methods and the Peptides Pose methods sections.","category":"page"},{"location":"getting-started/examples/#Energy-calculation","page":"Examples","title":"4 - Energy calculation","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. A crucial feature of the ProtoSyn framework is the ability to evaluate a given Pose based on a multitude of factors and potentials. In this example, a closer look on how to build an energy function is provided. Some of the available energy function components include Coulomb potentials, SASA/GB models, distance-based potentials, hydrogen network evaluators, etc. For more details and an exhaustive list of available potentials, check the Calculators section.","category":"page"},{"location":"getting-started/examples/#Monte-Carlo","page":"Examples","title":"5 - Monte Carlo","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. Besides the possibility to create custom simulation algorithms, ProtoSyn already provides several of these algorithms by default. A common simulation type is the Monte Carlo sampling. In this type of simulation, the conformational space is explored (or sampled) and the resulting candidate structure is evaluated and compared to the previous state. If the new energy is lower than the previous value (or accepted by an heuristic criterium, such as the Metropolis criterium), the new structure is saved for the continuation of the simulation. Otherwise, recover the previous structure and attempt a diferent change. This loop continues for N steps until the completion of the simulation. In this example, we will build a Monte Carlo simulation driver, while taking a first look at some important ProtoSyn components: the Mutators, Drivers and Callback instances. For more information, check the following sections of the manual: the Mutators section, the Monte Carlo Driver section and Callbacks section.","category":"page"},{"location":"getting-started/examples/#Steepest-Descent","page":"Examples","title":"6 - Steepest Descent","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. ProtoSyn makes available the Steepest Descent Driver, whose simulation algorithm calculates the forces being felt on each atom of a molecular structure (via an Energy Function instance) and updates the atoms position in accordance, as to relax the structure. For more information check the Steepest Descent Driver section.","category":"page"},{"location":"getting-started/examples/#ILS","page":"Examples","title":"7 - ILS","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. ILS stands for \"Iterated Local Search\" and it's a conformational search algorithm. In short, this algorithm is divided in two main components, the inner and outer loop. The inner loop can be, for example, a Monte Carlo simulation, and should explore and sample the local minimum, while the outer loop performs a \"jump\": a large conformational change, taking the system to a whole different local minimum for the next inner loop iteration. In this way, the conformational space can be efficiently sampled, with a higher certainty of exploring the global minimum during the simulation. In ProtoSyn, this algorithm is employed as a Driver, and will be briefly explored in this example. For more details, check the ILS Driver of this manual.","category":"page"},{"location":"getting-started/examples/#Design","page":"Examples","title":"8 - Design","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. One of the main goals of ProtoSyn is to provide an easy interface for the design of small peptides. This is achieved by mutating residues (more often than not in a specific region, i.e.: an active site) in order to stabilize certain interactions. In this example we will explore the DesignMutator (which provides random mutations in a selection). More more details, check the Design Mutator section of the manual.","category":"page"},{"location":"getting-started/examples/#Sidechain-packaging","page":"Examples","title":"9 - Sidechain packaging","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. A sub-problem of protein design is the correct packaging of aminoacid sidechains, that is, to find the correct rotamer (i.e.: set of sidechain chi dihedral angles) that minimizes clashes and augments stabilizing interactions with other sidechains in the 3D space. The conformational space to explore is, therefore, enormous. Several rotamer libraries have been proposed in the past to minimize this space by imposing certain restrictions. By default, ProtoSyn employs the Dunbrack Rotamer Library 2011, which reduces the rotamers to the most observed combination in natural databases, as well as imposing backbone dependency (i.e.: certain rotamers are only present for a given combination of backbone phi and psi dihedral angles). This greatly reduces the conformational space to search, while improving the likelihood of acceptance of a new rotamer. With this mind, in ProtoSyn, we can load a rotamer library and sample new rotamers, in a Monte Carlo simulation, in order to improve the sidechain packaging of a peptide. For more details, check the Rotamer Mutator section of this manual.","category":"page"},{"location":"getting-started/examples/#Rigid-body-docking","page":"Examples","title":"10 - Rigid body docking","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. ProtoSyn makes available two Rigid Body Mutators: translational and rotational. These allow the translation and rotation of blocks of residues (such as a ligand or a second molecule). With these, users are able to create custom Rigid Body Docking algorithms (for example, by moving a ligand to a grid of starting positions). In this quick example, we will take a look at a simplistic approach to rigid body docking, using a Monte Carlo simulation. In each step, short rotation and translation movements are attempted and, after evaluation by an energy function, accepted or rejected based on the Metropolis Criterium. For more information, consider reading the Rigid Body Mutators section of this manual.","category":"page"},{"location":"getting-started/examples/#Distributed-computing","page":"Examples","title":"11 - Distributed computing","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. By being developed in Julia, ProtoSyn enjoys some of the features naturally provided by the language, such as easy SIMD and GPU acceleration, a rich package environment and, among others, access to high level parallel and distributed computing routines. In this example we will take a look on how to launch and gather several decoys of the same Monte Carlo simulation. By having multiple decoys in parallel, given the random nature of the algorithm, we can have a greater confidence in the complete sampling of the conformational space, and that the obtained result is real. For more information, reffer to the Julia's Distributed Computing manual section.","category":"page"},{"location":"getting-started/examples/#Ramified-polymers-and-sugars","page":"Examples","title":"12 - Ramified polymers & sugars","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. Besides the Core and Peptides modules, ProtoSyn includes extra modules, such as the Sugars modules. In this example, we will briefly explore the goals of this modules: the introduction of ramified polymers. Note that this module is not the focus of ProtoSyn, in its current version, and may be improved in future iterations. For more details, check the Sugars sections of this manual.","category":"page"},{"location":"getting-started/examples/#Advanced-mutators","page":"Examples","title":"13 - Advanced mutators","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. Using the base ProtoSyn methods and mutators, users can build arbitrarily advanced and complex mutators for specific applications. In this example, we will explore how to build a Block Rotation Mutator (also known as blockrot). This advanced mutator is comprised of two rigid body mutators (translational and rotational), acting on a random block of sequential aminoacids, selected from a list of possible blocks. After rotation, since bonds are broken, a quick steepest descent drivers run is performed to re-close the severed connections. For this reason, the applied rotational and translational movement needs to be small. The final result is a concerted rotation of a whole block of aminoacids, in a peptide, whose occurrence using simple dihedral rotations was virtually impossible.","category":"page"},{"location":"getting-started/examples/#Non-canonical-aminoacids-(NCAAs)","page":"Examples","title":"14 - Non-canonical aminoacids (NCAAs)","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. ProtoSyn.jl allows users to define non-canonical aminoacids (NCAAs) and include them in simulations, such as design efforts and mutations. Besides using the NCAAs included with ProtoSyn, by default, in this brief tutorial the process to add a new NCAA is explored, as well as its implementation in a simple mutation application. The example NCAA is retrieved directly from a protein pose, by extracting the residue of interest from a downloaded file from Protein Data Bank (PDB).","category":"page"},{"location":"getting-started/examples/#Post-translational-modifications","page":"Examples","title":"15 - Post-translational modifications","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. Post translational modifications (PTMs) are structural modifications to a structure, usually performed after synthesis, and can include the removal or addition of functional groups. Some examples of PTMs include methylation and phosphorylation processes, where methyl- and phosphoryl- groups are grafted to a given residue. In this tutorial, both these processes will be exemplified, making use of ProtoSyn's structural manipulation methods.","category":"page"},{"location":"getting-started/examples/#Materials-and-carbons","page":"Examples","title":"16 - Materials & carbons","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here.  The objective of this example is to introduce methods and types for the creation and manipulation of both cristaline & amorphous inorganic structures. In the current version, this is restricted to a few basic unit cell repetitions and carbon sheets. These are, however, useful when setting up benchmarks for the measurement of speed/accuracy of new or improved energy functions, for example. In this example, we will create a repetition of one such basic unit cell, the primitive lattice. More interestingly, perhaps, are the methods for carbon sheet generation and manipulation. In this example, the topics of generation of simple carbon sheets, multi-layer carbon microcrystallites, pore generation and functionalization are explored and showcased.","category":"page"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"ukw: Note:\nWould you like to see a topic covered in a more in-depth tutorial? Don't hesitate to contact or drop an issue in the project's GitHub page.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/","page":"Monte Carlo","title":"Monte Carlo","text":"CurrentModule = ProtoSyn.Drivers","category":"page"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/#Monte-Carlo-Driver","page":"Monte Carlo","title":"Monte Carlo Driver","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/","page":"Monte Carlo","title":"Monte Carlo","text":"The Monte Carlo Driver uses a sampling AbstractMutator to generate a conformational change, evaluating it accoridng to a given EnergyFunction or custom evaluating function, and deciding wether to keep the new Pose or return to the previous State according to the Metropolis Criterion.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/","page":"Monte Carlo","title":"Monte Carlo","text":"MonteCarlo\nMonteCarloState","category":"page"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/#ProtoSyn.Drivers.MonteCarlo","page":"Monte Carlo","title":"ProtoSyn.Drivers.MonteCarlo","text":"MonteCarlo(eval!::Union{Function, EnergyFunction}, sample!::Union{Function, AbstractMutator, Driver}, callback::Opt{Callback}, max_steps::Int, temperature::Function)\n\nA MonteCarlo Driver instance. As such, this object is callable as a functor with the following signature:\n\n(driver::MonteCarlo)(pose::Pose)\n\nThis simulation performs a Markov Chain Monte Carlo algorithm (MCMC), more especifically, the Metropolis-Hastings method. Starting from an initial Pose pose conformation, new changes are imposed by calling the given sample! method (this is an AbstractMutator, Driver or a custom sampling function). Note that the Pose is synched (using the sync! method) after each sample! call. The two Pose instances are evaluated by calling the eval! method (an EnergyFunction or custom evaluator function). Following the Metropolis Criterion, the new Pose is accepted if the evaluated energy is lower than the previous Pose, or, otherwise, with a given probability based on the temperature of the simulation:\n\n rand()e^-fracE_n+1-E_nT \n\nWhere E_n+1 is the energy of new Pose, E_n is the current Pose energy and T is current temperature of the simulation. As such, higher temperature values correlate with a higher chance to accept higher energy Pose instances (in order to overcome energy barriers). If rejected, the previous Pose is recovered for a new attempt. This simulation loop (sample! -> eval! -> metropolis criterion) continues for a total of max_steps. Each step, a call to an optional Callback callback is performed. A companion MonteCarloState DriverState instance is also updated each step and provided to the Callback callback.\n\nFields\n\neval!::Union{Function, EnergyFunction} - The evaluator EnergyFunction or custom function, receives a Pose pose as the single argument;\nsample!::Union{Function, AbstractMutator, Driver} - The sampler method, receives a Pose pose as the single input argument;\ncallback::Opt{Callback} - An optional Callback instance, receives two input arguments: the current Pose pose and the current DriverState driver_state;\nmax_steps::Int - The total number of simulation steps to be performed;\ntemperature::Function - The temperature function thermostat (see Available thermostats), receives the current step (as an Int) as the single input argument.\n\nSee also\n\nMonteCarloState\n\nExamples\n\njulia> monte_carlo = ProtoSyn.Drivers.MonteCarlo(\n                  energy_function,\n                  dihedral_mutator,\n                  ProtoSyn.Common.default_energy_step_callback(1),\n                  10,\n                  ProtoSyn.Drivers.get_linear_quench(1.0, 10))\n⚒  Monte Carlo Driver:\n ├──  ●  Evaluator:\n |    └── 🗲  Energy Function (4 components):\n |        +----------------------------------------------------------------------+\n |        | Index | Component name                                | Weight (α)   |\n |        +----------------------------------------------------------------------+\n |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |        +----------------------------------------------------------------------+\n |   \n ├──  ● Sampler:\n |    └── ⚯  Dihedral Mutator:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                       | Value                          |\n |        +----------------------------------------------------------------------+\n |        | 1     | angle_sampler               | Function randn                 |\n |        | 2     | p_mut                       | 0.0100                         |\n |        | 3     | step_size                   | 0.5000                         |\n |        +----------------------------------------------------------------------+\n |         ● Selection: Set\n |         └── FieldSelection › Atom.name = r\"C|N\"\n |   \n ├──  ● Callback:\n |    └── ✉  Callback:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                     | Value                            |\n |        +----------------------------------------------------------------------+\n |        | 1     | Event                     | energy_step                      |\n |        | 2     | Frequency                 | 1                                |\n |        +----------------------------------------------------------------------+\n |   \n └──  ● Settings:\n       Max steps: 10\n     Temperature: linear_quench\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/#ProtoSyn.Drivers.MonteCarloState","page":"Monte Carlo","title":"ProtoSyn.Drivers.MonteCarloState","text":"MonteCarloState{T <: AbstractFloat}(step::Int = 0, converged::Bool = false, completed::Bool = false, stalled::Bool = false, acceptance_count = 0, temperature::T = T(0.0))\nMonteCarloState{T <: AbstractFloat}()\n\nA MonteCarloState instance is a DriverState that keeps track of a MonteCarlo simulation status. Besides the default :step, :converged, :completed and :stalled fields, a MonteCarloState instance adds the following tracking fields specific for MonteCarlo simulations:\n\nacceptance_count::Int - The number of accepted Pose changes by the Metropolis criterion;\ntemperature::T - The current temperature of the simulation.\n\nSee also\n\nMonteCarlo\n\nExamples\n\njulia> ProtoSyn.Drivers.MonteCarloState{Float64}()\nProtoSyn.Drivers.MonteCarloState{Float64}(0, false, false, false, 0, 0.0)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/","page":"Monte Carlo","title":"Monte Carlo","text":"(Image: ProtoSyn monte-carlo-driver)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/","page":"Monte Carlo","title":"Monte Carlo","text":"Figure 1 | A schematic overview of the different stages in a MonteCarlo Driver: (1) - Sampling a new conformation; (2) - Evaluating the new Pose; (3) - Metropolis Criterion, the new Pose conformation is either accepted (in which case it is saved as a reference for further steps in the simulation) or rejected (where the current state is recovered from a saved Pose to the previous step).","category":"page"},{"location":"protosyn-api/peptides/calculators/sasa/","page":"SASA","title":"SASA","text":"CurrentModule = ProtoSyn.Peptides.Calculators.SASA","category":"page"},{"location":"protosyn-api/peptides/calculators/sasa/#peptides-calculators-sasa","page":"SASA","title":"SASA","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/sasa/","page":"SASA","title":"SASA","text":"The Peptides module SASA section expands the Core module methods (See SASA) specifically to measure SASA values (and approximate energy values) on protein and peptide sequences. ","category":"page"},{"location":"protosyn-api/peptides/calculators/sasa/","page":"SASA","title":"SASA","text":"calculate_max_sasa\ncalculate_average_sasa\nget_default_sasa_energy","category":"page"},{"location":"protosyn-api/peptides/calculators/sasa/#ProtoSyn.Peptides.Calculators.SASA.calculate_max_sasa","page":"SASA","title":"ProtoSyn.Peptides.Calculators.SASA.calculate_max_sasa","text":"calculate_max_sasa(selection::AbstractSelection, residue_list::Vector{Char}; grammar::LGrammar = Peptides.grammar, probe_radius::T = 1.4, n_points::Int = 100) where {T <: AbstractFloat}\n\nFor each Residue type in residue_list, build a template from the provided LGrammar grammar (Peptides.grammar, by default) and evaluate the maximum SASA (the single Residue instance completly solvated by the implicit solvent). The the given AbstractSelection selection, probe_radius and n_points settings are used to calculate the SASA value (see calc_sasa). Note that, when using the maximum SASA for comparison with the evaluated SASA in a complex and partially occluded system (such as a protein environment), the same settings should be employed (AbstractSelection, probe_radius and n_points). Returns a dictionary with a maximum SASA value for each queried Residue type.\n\nukw: Note:\nThis method is used to define default_sidechain_max_sasa using the default settings from get_default_sasa_energy:AbstractSelection: (SidechainSelection() & !as\"H\") | an\"CA\"\nprobe_radius: 2.8 Å\nn_points: 100\n\nSee also\n\ncalculate_average_sasa\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.SASA.calculate_max_sasa(((SidechainSelection() & !as\"H\") | an\"CA\"), ['R', 'G'], probe_radius = 2.8)\nDict{String, Float64} with 2 entries:\n  \"GLY\" => 100.0\n  \"ARG\" => 260.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/sasa/#ProtoSyn.Peptides.Calculators.SASA.calculate_average_sasa","page":"SASA","title":"ProtoSyn.Peptides.Calculators.SASA.calculate_average_sasa","text":"calculate_average_sasa(pose::Pose, selection::AbstractSelection, max_sasas::Dict{String, T}; probe_radius::T = 1.4, n_points::Int = 100) where {T <: AbstractFloat}\n\nCalculates the average SASA exposure of the given Pose pose (as a % in relation to the maximum SASA, as defined in max_sasas - see calculate_max_sasa). If an AbstractSelection selection is provided, only the selected Atom instances will be considered for SASA calculation (using the given probe_radius and n_points). Note that for comparison, make sure the max_sasas were calcualted using the same  settings (selection, probe_radius and n_points). If using an AbstractSelection that only selects a given subset of Residue instances (instead of a subset of Atom instances in all Residue instances), note that the SASA can only be occluded by all other selected Residue instances. This generally tens to return a much higher average SASA value.\n\nukw: Note:\nIn the default Peptides SASA EnergyFunctionComponent (see get_default_sasa_energy), a Ω value sets the average SASA value for a Residue instance in the evaluated Pose. calculate_average_sasa can help setting this value.\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.SASA.calculate_average_sasa(pose, ((SidechainSelection() & !as\"H\") | an\"CA\"), Peptides.Calculators.SASA.default_sidechain_max_sasa, probe_radius = 2.8)\n0.49055441526123295\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/sasa/#ProtoSyn.Peptides.Calculators.SASA.get_default_sasa_energy","page":"SASA","title":"ProtoSyn.Peptides.Calculators.SASA.get_default_sasa_energy","text":"get_default_sasa_energy(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default SASA energy EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance, 1.0 by default). This function employs calc_sasa as the :calc function.\n\nukw: Note:\nThis EnergyFunctionComponent is similar to the ProtoSyn.Calculators.SASA.get_default_sasa_energy version, but adds the correct selection and max_sasas dictionary (specifically for peptides).\n\nSettings\n\nn_points::Int - The number of points to generate in each Atom sphere (higher number of points leads to higher accuracy, at the expense of performance);\nprobe_radius::T - The distance of each point in a generated sphere to the central Atom instance. Any point within probe_radius of any other atom is considered buried Residue name (where T <: AbstractFloat);\nhydrophobicity_map::Dict{String, T} - A dictionary of hydrophobicity values for each Residue name, positive values indicate hydrophobicity and vice-versa (where T <: AbstractFloat);\nmax_sasas::Dict{String, T} - A dictionary of max_sasa values (SASA values for fully-solvated Residue instances) for each Residue name (where T <: AbstractFloat);\nΩ::T - The average exposure value (between 0.0 and 1.0), any SASA value bellow this percentage of maxsasa is considered buried (where T <: AbstractFloat) (see [`calculateaverage_sasa`](@ref)).\n\nSee also\n\ncalc_sasa_energy\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.SASA.get_default_sasa_energy()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | SASA_Solvation                   |\n| Alpha (α)      | 1.0                              |\n| Update forces  | false                            |\n| Calculator     | calc_sasa_energy                 |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | max_sasas                     | Dict{String, Float64}(22 components)             |\n |    | hydrophobicity_map            | Dict{String, Float64}(22 components)             |\n |    | Ω                             | 0.5                                              |\n |    | probe_radius                  | 2.8                                              |\n |    | n_points                      | 100                                              |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ●  Selection:\n      └── BinarySelection ❯  | \"or\" (Atom)\n           ├── BinarySelection ❯  & \"and\" (Atom)\n           |    ├── SidechainSelection › (Atom)\n           |    └── UnarySelection ❯ ! \"not\" (Atom)\n           |         └── FieldSelection › Atom.symbol = H\n           └── FieldSelection › Atom.name = CA\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/custom-ref-energy/","page":"Custom reference energy","title":"Custom reference energy","text":"CurrentModule = ProtoSyn.Calculators","category":"page"},{"location":"protosyn-api/core/calculators/custom-ref-energy/#Custom-reference-energy","page":"Custom reference energy","title":"Custom reference energy","text":"","category":"section"},{"location":"protosyn-api/core/calculators/custom-ref-energy/","page":"Custom reference energy","title":"Custom reference energy","text":"Similarly to the logic behind TorchANI reference energy EnergyFunctionComponent, it is often useful to attribute a custom reference energy to a Residue type (by name). This can be, for example, to promote a positive bias towards a certain sub-set of aminoacids during mutation/design processes. The following methods allow the introduction of custom reference energies in ProtoSyn energy evaluations.","category":"page"},{"location":"protosyn-api/core/calculators/custom-ref-energy/","page":"Custom reference energy","title":"Custom reference energy","text":"Calculators.calc_custom_ref_energy\nCalculators.get_default_custom_ref_energy","category":"page"},{"location":"protosyn-api/core/calculators/custom-ref-energy/#ProtoSyn.Calculators.calc_custom_ref_energy","page":"Custom reference energy","title":"ProtoSyn.Calculators.calc_custom_ref_energy","text":"Calculators.calc_custom_ref_energy([::A], pose::Pose, selection::Opt{AbstractSelection}, update_forces::Bool = false; [map::Opt{Dict{AbstractSelection, T}} = nothing]) where {A, T <: AbstractFloat}\n\nCalculate and return the Pose pose energy according to the given map. The map is a 1 to 1 correspondence between AbstractSelection instances and energy values. If provided, an AbstractSelection selection limits the selected range of Atom instances considered for this EnergyFunctionComponent calculation. Note that any provided selection and map AbstractSelection type are promoted to the biggest value: selection is promoted to the AbstractSelection type of map if the map type is larger or vice-versa. update_forces Bool has no effect in this EnergyFunctionComponent calculation and is only included to provide a standard function signature between all EnergyFunctionComponent instances. If no map is provided, returns 0.0.\n\nExamples\n\njulia> ProtoSyn.Calculators.calc_custom_ref_energy(pose, nothing, false)\n(0.0, nothing)\n\njulia> ProtoSyn.Calculators.calc_custom_ref_energy(pose, nothing, false, map = Dict{AbstractSelection, Float64}(rn\"ALA\" => 3.0, rn\"GLU\" => 2.4))\n(71.4, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/custom-ref-energy/#ProtoSyn.Calculators.get_default_custom_ref_energy","page":"Custom reference energy","title":"ProtoSyn.Calculators.get_default_custom_ref_energy","text":"get_default_custom_ref_energy(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default custom reference energy EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). This component employs the calc_custom_ref_energy method, therefore defining a Pose energy based on a user-defined map between AbstractSelection instances and energy values.\n\nSettings\n\nmap::Dict{AbstractSelection, T} - Defines which map the custom reference energy should use;\n\nExamples\n\njulia> ProtoSyn.Calculators.get_default_custom_ref_energy()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | Custom_Ref_Energy                |\n| Alpha (α)      | 1.0                              |\n| Update forces  | true                             |\n| Calculator     | calc_custom_ref_energy           |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | map                           | Dict{AbstractSelection, Float64}(0 components)   |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/methods/pose/#pose-methods","page":"Pose","title":"Pose","text":"","category":"section"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"As previously stated, a Pose is the main object of ProtoSyn and brings together both the Graph and the State. The following methods directly operate on Pose structs. These methods are subdivided by topics, for organization purposes:","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"Creating, appending and inserting Fragments\nAppending, inserting and removing Atom and Residue instances\nCopying and merging\nAligning poses\nDiagnosing poses","category":"page"},{"location":"protosyn-api/core/methods/pose/#Creating,-appending-and-inserting-Fragments","page":"Pose","title":"Creating, appending and inserting Fragments","text":"","category":"section"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"The next methods allow a user to create a new Fragment from a Pose instance and append or insert in in an existing structure. Note: creation of a new Fragment from a sequence of Residue codes is available at the Builder submodule.","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"fragment(::Pose{Topology})\nfragment!\nisfragment\nappend_fragment_as_new_segment!(::Pose{Topology}, ::Fragment)\nappend_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Pose{Segment}; ::Any)\ninsert_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Pose{Segment}; ::Any, ::Bool)","category":"page"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.fragment-Tuple{Pose{Topology}}","page":"Pose","title":"ProtoSyn.fragment","text":"fragment(pose::Pose{Topology})\n\nReturn a Fragment from a given Pose pose. The pose must have a single Segment.\n\nfragment(pose::Pose{Topology}, selection::ProtoSyn.AbstractSelection)\n\nReturn a Fragment from a list of residues retrieved from the given selection when applied to the provided Pose pose. If not yet of selection type Residue, the selection will be promoted to Residue selection type (with the default any aggregating function). The resulting list of residues must be contiguous (a connected graph of Residue instances parenthoods). These will constitute the unique Segment of the resulting Fragment.\n\nukw: Note:\nA Fragment is a Pose{Segment}, without a root/origin. These are usually used as temporary carriers of information, without the ability to be directly incorporated in simulations.\n\nExamples\n\njulia> frag = fragment(pose)\nFragment(Segment{/UNK:9547}, State{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> frag = fragment(pose, rid\"1:10\")\nFragment(Segment{/UNK:58266}, State{Float64}:\n Size: 160\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.fragment!","page":"Pose","title":"ProtoSyn.fragment!","text":"fragment!(pose::Pose{Topology}, selection::ProtoSyn.AbstractSelection; [keep_downstream_position::Bool = true])\n\nReturn a Fragment from a list of residues retrieved from the given AbstractSelection selection when applied to the provided Pose pose. If not yet of selection type Residue, the selection will be promoted to Residue selection type (with the default any aggregating function). The resulting list of residues must be contiguous (a connected graph of Residue instances parenthoods). These will constitute the unique Segment of the resulting Fragment. In opposition to the fragment method, this function will remove the fragmented Residue instances from the original Pose (using the pop_residue! method). If keep_downstream_position is set to true (is, by default), the downstream Residue position is maintained (by calling request_c2i! and sync! methods).\n\nukw: Note:\nA Fragment is a Pose{Segment}, without a root/origin. These are usually used as temporary carriers of information, without the ability to be directly incorporated in simulations.\n\nExamples\n\njulia> frag = fragment!(pose, rid\"19:26\")\nFragment(Segment{/UNK:9547}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.isfragment","page":"Pose","title":"ProtoSyn.isfragment","text":"isfragment(pose::Pose)\n\nReturn true if the given pose Graph is a single non-empty Segment (with no container).\n\nSee also\n\nfragment\n\nExamples\n\njulia> isfragment(frag)\ntrue\n\njulia> isfragment(pose)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.append_fragment_as_new_segment!-Tuple{Pose{Topology}, Fragment}","page":"Pose","title":"ProtoSyn.append_fragment_as_new_segment!","text":"append_fragment_as_new_segment!(pose::Pose{Topology}, frag::Fragment)\n\nAppend a Fragment frag as a new Segment to the given Pose pose. This function overwrites pose.\n\nSee also\n\nisfragment fragment\n\nExamples\n\njulia> ProtoSyn.append_fragment_as_new_segment!(pose, frag)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.append_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Fragment}","page":"Pose","title":"ProtoSyn.append_fragment!","text":"append_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, frag::Pose{Segment}; op = \"α\")\n\nAdd the Fragment frag to the given Pose pose, appending it after the given Residue residue. This residue and the new Fragment frag will be connected using operation op (\"α\" by default) of the given LGrammar grammar. Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nSee also\n\ninsert_fragment!\n\nExamples\n\njulia> ProtoSyn.append_fragment!(pose, pose.graph[1][end], res_lib, frag)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.insert_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Fragment}","page":"Pose","title":"ProtoSyn.insert_fragment!","text":"insert_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, frag::Pose{Segment}; op = \"α\")\n\nInsert the Fragment frag in the given pose, on the position of the provided Residue instance residue (the residue gets shifted downstream). This first downstream Residue and the new Fragment will be connected using operation op (\"α\" by default) from [LGrammar] grammar. Also connects to the upstream Residue instance, using the same operation. Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nukw: Note:\nConsider using more specific versions of this function, see Peptides.insert_fragment!\n\nSee also\n\nappend_fragment!\n\nExamples\n\njulia> ProtoSyn.insert_fragment!(pose, pose.graph[1][1], res_lib, frag)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/pose/#Appending,-inserting-and-removing-Atom-and-Residue-instances","page":"Pose","title":"Appending, inserting and removing Atom and Residue instances","text":"","category":"section"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"In this section the methods responsible to manipulating the molecular structure of a Pose are explored.","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"insert_atom_as_children!\npop_atom!\npop_atoms!\npop_residue!\nsort_atoms_by_graph!\nadd_hydrogens!\nreplace_by_fragment!","category":"page"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.insert_atom_as_children!","page":"Pose","title":"ProtoSyn.insert_atom_as_children!","text":"insert_atom_as_children!(pose::Pose, parent_atom::Atom, atom::Atom, [atomstate::Opt{AtomState} = nothing])\n\nAdd the given Atom atom to the Pose pose graph, as a child of parent_atom. Correctly sets atom.container, container.size, container.items_by_name, parenthood relationships, bonds, indexes and ascedents. If an optional AtomState atomstate is provided, the inserted atom's State is set, otherwise, insert an empty State (with all internal and cartesian coordinates set to zero). Return the modified (in-place) Pose pose.\n\nExamples\n\njulia> ProtoSyn.insert_atom_as_children!(pose, pose.graph[1][1][1], Atom(\"N\", 1, 1, \"N\"))\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 344\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.pop_atom!","page":"Pose","title":"ProtoSyn.pop_atom!","text":"pop_atom!(pose::Pose{Topology}, atom::Atom; [keep_downstream_position::Bool = true])\n\nPop and return the given Atom atom from the given Pose pose. In order to do this, perform the following actions:\n\nUnset parenthood relationships (On Atom level only);\nUnbond neighbouring Atom instances;\nRemove from Graph;\nRemove from State;\nSet new ascendents;\nUpdate the container.itemsbyname.\n\nIf keep_downstream_position is set to true (is, by default), the downstream Residue position is maintained (by calling request_c2i! and sync! methods). In either case, this method requests internal to cartesian coordinates conversion at the end (using the request_i2c! method).\n\nSee also\n\npop_residue!\n\nExamples\n\njulia> ProtoSyn.pop_atom!(pose, pose.graph[1][1][2])\nPose{Atom}(Atom{/H:6299}, State{Float64}:\n Size: 1\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.pop_atoms!","page":"Pose","title":"ProtoSyn.pop_atoms!","text":"pop_atoms!(pose::Pose{Topology}, selection::Opt{AbstractSelection} = nothing; keep_downstream_position::Bool = false)\n\nRemove all selected atoms (by the given AbstractSelection selection) from the provided Pose pose. keep_downstream_position sets whether to re-calculate the internal coordinates of downstream Atom instances (children) from cartesian coordinates (set to false, by default).\n\nSee also\n\npop_atom!\n\nExamples\n\njulia> ProtoSyn.pop_atoms!(pose, as\"H\")\nPose{Topology}(Topology{/1bkr:24417}, State{Float64}:\n Size: 887\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.pop_residue!","page":"Pose","title":"ProtoSyn.pop_residue!","text":"pop_residue!(pose::Pose{Topology}, residue::Residue; [keep_downstream_position::Bool = false])\n\nPop and return the desired Residue residue from the given Pose pose. This is peformed by popping each Atom of the Residue residue individually. If keep_downstream_position is set to true (is, by default), the downstream Residue position is maintained (by calling request_c2i! and sync! methods). In either case, this method requests internal to cartesian coordinates conversion at the end (using the request_i2c! method).\n\nukw: Note:\nThe resulting Pose is re-indexed, therefore Residue N + 1 becomes Residue N. When removing multiple Residue instances, consider performing a reversed loop.\n\nSee also\n\npop_atom!\n\nExamples\n\njulia> r = ProtoSyn.pop_residue!(pose, pose.graph[1][5])\nPose{Residue}(Residue{/ALA:51397}, State{Float64}:\n Size: 10\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.sort_atoms_by_graph!","page":"Pose","title":"ProtoSyn.sort_atoms_by_graph!","text":"sort_atoms_by_graph!(state::State, container::Residue; [start::Opt{Atom} = nothing], [search_algorithm::F = ProtoSyn.BFS]) where {F <: SearchAlgorithm}\n\nSorts the Atom instances in the given Residue container to match its graph. By default, employs travel_graph to get the new sorted list of Atom instances (from the first Atom in the Residue container, set start argument to define a new starting point). Also updates the Atom order in the corresponding and provided State state. Expects both the State and respective Graph to be correctly re-indexed (see reindex). By default, uses search_algorithm BFS (breath first search). Note that, after sorting, Atom indexes may be wrong. It's reccommended to reindex the encompassing Pose after.\n\nsort_atoms_by_graph!(state::State, container::Union{Topology, Segment}; [start::Opt{Atom} = nothing], [search_algorithm::F = ProtoSyn.BFS]) where {F <: SearchAlgorithm}\n\nApplies sort_atoms_by_graph! to all Residue instances in the given container. Automatically calls reindex after sorting the Atom instances.\n\nsort_atoms_by_graph!(pose::Pose; start::Opt{Atom} = nothing, search_algorithm::F = ProtoSyn.DFS) where {F <: SearchAlgorithm}\n\nApplies sort_atoms_by_graph! to all Residue instances in the given Pose pose. Automatically calls reindex after sorting the Atom instances.\n\nukw: Note:\nWhen applying sort_atoms_by_graph! to a Pose, Topology or Segment, the sorting is still performed at the Residue level (one Residue at a time), therefore the chain sorting based on graph size only takes into account intra-residue Atom instances.\n\nExamples\n\njulia> ProtoSyn.sort_atoms_by_graph!(pose.state, pose.graph[1, 1])\n(State{Float64}:\n Size: 1140\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n, Residue{/2a3d:3900/A:1/MET:1})\n\njulia> ProtoSyn.sort_atoms_by_graph!(pose.state, pose.graph, search_algorithm = ProtoSyn.Peptides.IUPAC)\n(State{Float64}:\n Size: 26\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n, Topology{/test:378})\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.add_hydrogens!","page":"Pose","title":"ProtoSyn.add_hydrogens!","text":"add_hydrogens!(pose::Pose, res_lib::LGrammar, selection::Opt{AbstractSelection} = nothing)\n\nPredict and add hydrogens to the provided Pose pose, according to the templates in the given LGrammar res_lib. Note that both residues and atoms are retrieved from the res_lib based on their name. If provided, an AbstractSelection selection limits the selected atoms to receive hydrogens (defaults to an Atom level AbstractSelection, expects Atom instances in the given Pose pose to be correctly indexed). This function applies internal coordinates based on the template from res_lib where the dihedral angle is rotated in order to match the current dihedral angles in the Pose pose. Make sure the internal coordinates are synched (using the sync! method).\n\nExamples\n\njulia> ProtoSyn.add_hydrogens!(pose, Peptides.grammar, rid\"1:10\")\nPose{Topology}(Topology{/1bkr:47568}, State{Float64}:\n Size: 975\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.replace_by_fragment!","page":"Pose","title":"ProtoSyn.replace_by_fragment!","text":"replace_by_fragment!(pose::Pose, atom::Atom, fragment::Fragment; [remove_downstream_graph::Bool = true], [spread_excess_charge::Bool = true])\n\nReplace the selected Atom atom instance (and any downstream children atom, if remove_downstream_graph is set to true (is, by default), uses travel_graph, with the default ProtoSyn.BFS search algorithm, starting on Atom atom to define the downstream region) with the given Fragment fragment, in the context of the provided Pose pose (updates the State and Graph). The first Atom in the Fragment fragment (also known as root or R Atom) is placed in the same position as the chosen Atom atom for replacement, and is then removed. This serves only to orient the remaining Fragment fragment. If the spread_excess_charge flasg is set to true (is, by default), the total sum of partial charges in the added Fragment fragment is divided by the number of remaning bonds (if remove_downstream_graph is set to true, some bonds may be removed during the replacement process) and added to each bonded Atom instance. Requests internal to cartesian coordinates.\n\nExamples\n\njulia> frag = ProtoSyn.getvar(ProtoSyn.modification_grammar, \"PO4\")\nFragment(Segment{/po4:18413}, State{Float64}:\n Size: 5\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.replace_by_fragment!(pose, pose.graph[1, 3, \"HG\"], frag)\nPose{Topology}(Topology{/2a3d:3900}, State{Float64}:\n Size: 1143\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#Copying-and-merging","page":"Pose","title":"Copying and merging","text":"","category":"section"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"The following methods allow a user to save or replicate an existing Pose (for example, for simulations with multiple molecules).","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"Base.copy(::Pose)\nrecoverfrom!\nmerge\nmerge!\nsymexp\nsymexp!","category":"page"},{"location":"protosyn-api/core/methods/pose/#Base.copy-Tuple{Pose}","page":"Pose","title":"Base.copy","text":"copy(pose::Pose)\n\nReturn a copied Pose of the provided pose. The resulting Pose will have different :id fields for the Graph Topology and State.\n\nThis function is a Base module overload.\n\nExamples\n\njulia> copy(pose)\nPose{Topology}(Topology{/UNK:9547}, State{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.recoverfrom!","page":"Pose","title":"ProtoSyn.recoverfrom!","text":"recoverfrom!(pose::Pose, backup::Pose)\n\nRecovers the Pose pose State and Graph from a backup Pose while maintaining any reference to the given Pose pose. In essence, when using a Driver, simply using copy! will create a new instance, and sometimes this can cause bugs. It's recommended to employ recoverfrom! in such cases.\n\nExamples\n\njulia> ProtoSyn.recoverfrom!(pose, backup)\nPose{Topology}(Topology{/2a3d:31788}, State{Float64}:\n Size: 1140\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.merge","page":"Pose","title":"ProtoSyn.merge","text":"merge(pose1::Pose, pose2::Pose)\n\nMerge the two given poses, creating a new Pose in the process.\n\nExamples\n\njulia> ProtoSyn.merge(pose, pose_mod)\nPose{Topology}(Topology{/merged:32083}, State{Float64}:\n Size: 686\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.merge!","page":"Pose","title":"ProtoSyn.merge!","text":"merge!(pose1::Pose, pose2::Pose)\n\nMerge the two given poses, updating/overwritting the given pose1.\n\nExamples\n\njulia> ProtoSyn.merge!(pose, pose_mod)\nPose{Topology}(Topology{/merged:10313}, State{Float64}:\n Size: 748\n i2c: false | c2i: true\n Energy: Dict(:Total => Inf)\n)\n...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.symexp","page":"Pose","title":"ProtoSyn.symexp","text":"symexp(pose::Pose, reps::Vector{Int}, unit_cell_dims::Vector{T}) where {T <: AbstractFloat}\n\nReturn a symmetry expanded Pose. Create N copies of the given pose in all 3 symmetry axis of a cubic lattice, where reps is the number of copies in each of the dimensions X, Y and Z (N is, therefore, reps[1]reps[2]reps[3]). Length of reps must be 3. unit_cell_dims sets the distance in each of dimension to translate the copies, in Angstrom Å. Length of unit_cell_dims must be 3. Copies the given pose, returning a new struct.\n\nSee also\n\nsymexp! merge\n\nExamples\n\njulia> ProtoSyn.symexp(pose, [2, 2, 2], [50.0, 50.0, 50.0])\nPose{Topology}(Topology{/UNK:59312}, State{Float64}:\n Size: 9261\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.symexp!","page":"Pose","title":"ProtoSyn.symexp!","text":"symexp!(pose::Pose, reps::Vector{Int}, unit_cell_dims::Vector{T}) where {T <: AbstractFloat}\n\nReturn a symmetry expanded Pose. Create N copies of the given pose in all 3 symmetry axis of a cubic lattice, where reps is the number of copies in each of the dimensions X, Y and Z (N is, therefore, reps[1]reps[2]reps[3]). Length of reps must be 3. unit_cell_dims sets the distance in each of dimension to translate the copies, in Angstrom Å. Length of unit_cell_dims must be 3. Copies the given pose, returning a new struct. Updates/overwrites the given pose.\n\nSee also\n\nsymexp merge\n\nExamples\n\njulia> ProtoSyn.symexp!(pose, [2, 2, 2], [50.0, 50.0, 50.0])\nPose{Topology}(Topology{/merged:10313}, State{Float64}:\n Size: 748\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn symexp)","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"Figure 1 | An example of the output of symexp with just one symmetry dimension. The second Pose is a copy of the original, translated in 1 dimension by the defined value.","category":"page"},{"location":"protosyn-api/core/methods/pose/#Aligning-poses","page":"Pose","title":"Aligning poses","text":"","category":"section"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"The following methods allow a user to juxtapose two Pose instances and measure the RMSD distance between them.","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"align!\ncenter_of_mass\nrmsd","category":"page"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.align!","page":"Pose","title":"ProtoSyn.align!","text":"align!(mobile::Pose, target::Pose)\nalign!(mobile::Pose, target::Pose, selection::ProtoSyn.AbstractSelection)\nalign!(mobile::Pose, target::Pose, mobile_selection::ProtoSyn.AbstractSelection, target_selection::ProtoSyn.AbstractSelection)\n\nApplication of the Kabsch algorithm. Applies a rotation + translation movement on the mobile Pose instance in order to align to the target Pose instance. If a selection is provided, only the subset of selected Atom instances (on both Pose structures) will be considered to calculate the necessary rotation + translation movement (minimizing the RMSD). If two AbstractSelection instances are provided (mobile_selection and target_selection), each is applied to the respective Pose instances (mobile and target, respectively) in order to calculate the necessary rotation + translation movement. Sets mobile.state.c2i to true and returns the altered mobile Pose instance.\n\nukw: Note:\nThis function can also align Fragment instances.\n\nSee also\n\nrmsd\n\nExamples\n\njulia> ProtoSyn.align!(pose, pose_mod)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.align!(pose, pose_mod, an\"CA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.align!(pose, pose_mod, an\"CA\", an\"CB\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.center_of_mass","page":"Pose","title":"ProtoSyn.center_of_mass","text":"center_of_mass(pose::Pose)\n\nReturn the center of mass X, Y and Z cartesian coordinates of the given Pose pose (based on the current cartesian coordinates - make sure the Pose pose is synched, using the sync! method).\n\ncenter_of_mass(pose::Pose, selection::AbstractSelection)\n\nReturn the center of mass X, Y and Z cartesian coordinates of the given Pose pose, taking into consideration only the subset of selected Atom instances in the AbstractSelection selection (based on the current cartesian coordinates - make sure the Pose pose is synched, using the sync! method).\n\ncenter_of_mass(pose::Pose, idxs::Vector{Int})\n\nReturn the center of mass X, Y and Z cartesian coordinates of the given Pose pose, taking into consideration only the subset of  Atom instances in the vector idxs (by Atom index, based on the current cartesian coordinates - make sure the Pose pose is synched, using the sync! method).\n\nExamples\n\njulia> ProtoSyn.center_of_mass(pose)\n3×1 Matrix{Float64}:\n 39.85855147920603\n 14.995282315671613\n -0.016516024315774907\n\njulia> ProtoSyn.center_of_mass(pose, an\"CA\")\n3×1 Matrix{Float64}:\n 37.56949530961898\n 14.249844760318357\n -5.4078476622375185e-16\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.rmsd","page":"Pose","title":"ProtoSyn.rmsd","text":"rmsd(pose1::Pose, pose2::Pose)\nrmsd(pose1::Pose, pose2::Pose, selection::AbstractSelection)\n\nCalculates the RMSD value between 2 Pose instances, based on the cartesian coordinates. Note: Make sure the poses have been synched beforehand (using the sync! method). If an AbstractSelection selection is provided, calculate the RMSD values of only the selected subset of Atom instances. Returns RMSD result in Angstrom (Å). \n\nSee also\n\nalign! getdihedral\n\nExamples\n\njulia> ProtoSyn.rmsd(pose, pose_mod)\n34.443215682826676\n\njulia> ProtoSyn.rmsd(pose, pose_mod, an\"CA\")\n32.5063913965703\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#pose-diagnose-core","page":"Pose","title":"Diagnosing poses","text":"","category":"section"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"ProtoSyn may sometimes expect a certain level of standardization between Pose instances. This includes, but is not restricted to, Atom names, order, graph completeness, neutral charge, etc. ProtoSyn makes available tools to diagnose Pose instances, when things take a turn for the worst, and other auxiliary methods for debugging faulty Pose instances.","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"diagnose\nset_parenthood_as_forces!\nwrite_forces","category":"page"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.diagnose","page":"Pose","title":"ProtoSyn.diagnose","text":"diagnose(pose::Pose; [return_issues::Bool = false], [atom_order_search_algorithm::F = ProtoSyn.BFS]) where {F <: SearchAlgorithm}\n\nMeasure several agreement criteria on the given Pose pose:\n\nChecks residue-level graph for any Residue instance without parent\nChecks atom-level graph for any Atom instance without parent\nChecks if atom-level graph travels all Atom instances in the given Pose pose\nChecks if atom-level graph and list of Atom instances in the given Pose pose have the same order\nChecks if any internal to cartesian coordinate conversion (or vice-versa) is pending\nCheck if the Pose pose indexation matches the order of atoms (both in the :id and :index fields)\n\nAny Graph travel is done using the ProtoSyn.travel_graph method, employing the given atom_order_search_algorithm (ProtoSyn.BFS, by default). If return_issues is set to true (false, by default) doesn't print results to stdout, returns them as a Vector{String} instead.\n\nExamples\n\njulia> ProtoSyn.diagnose(pose)\n ⬤   Diagnosing pose 4J88 ...\n |\n ├──  • Residue-level graph OK\n |\n ├──  • Atom-level graph (1 issue identified)\n |    └── Travelling from the first atom on the pose list, not all atoms were visited (From graph: 466 | From list: 1805).\n |        Check for breaks in the parenthood relationships. Suggested fix: consider using the infer_parenthood! function.\n |\n ├──  • Pose synchronization status OK\n |\n └──  • Pose indexation (1 issue identified)\n      └── Pose indexation doesn't match the current order of atoms in each AbstractContainer (on the :id fields).\n          Check atoms 63 and 64. Suggested fix: Consider using the reindex function.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.set_parenthood_as_forces!","page":"Pose","title":"ProtoSyn.set_parenthood_as_forces!","text":"set_parenthood_as_forces!(pose::Pose, [selection::Opt{AbstractSelection} = nothing])\n\nSet a vector between any given Atom instance in the provided Pose pose and its .parent as that Atom instance's force (in the pose.state). If an AbstractSelection selection is given, only loop over the selected atoms. Useful for debuging purposes.\n\nSee also\n\nwrite_forces\n\nExamples\n\njulia> ProtoSyn.set_parenthood_as_forces!(pose)\n\njulia> pose.state.f\n3×7 Matrix{Float64}:\n  0.512436     -1.4          -0.7          -1.43         0.7           1.4           0.7\n  0.512436      0.0           1.21244      -1.46422e-7   1.21244      -4.88498e-15  -1.21244\n -6.27553e-17   1.21234e-16  -1.31353e-16   8.09416e-7  -2.52586e-16  -1.21234e-16   1.31353e-16\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.write_forces","page":"Pose","title":"ProtoSyn.write_forces","text":"write_forces(pose::Pose, filename::String, α::T = 1.0) where {T <: AbstractFloat}\n\nWrite the Pose pose forces to filename in a specific format to be read by the companion Python script \"cgoarrow.py\" (see [https://pymolwiki.org/index.php/Cgoarrow](https://pymolwiki.org/index.php/Cgo_arrow)). α sets a multiplying factor to make the resulting force vectors longer/shorter (for visualization purposes only).\n\nSee also\n\nset_parenthood_as_forces!\n\nExamples\n\njulia> ProtoSyn.write_forces(pose, \"forces.dat\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/natural-frequency/","page":"Natural frequency","title":"Natural frequency","text":"CurrentModule = ProtoSyn.Peptides.Calculators","category":"page"},{"location":"protosyn-api/peptides/calculators/natural-frequency/#Natural-frequency","page":"Natural frequency","title":"Natural frequency","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/natural-frequency/","page":"Natural frequency","title":"Natural frequency","text":"The Natural frequency Calculators module introduces a measure of how likely a given peptide sequence is based on the natural distribution of aminoacids in nature, according to Krick et al. (See this paper).","category":"page"},{"location":"protosyn-api/peptides/calculators/natural-frequency/","page":"Natural frequency","title":"Natural frequency","text":"calc_aa_frequency\nget_default_aa_frequency","category":"page"},{"location":"protosyn-api/peptides/calculators/natural-frequency/#ProtoSyn.Peptides.Calculators.calc_aa_frequency","page":"Natural frequency","title":"ProtoSyn.Peptides.Calculators.calc_aa_frequency","text":"calc_aa_frequency([::Type{A}], pose::Pose, selection::Opt{AbstractSelection}, update_forces::Bool; [aa_frequency_map::Dict{Char, T} = default_aa_frequencies]) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat}\n\nCalculates an energy value based on the total number of Residue instances in the given Pose of a single type. For each Residue type, a corrresponding value should be provided in aa_frequency_map (this method adds the inverse of that value as an energy reward). By default, aa_frequency_map reflects the natural distribution of aminoacids, according to Krick et al. (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4209132/). Different aa_frequency_map instances can introduce bias towards certain types of aminoacids in simulations. If provided, an AbstractSelection selection limits the subset of considered Residue instances for aminoacid frequency calculation (selection is promoted to Residue level using the promote method). update_forces has no effect and exists only in order to standardize calls between Calculators. An optional parameter Type{<: AbstractAccelerationType} can be provided, stating the acceleration type used to calculate this energetic contribution (See ProtoSyn acceleration types, if not provided defaults to ProtoSyn.acceleration.active).\n\nSee also\n\nget_default_aa_frequency\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.calc_aa_frequency(pose, nothing, false)\n(-456.50000000000017, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/natural-frequency/#ProtoSyn.Peptides.Calculators.get_default_aa_frequency","page":"Natural frequency","title":"ProtoSyn.Peptides.Calculators.get_default_aa_frequency","text":"get_default_aa_frequency(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default natural frequency energy EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance, 1.0 by default). This function employs calc_aa_frequency as the :calc function.\n\nSettings\n\naa_frequency_map::Dict{Char, T} - A mapping between Residue types (in 1-letter code format) and the natural frequency of aminoacids of that type;\n\nSee also\n\ncalc_aa_ss_propensity\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.get_default_aa_frequency()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | Natural_AA_Freq                  |\n| Alpha (α)      | 1.0                              |\n| Update forces  | false                            |\n| Calculator     | calc_aa_frequency                |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | aa_frequency_map              | Dict{Char, Float64}(20 components)               |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/","page":"Hydrogen Bonds","title":"Hydrogen Bonds","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/#Hydrogen-bonds","page":"Hydrogen Bonds","title":"Hydrogen bonds","text":"","category":"section"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/","page":"Hydrogen Bonds","title":"Hydrogen Bonds","text":"ProtoSyn aims to evaluate the stabilizing energy contribution of hydrogen bonds using a simple geometric potential. For each HydrogenBondPair in a pre-calculated HydrogenBondNetwork, the hydrogen bond energetic contribution is given by product of a given distance-based potential (see Available potentials) by the cos(α)cos(β), where α and β are the angles between the donor and receptor Atom instances (in each \"side\" of the interaction).","category":"page"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/","page":"Hydrogen Bonds","title":"Hydrogen Bonds","text":"(Image: ProtoSyn Hydrogen Bonds)","category":"page"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/","page":"Hydrogen Bonds","title":"Hydrogen Bonds","text":"Figure 1 | A schematic representation of the geometric criteria taken into account when estimating the hydrogen bonds stabilizing interactions. Besides the inter-atomic distance, ProtoSyn also calculates the α and β angles, with maximum energetic reward being given to planar conformations of the dimeric system.","category":"page"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/","page":"Hydrogen Bonds","title":"Hydrogen Bonds","text":"The Hydrogen bonds section is subdivided in the following sub-sections, for organizational purposes:","category":"page"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/","page":"Hydrogen Bonds","title":"Hydrogen Bonds","text":"Hydrogen bond network prediction\nHydrogen bonds EnergyFunctionComponent","category":"page"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/#Hydrogen-bond-network-prediction","page":"Hydrogen Bonds","title":"Hydrogen bond network prediction","text":"","category":"section"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/","page":"Hydrogen Bonds","title":"Hydrogen Bonds","text":"The generate_hydrogen_bond_network attempts to identify all donor and receptor Atom instances in a given Pose using rudimentary criteria. This may change in future versions of ProtoSyn.","category":"page"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/","page":"Hydrogen Bonds","title":"Hydrogen Bonds","text":"Calculators.HydrogenBonds.HydrogenBondPair\nCalculators.HydrogenBonds.HydrogenBondNetwork\nCalculators.HydrogenBonds.generate_hydrogen_bond_network","category":"page"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/#ProtoSyn.Calculators.HydrogenBonds.HydrogenBondPair","page":"Hydrogen Bonds","title":"ProtoSyn.Calculators.HydrogenBonds.HydrogenBondPair","text":"HydrogenBondPair(charged::Atom, base::Atom)\n\nDefine a new HydrogenBondPair. An HydrogenBondPair is a set of two bonded Atom instances, the charged and base atom. As an example, in a carbonyl group (-C=O), the carbon is the base and the oxygen is the charged atom. It's expected that this HydrogenBondPair is involved in hydrogen bonding interactions.\n\nSee also\n\nHydrogenBondNetwork\n\nExamples\n\njulia> ProtoSyn.Calculators.HydrogenBonds.HydrogenBondPair(pose.graph[1, 1, \"C\"], pose.graph[1, 1, \"O\"])\nMET:1:O - MET:1:C\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/#ProtoSyn.Calculators.HydrogenBonds.HydrogenBondNetwork","page":"Hydrogen Bonds","title":"ProtoSyn.Calculators.HydrogenBonds.HydrogenBondNetwork","text":"HydrogenBondNetwork(donors::Vector{HydrogenBondPair}, acceptors::Vector{HydrogenBondPair})\n\nDefine a new HydrogenBondNetwork, a set of donors HydrogenBondPair instances (strongly electronegative Atom instances, such as N, O or F) and acceptors HydrogenBondPair instances (electronegative Atom instances with a lone electron pair).\n\nHydrogenBondNetwork()\n\nDefine an empty HydrogenBondNetwork.\n\nSee also\n\ncalc_hydrogen_bond_network generate_hydrogen_bond_network\n\nExamples\n\njulia> ProtoSyn.Calculators.HydrogenBonds.generate_hydrogen_bond_network(pose)\nDonors: 131 | Acceptors: 104\n\njulia> ProtoSyn.Calculators.HydrogenBonds.HydrogenBondNetwork()\nDonors: 0 | Acceptors: 0\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/#ProtoSyn.Calculators.HydrogenBonds.generate_hydrogen_bond_network","page":"Hydrogen Bonds","title":"ProtoSyn.Calculators.HydrogenBonds.generate_hydrogen_bond_network","text":"generate_hydrogen_bond_network(pose::Pose, selection::Opt{AbstractSelection} = nothing)\n\nAttempts to predict the HydrogenBondNetwork of a given Pose pose (restricted to the selected region provided by the AbstractSelection selection). The following simple criteria are used:\n\nDonors are hydrogen (H) Atom instances connected to a single nitrogen (N) Atom instance;\nAcceptors are oxygen (O) Atom instances connected to a single carbon (C) Atom instance.\n\nExamples\n\njulia> ProtoSyn.Calculators.HydrogenBonds.generate_hydrogen_bond_network(pose)\nDonors: 131 | Acceptors: 104\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/#Hydrogen-bonds-EnergyFunctionComponent","page":"Hydrogen Bonds","title":"Hydrogen bonds EnergyFunctionComponent","text":"","category":"section"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/","page":"Hydrogen Bonds","title":"Hydrogen Bonds","text":"By default, ProtoSyn generates a new HydrogenBondNetwork each call to the default Hydrogen bonds EnergyFunctionComponent. This may cause performance losses. If no mutation/design process is being performed, consider employing fixate_hydrogen_bond_network! to set a static HydrogenBondNetwork.","category":"page"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/","page":"Hydrogen Bonds","title":"Hydrogen Bonds","text":"Calculators.HydrogenBonds.calc_hydrogen_bond_network\nCalculators.HydrogenBonds.get_default_hydrogen_bond_network\nCalculators.HydrogenBonds.fixate_hydrogen_bond_network!","category":"page"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/#ProtoSyn.Calculators.HydrogenBonds.calc_hydrogen_bond_network","page":"Hydrogen Bonds","title":"ProtoSyn.Calculators.HydrogenBonds.calc_hydrogen_bond_network","text":"calc_hydrogen_bond_network([::Type{A}], pose::Pose, selection::Opt{AbstractSelection}, update_forces::Bool; [hydrogen_bond_network::Union{HydrogenBondNetwork, Function} = HydrogenBondNetwork()], [potential::Function = (x; qi = 0.0, qj = 0.0) -> 0.0]) where {A <: ProtoSyn.AbstractAccelerationType}\n\nCalculate the Pose pose hydrogen bond energy according to the given potential function (make sure the Pose pose is synched, see sync!). ProtoSyn loops through the provided HydrogenBondNetwork hydrogen_bond_network and applied the potential to each pair of charged Atom instances (based on the inter-atomic distance). Besides this component, calc_hydrogen_bond_network adds a geometric potential based on the angle between the charged Atom instances and each base (rewards 180º conformations). Optionally, hydrogen_bond_network can be a Function, in which case a new HydrogenBondNetwork is calculated. Such a custom function should have the following signature:\n\nmy_hydrogen_bond_predictor(pose::Pose, selection::Opt{AbstractSelection} = nothing)\n\nIf provided, an AbstractSelection selection limits the selected Atom instances considered for HydrogenBondNetwork prediction (if hydrogen_bond_network is a Function, otherwise the provided HydrogenBondNetwork is static and selection has no effect). An optional parameter A (Type{<: AbstractAccelerationType}) can be provided, stating the acceleration type used to calculate this energetic contribution (See ProtoSyn acceleration types). Uses ProtoSyn.acceleration.active by default. Note that, depending on the potential employed, atomic charges may be required (See assign_default_charges, for example).\n\nSee also\n\nget_default_hydrogen_bond_network\n\nExamples\n\njulia> e, f, hb_pairs = ProtoSyn.Calculators.HydrogenBonds.calc_hydrogen_bond_network(pose, nothing, false, hydrogen_bond_network = hbn, potential = potential)\n(-9.329167508668307, nothing, (...))\n\njulia> hb_pairs\n122-element Vector{Tuple{Atom, Atom}}:\n(Atom{/2a3d:41940/A:1/MET:1/O:19}, Atom{/2a3d:41940/A:1/TRP:4/H:39})\n(Atom{/2a3d:41940/A:1/MET:1/O:19}, Atom{/2a3d:41940/A:1/ALA:5/H:63})\n(Atom{/2a3d:41940/A:1/GLY:2/O:26}, Atom{/2a3d:41940/A:1/ALA:5/H:63})\n(...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/#ProtoSyn.Calculators.HydrogenBonds.get_default_hydrogen_bond_network","page":"Hydrogen Bonds","title":"ProtoSyn.Calculators.HydrogenBonds.get_default_hydrogen_bond_network","text":"get_default_hydrogen_bond_network(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default hydrogen bond EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). This component employs the calc_hydrogen_bond_network method, therefore defining a Pose energy based on a given potential function multiplied by a geometric angle component for each pair defined in an HydrogenBondNetwork. By default, this EnergyFunctionComponent uses the generate_hydrogen_bond_network function to predict a new HydrogenBondNetwork each call. Consider setting efc.settings[:hydrogen_bond_network] as an HydrogenBondNetwork to employ a static list of interacting Atom instances (for improved performance).\n\nSee also\n\nfixate_hydrogen_bond_network!\n\nSettings\n\nhydrogen_bond_network::Union{HydrogenBondNetwork, Function} - Defines either the HydrogenBondNetwork predictor function or static HydrogenBondNetwork;\npotential::Function - Define the potential to apply (calculates energy and force value from inter-atomic distance - and optionally atomic charges qi & qj);\n\nExamples\n\njulia> ProtoSyn.Calculators.HydrogenBonds.get_default_hydrogen_bond_network()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | Hydrogen_Bonds                   |\n| Alpha (α)      | 1.0                              |\n| Update forces  | false                            |\n| Calculator     | calc_hydrogen_bond_network       |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | potential                     | bump_potential_charges                           |\n |    | hydrogen_bond_network         | generate_hydrogen_bond_network                   |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/hydrogen-bonds/#ProtoSyn.Calculators.HydrogenBonds.fixate_hydrogen_bond_network!","page":"Hydrogen Bonds","title":"ProtoSyn.Calculators.HydrogenBonds.fixate_hydrogen_bond_network!","text":"fixate_hydrogen_bond_network!(efc::EnergyFunctionComponent, pose::Pose)\n\nIf the given EnergyFunctionComponent efc is an Hydrogen Bonds EnergyFunctionComponent (and the :hydrogen_bond_network setting is a Function), calculate a new HydrogenBondNetwork and apply it as a static list of interaction Atom instances (improved performance).\n\nSee also\n\nget_default_hydrogen_bond_network\n\nExamples\n\njulia> ProtoSyn.Calculators.HydrogenBonds.fixate_hydrogen_bond_network!(efc, pose)\nDonors: 131 | Acceptors: 104\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"CurrentModule = ProtoSyn.Calculators","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#calculators-potential-restraints","page":"Potential Restraints","title":"Potential restraints","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Potential restraints are a family of EnergyFunctionComponent instances that apply any given potential to a selection of Atom instances, optionally further masked or mapped. In other words, the application of a potential restraint to a Pose is characterized by a series of fully customizable steps to generate new and/or improved Potential restraints:","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"(Optional) Select a subset of Atom instances to apply the potential;\nDefine the potential function to be applied (See Available potentials);\nApply the potential mask to the selected Atom instances;\n(Optional) Multiply a mask/map to the calculated energy and forces matrices;\nSum the calculated energy and forces matrices.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"ukw: Note:\nMost of these EnergyFunctionComponent instances are specific for a certain type of molecules (such as Peptides). The following types and methods constitute the backbone for all Potential restraints, but more specific applications can be found in other modules of ProtoSyn.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"(Image: ProtoSyn Potential Restraint)","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Figure 1 | A diagram representation of the application of a potential restraint, in ProtoSyn. A given potential function (See Available potentials) is applied to a distance matrix (See Distance matrix calculation) calculated from the distances between all selected Atom instances. The resulting 2D energy matrix includes the energy values for each pair of interacting Atom instances. An optional secondary output from the application of the potential function is a 3D forces matrix, with the forces felt on each atom from the interaction with its pair. Both these matrices can optionally suffer another step: the application of a mask or map. On one hand, a Mask, similarly to its application in AbstractSelections, turns on and off certain pairs of interacting atoms. As an example, a mask allows the user to ignore same-atom energy artifacts using a get_diagonal_mask or ignore interaction between atoms of the same residue using an get_intra_residue_mask. On the other hand, a map in a 2D matrix (with the same size as the 2D energy matrix) with weights and biases. When the two matrices are multiplied together, certain interaction strengths are increased while others are reduced. An example would be the application of a contact map, where each weight corresponds to the certainty factor for the distance between each of the considered Atom pairs. As a final step both the 2D energy matrix and the 3D forces matrix (optionally after the application of the mask/map) are summed (in both axis, in the case of energy calculation, and in one axis, in the case of forces calculation).","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"ukw: Note:\nThe above paradigm for application of potential restraints requires, for the correct calculation of forces, the full_distance_matrix to be considered. This causes the energy value calculated to be double the expected (not considering the application on any non diagonally symmetrical mask), as both the top and bottom triagonal matrices are considered. In most cases this is not an issue, as the energy values are compared between simulation frames in relation to eachother and therefore the scale of the value is not important. However, in specific applications, further adjustment of the potential and/or mask applied may be necessary.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"The following section is subdivided in the following topics, for organizational purposes:","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Base methods\nAvailable potentials\nCreating custom potential functions\nAvailable masks\nCreating custom masks\nAvailable Potential Restraint EnergyFunctionComponents","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#Base-methods","page":"Potential Restraints","title":"Base methods","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"The following methods are ubiquous to all Potential restraints:","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"ProtoSyn.Calculators.apply_potential!","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.apply_potential!","page":"Potential Restraints","title":"ProtoSyn.Calculators.apply_potential!","text":"apply_potential!([A::Type{<: ProtoSyn.AbstractAccelerationType}], pose::Pose, potential::Function, update_forces::Bool, [verlet_list::Union{VerletList, Nothing}], [selection::Union{Nothing, ProtoSyn.AbstractSelection}], [mask::MaskMap])\n\nApply the given potential to the provided Pose pose. If the update_forces flag is set to true, also calculate the forces acting on the system. The call to this function can be further customized by providing an optional VerletList, an AbstractSelection selection or a MaskMap map (this can be a Mask, a Matrix or a Function).\n\nExamples\n\njulia> ProtoSyn.Calculators.apply_potential!(ProtoSyn.SISD_0, pose, (d; kwargs...) -> 0.0, false, nothing, nothing, nothing)\n(0.0, [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0])\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#Available-potentials","page":"Potential Restraints","title":"Available potentials","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"A list of available potentials in ProtoSyn is described bellow. See Creating custom potential functions for the required signature of new potential functions.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"get_flat_bottom_potential\nget_coulomb_potential\nget_bump_potential\nget_harmonic_potential","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Calculators.get_flat_bottom_potential\nCalculators.get_coulomb_potential\nCalculators.get_bump_potential\nCalculators.get_bump_potential_charges\nCalculators.get_harmonic_potential","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_flat_bottom_potential","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_flat_bottom_potential","text":"get_flat_bottom_potential(;d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf) where {T <: AbstractFloat}\n\nReturn a flat-bottom potential function, using the specified distances. The potential is made up of 5 different sectors, each with the following functions:\n\nf_1)  e = m_1 cdot d + b_1  left  d  d_1 right \n\nf_2)  e = left (d-d_2  right )^2  left  d_1 leqslant d  d_2 right \n\nf_3)  e = 0  left  d_2 leqslant d leqslant d_3 right \n\nf_4)  e = left (d-d_3  right )^2  left  d_4  d leqslant d_4 right \n\nf_5)  e = m_2 cdot d + b_2   left  d  d_4 right \n\nWhere \n\nm_1 = 2 left ( d_1-d_2 right ) \n\nb_1 = f_2left ( d_1 right ) - m_1 cdot d_1 \n\nm_2 = 2left ( d_4 - d_3 right ) \n\nb_2 = f_4left ( d_4 right ) - m_2 cdot d_4 \n\nThe resulting function can be called with the following signature:\n\nflat_bottom_potential(d::T; v::Opt{Vector{T}} = nothing) where {T <: AbstractFloat}\n\nReturn an energy value based on the provided distance d. If a vector v is also provided (optional), the flat-bottom restraint will also return the forces f1 and f2 (the forces felt on both ends of the vector v). The vector v should have length = 3, corresponding to the 3 dimensions of the distance between the two Atom instances (X, Y and Z). For more information on the flat-bottom potential, please read: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4692055/. \n\nSee also\n\napply_potential! calc_flat_bottom_restraint\n\nExamples\n\njulia> f = ProtoSyn.Calculators.get_flat_bottom_potential(d1 = 1.0, d2 = 2.0, d3 = 3.0, d4 = 4.0);\n\njulia> f(2.5)\n0.0\n\njulia> f(1.73, v = (1.0, 1.0, 1.0))\n(0.0729, (0.54, 0.54, 0.54), (-0.54, -0.54, -0.54))\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_coulomb_potential","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_coulomb_potential","text":"get_coulomb_potential(d::T; v::Opt{Tuple{T, T, T}} = nothing, kwargs...) where {T <: AbstractFloat}\n\nReturn a simple coulomb potential with charges included, as described in https://www.softschools.com/formulas/physics/potentialenergyelectrostaticpointparticles_formula/37/. The coulomb potential is measured between two charged point-like particles at distance d and charges kwargs[:qi] and kwargs[:qj], respectivelly. If a vector v between the two particles is provided, also calculates the resulting forces.\n\nSee also\n\nget_bump_potential\n\nExamples\n\njulia> coulomb = ProtoSyn.Calculators.get_coulomb_potential()\n\njulia> coulomb(2.0, qi = 1.0, qj = -1.0)\n-0.5\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_bump_potential","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_bump_potential","text":"get_bump_potential(;[c::T = 1.0], [r::T = 1.0]) where {T <: AbstractFloat}\n\nReturn a bump potential without charges included, as described in https://math.stackexchange.com/a/3236066. The bump function is centered around c with a radius r.\n\nSee also\n\nget_bump_potential_charges\n\nExamples\n\njulia> ProtoSyn.Calculators.get_bump_potential(c = 1.0, r = 1.0)\n(::ProtoSyn.Calculators.var\"#bump_potential#25\"{ProtoSyn.Calculators.var\"#bump_potential#24#26\"{Float64, Float64, Float64}}) (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_bump_potential_charges","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_bump_potential_charges","text":"get_bump_potential_charges(;[c::T = 1.0], [r::T = 1.0]) where {T <: AbstractFloat}\n\nReturn a bump potential with charges included, as described in https://math.stackexchange.com/a/3236066. The bump function is centered around c with a radius r.\n\nSee also\n\nget_bump_potential\n\nExamples\n\njulia> ProtoSyn.Calculators.get_bump_potential_charges(c = 1.0, r = 1.0)\n(::ProtoSyn.Calculators.var\"#bump_potential_charges#21\"{ProtoSyn.Calculators.var\"#bump_potential_charges#20#22\"{Float64, Float64}}) (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_harmonic_potential","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_harmonic_potential","text":"get_harmonic_potential(a::T, b::T, c::T) where {T <: AbstractFloat}\n\nReturn a simple harmonic potential with the following equation:\n\nU = ((d+a)²-b)*c\n\nThe harmonic potential is measured between two point-like particles at distance d (doesn't take charges into consideration). If a vector v between the two particles is provided, also calculates the resulting forces.\n\nSee also\n\nget_bump_potential\n\nExamples\n\njulia> harmonic = ProtoSyn.Calculators.get_harmonic_potential(1.0, 1.0, 1.0)\n\njulia> harmonic(1.0)\n3.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"(Image: ProtoSyn Flat Bottom Potential)","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Figure 1 | Visual depiction of the various potentials made available with ProtoSyn (version 1.1).","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#Creating-custom-potential-functions","page":"Potential Restraints","title":"Creating custom potential functions","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Besides the currently Available potentials, users can freely create custom and/or improved potential functions. In order to incorporate these potentials in EnergyFunctionComponent instances (and therefore in EnergyFunction instances), the following signature must be followed.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"energy, force1, force2 = new_potential(d::T; v::Opt{Tuple{T, T, T}} = nothing, kwargs...) where {T <: AbstractFloat}","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Any function must, therefore, receive a distance value d::T between two Atom instances and return the corresponding energy felt. Optionally, it may receive a vector v::Vector{T}, which is the difference vector between the two Atom positions, in which case the potential should also return the two forces felt on each atom from this energetic interaction. The kwargs may contain extra information from the apply_potential! function. Currently, only the Atom charges are provided, with entries qi and qj. This may change in future versions of ProtoSyn.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"The newly defined method can then be used in the apply_potential! function: for each pair of Atom instances in the full_distance_matrix this potential will be evaluated. The apply_potential! (with the new potential) can then be used in a new :calc field of any new EnergyFunctionComponent (with the correct signature, see Creating a custom EnergyFunctionComponent). However, as a general rule of good practice, an extra step is usually included: as exemplified by the get_flat_bottom_potential method, the potential here is actually a functor, returned everytime the get_flat_bottom_potential function is called. A set of settings act as the input of this function (the settings of the encompassing EnergyFunctionComponent), parametrizing the returned potential. Using this approach, the user has complete access to the EnergyFunctionComponent.settings field, which will dictate the parametrization of the newly developed potential. This can be useful, for example, in efforts to correctly parametrize an energetic contribution based on a set of data, as the used potential settings can be changed and optimized each step of the simulation, as a new potential is generated everytime. However, this generation should not negatively impact performance in any meaningfull way. ","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#Available-masks","page":"Potential Restraints","title":"Available masks","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"A list of available masks/maps in ProtoSyn is described bellow. See Creating custom masks for the required signature of new potential function masks/maps, and consider using ProtoSyn.Calculators.show_available_masks method to list all available masks.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"ProtoSyn.Calculators.show_available_masks\nCalculators.get_intra_residue_mask\nCalculators.get_bonded_mask\nCalculators.get_diagonal_mask\nCalculators.get_upper_triangular_matrix_mask\nCalculators.get_upper_triangular_matrix_inversed_mask\nCalculators.load_map","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.show_available_masks","page":"Potential Restraints","title":"ProtoSyn.Calculators.show_available_masks","text":"show_available_masks([io::IO], [m::Module])\n\nPrints all available masks for potential restraints Module m (defaults to ProtoSyn.Calculators) to the given IO io (defaults to stdout). Recursivelly searches any inner Module.\n\nExamples\n\njulia> ProtoSyn.Calculators.show_available_masks()\n+-------------------------------------------------------+\n| Index | Mask function                                 |\n+-------------------------------------------------------+\n| 1     | get_bonded_mask                               |\n| 2     | get_diagonal_mask                             |\n+-------------------------------------------------------+\n  └── Consider using the `?` menu to learn more about each mask function.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_intra_residue_mask","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_intra_residue_mask","text":"get_intra_residue_mask(pose::Pose, [selection::Opt{AbstractSelection}])\n\nFor all the Atom instances in the provided AbstractSelection selection (N), return a 2D N x N Mask with all the Atom instances of the given Pose pose not in the same residue selected. \n\nukw: Note:\nThis function is rather heavy and has low performance. If no design effort is being made (where the sequence changes), the resulting Mask from this function can and should be re-used (only calculated once). If, for a specific application, the AbstractSelection selection remains constant but the Mask needs to be re-calculated (for example, because there was a design/mutation step, use the functor resulting from get_intra_residue_mask).\n\nSee also\n\nshow_available_masks\n\nExamples\n\njulia> ProtoSyn.Calculators.get_intra_residue_mask(pose, !an\"^CA$|^N$|^C$|^H$|^O$\"r)\nProtoSyn.Mask\n ├── Type: Atom\n ├── Size: (1140, 1140)\n ├── Count: 1279946 / 1299600\n └── Content: [0 0 … 1 1; 0 0 … 1 1; … ; 1 1 … 0 0; 1 1 … 0 0]\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_bonded_mask","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_bonded_mask","text":"get_bonded_mask(pose::Pose, [selection::Opt{AbstractSelection}])\n\nFor all the atoms in the provided AbstractSelection selection (N), return a 2D N x N Mask: for each Atom instance of the given Pose pose mask out all other bonded Atom instance.\n\nSee also\n\nshow_available_masks\n\nExamples\n\njulia> ProtoSyn.Calculators.get_bonded_mask(pose, an\"CA\")\nProtoSyn.Mask\n ├── Type: Atom\n ├── Size: (73, 73)\n ├── Count: 5256 / 5329\n └── Content: [0 1 … 1 1; 1 0 … 1 1; … ; 1 1 … 0 1; 1 1 … 1 0]\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_diagonal_mask","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_diagonal_mask","text":"get_diagonal_mask(pose::Pose, [selection::Opt{AbstractSelection}])\n\nFor all the atoms in the provided AbstractSelection selection (N), return a 2D N x N Mask with all the Atom instances of the given Pose pose not in the natural diagonal selected (i.e. ignores same Atom interaction artifacts).\n\nSee also\n\nshow_available_masks\n\nExamples\n\njulia> ProtoSyn.Calculators.get_diagonal_mask(pose, an\"CA\")\nProtoSyn.Mask\n ├── Type: Atom\n ├── Size: (73, 73)\n ├── Count: 5256 / 5329\n └── Content: [0 1 … 1 1; 1 0 … 1 1; … ; 1 1 … 0 1; 1 1 … 1 0]\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_upper_triangular_matrix_mask","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_upper_triangular_matrix_mask","text":"get_upper_triangular_matrix_mask(pose::Pose, [selection::Opt{AbstractSelection}])\n\nFor all the atoms in the provided AbstractSelection selection (N), return a 2D N x N Matrix{T} with the bottom triangular matrix set to 0.0 (including diagonal) and upper triangular matrix set to 1.0.\n\nSee also\n\nshow_available_masks\n\nExamples\n\njulia> ProtoSyn.Calculators.get_upper_triangular_matrix_mask(pose, an\"CA\")\n73×73 Matrix{Float64}:\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_upper_triangular_matrix_inversed_mask","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_upper_triangular_matrix_inversed_mask","text":"get_upper_triangular_matrix_mask(pose::Pose, [selection::Opt{AbstractSelection}])\n\nFor all the atoms in the provided AbstractSelection selection (N), return a 2D N x N Matrix{T} with the bottom triangular matrix set to 0.0 (including diagonal) and upper triangular matrix set to -1.0.\n\nSee also\n\nshow_available_masks\n\nExamples\n\njulia> ProtoSyn.Calculators.get_upper_triangular_matrix_inversed_mask(pose, an\"CA\")\n73×73 Matrix{Float64}:\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.load_map","page":"Potential Restraints","title":"ProtoSyn.Calculators.load_map","text":"load_map([::Type{T}], filename::String) where {T <: AbstractFloat}\n\nLoad the map in the filename file (i.e. Contact Map). The file should be in PFRMAT RR format (See: https://predictioncenter.org/casp13/index.cgi?page=format#RR). Returns an N x N map of the found weights, with pairs not identified in the file set to 0.0 (N is the maximum indentifier found on the file. As an example, it might be the case where a peptide has 74 residues, but no pair with residue 74 is found on the file, the maximum identifier found might be 72, for example. In this case, the resulting map will have size 72 x 72. In order to ensure the loaded map size matches the underlying peptide size, consider adding an entry of 0.0 on the map file, with the correct maximum identifier). Note: If no optional type T is provided, will use ProtoSyn.Units.defaultFloat.\n\nExamples\n\njulia> cmap = ProtoSyn.Calculators.load_map(\"contact_map_example.txt\")\n73×73 Array{Float64,2}:\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"(Image: ProtoSyn Available Masks)","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Figure 2 | Some of the available Mask instances in ProtoSyn. A get_intra_residue_mask de-selects all atoms that belong to the same Residue instance (only accounting for inter-Residue interactions). A get_diagonal_mask simply de-selects the same Atom instance in a 2D full_distance_matrix. Finally, a contact map is a loaded map (using the load_map method) that asserts a 2D Matrix of weights or biases to be multiplied by the resulting energy and forces matrices in apply_potential!. As an example, this can be the likelihood of two Atom instances having a distance shorter can D Angstrom (Å).","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#Creating-custom-masks","page":"Potential Restraints","title":"Creating custom masks","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"In addition to the Available masks, users may wish to create and add custom Mask instances to employ in the apply_potential! method. This method can receive a 2D Mask instance directly, as well as a Matrix{T} or a Function instance. Each case is discussed bellow:","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"2D Mask : A static mask, calculated only once. Energy and forces contributions will only be considered for the selected Atom instances (make sure the size of the Mask matches the number of selected Atom instances in the apply_potential! call). As an example, see get_intra_residue_mask. The syntax to create a new ProtoSyn Mask is as follows. For more details, see the Masks section.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"2d_mask = Mask{Atom}(BitArray(falses(4, 4)))","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"MatrixT : A static map, calculated only once. Energy and forces contibutions will be multiplied by the Matrix{T} (make sure that the Matrix{T} size matches the number of selected Atom instances in the apply_potential! call). As an example, see load_map. The syntax to create a new Matrix{T} is as follows (as an example of a random map).","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"2d_map = rand(4, 4)","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Function : A dynamic mask or map, calculated every step/call of apply_potential!. This function should have the following simple signature, receiving a Pose pose as input and returning either a Mask or a Matrix{T}.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"mask_or_map(pose::Pose)","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Altough potentially sacrificing the performance of the code, this allows for new Mask or a Matrix{T} instances to be calculated every step of a simulation, reflecting new changes, such as mutations or design efforts, for example.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"ukw: Note:\nA common practice in building new Function instances that return Mask or a Matrix{T} instances for application in the apply_potential! method is to encompass this Function as a functor of another Function. As an example, see the get_intra_residue_mask method. In this cases, the encompassing Function receives the AbstractSelection selection, making sure that the returned Function selects Atom instances only within this selection.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"When a dynamic mask or map is used, performance penalties are to be expected. If a user whises to fixate a dynamic mask into a static mask (on the context of an EnergyFunctionComponent or EnergyFunction), the following companion methods are made available:","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"ProtoSyn.Calculators.fixate_mask!\nProtoSyn.Calculators.fixate_masks!","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"CurrentModule = ProtoSyn.Calculators","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#Available-Potential-Restraint-EnergyFunctionComponents","page":"Potential Restraints","title":"Available Potential Restraint EnergyFunctionComponents","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Making use of all the above, the following default EnergyFunctionComponent instances are defined and made available:","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Calculators.Restraints.calc_flat_bottom_restraint\nCalculators.Restraints.get_default_all_atom_clash_restraint","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint","page":"Potential Restraints","title":"ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint","text":"calc_flat_bottom_restraint([::Type{A}], pose::Pose, update_forces::Bool; d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf, selection::Opt{AbstractSelection} = nothing, mask::MaskMap = nothing) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat}\n\nApply a flat bottom potential to a given Pose pose. The potential is iteratively obtained each call using the get_flat_bottom_potential method (See Available potentials), by providing the given d1::T (default: 0.0), d2::T (default = 0.0), d3::T (default = Inf) and d4::T (default = Inf) settings as the flat bottom potential distances. This potential then applied to the Pose pose (via the apply_potential! method), optionally on a subset of Atom instances given by the AbstractSelection selection and optionally multiplied by a mask. This mask can be a Mask, a Matrix{T} or a Function, in which case it should be a functor (return a Function) (For the correct signature of this Function mask, see Creating custom masks). These 3 options are named MaskMap for a simplicity of organization only. Return the total energy of the system and matrix of forces felt on each atom. Note that the calculation acceleration type can be set by providing an option parameter A Type{<: ProtoSyn.AbstractAccelerationType}. If not provided, the default ProtoSyn.acceleration.active will be used instead.\n\ncalc_flat_bottom_restraint!([::Type{A}], pose::Pose, update_forces::Bool; d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf, selection::Opt{AbstractSelection} = nothing, mask::MaskMap = nothing) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat}\n\nApply a flat bottom potential to a given Pose pose (see above). Also apply any energy and forces changes directly to the Pose pose.\n\nExamples\n\njulia> ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint(pose, true)\n(0.0, [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0])\n\njulia> ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint(pose, false, d1 = 10.0, d2 = 12.0)\n(556449.1936070402, [-711.7603616347209 -630.2662235401388 … 995.0284325254745 1153.572133762037; -419.1275359380875 -548.0506257124055 … 286.5285847489888 92.16862928705675; 6.007398880372552 8.2409631821887 … -99.38257889245355 -92.37110004070036])    ```\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.Restraints.get_default_all_atom_clash_restraint","page":"Potential Restraints","title":"ProtoSyn.Calculators.Restraints.get_default_all_atom_clash_restraint","text":"get_default_all_atom_clash_restraint(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the all-atom clash EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). This component employs the calc_flat_bottom_restraint method, therefore defining a Pose energy based on a flat-bottom potential function applied to all atom-pairs in the system (N² complexity). By default, this EnergyFunctionComponent potential sets :d1 and :d2 of the flat-bottom potential to be 1.0 and 2.0, and masks out bonded atom-pairs.\n\nSee also\n\nget_default_bond_distance_restraint\n\nSettings\n\nd1::T - The :d1 distance in the flat-bottom potential;\nd2::T - The :d2 distance in the flat-bottom potential;\nd3::T - The :d3 distance in the flat-bottom potential;\nd4::T - The :d4 distance in the flat-bottom potential;\nmask::MaskMap - The Mask, Matrix{T} or Function (see Creating custom masks) that masks out our multiplied by a set of pre-defined Atom instances;\n\nExamples\n\njulia> ProtoSyn.Calculators.Restraints.get_default_all_atom_clash_restraint()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | All_Atom_Clash_Rest              |\n| Alpha (α)      | 1.0                              |\n| Update forces  | true                             |\n| Calculator     | calc_flat_bottom_restraint       |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | d4                            | Inf                                              |\n |    | d2                            | 2.0                                              |\n |    | mask                          | get_bonded_mask                                  |\n |    | d1                            | 1.0                                              |\n |    | d3                            | Inf                                              |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/state/","page":"State","title":"State","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/methods/state/#peptides-state-methods","page":"State","title":"State","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/state/","page":"State","title":"State","text":"This section lists functions that work on the system State, as expansions to the Core methods (See State). Making use of the Secondary Structure types (in specific, the SecondaryStructureTemplate instance), the setss! method allows a user to quickly apply a given Secondary Structure to a Pose or a subset of selected Residue instances.","category":"page"},{"location":"protosyn-api/peptides/methods/state/","page":"State","title":"State","text":"setss!\nread_ss_map\ncategorize_ss_from_dihedral_angles","category":"page"},{"location":"protosyn-api/peptides/methods/state/#ProtoSyn.Peptides.setss!","page":"State","title":"ProtoSyn.Peptides.setss!","text":"setss!(state::State, ss::SecondaryStructureTemplate{T}, residues::Vector{Residue}; [include_variation::Bool = false], [min_prob::T = 0.0]) where {T <: AbstractFloat}\n\nSet the phi ϕ, psi ψ and omega ω backbone angles of all Residue instances in the given residues vector to match the provided SecondaryStructureTemplate. This function acts on the internal coordinates and does not update cartesian coordinates (using the sync! method), although a request for conversion is made (by calling the request_i2c!). If include_variation is set to true (false, by default), the phi ϕ, psi ψ and omega ω backbone angles are sampled from each distribution, instead of using the ideal angle. min_prob defines the minimum probability of the sampled angle (from 0.0 to 1.0). Using higher min_prob values results in variations conformationally closer to the ideal dihedral angle values.\n\nsetss!(pose::Pose, ss::SecondaryStructureTemplate; [include_variation::Bool = false], [min_prob::T = 0.0])\nsetss!(pose::Pose, ss::SecondaryStructureTemplate, sele::ProtoSyn.AbstractSelection; [include_variation::Bool = false], [min_prob::T = 0.0])\nsetss!(pose::Pose, ss::SecondaryStructureTemplate, residue::Residue; [include_variation::Bool = false], [min_prob::T = 0.0])\n\nSet the phi ϕ, psi ψ and omega ω backbone angles of all Residue instances in the given Pose pose to match the provided SecondaryStructureTemplate. If an optional AbstractSelection sele is provided, apply the transformation only to the selected Residue instances. Optionally, a single Residue instance can also be provided: any changes will only apply to the selected Residue instance.\n\nSee also\n\nSecondaryStructure\n\nExamples\n\njulia> ProtoSyn.Peptides.setss!(pose, ProtoSyn.Peptides.SecondaryStructure[:helix])\nState{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/state/#ProtoSyn.Peptides.read_ss_map","page":"State","title":"ProtoSyn.Peptides.read_ss_map","text":"read_ss_map(pose::Pose, filename::String, ss_type::String)\n\nReads a SecondaryStructure map from filename into an AbstractSelection of Residue instances marked with the desired ss_type in the map. The map is checked against the given Pose for compatibility (number of Residue instances, etc). The expected map format follows the DeepConCNF_SS3 format (3-mode categorization), as given by RaptorX prediction server.\n\nExamples\n\njulia> ProtoSyn.Peptides.read_ss_map(\"ss_map.txt\", \"H\")\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/state/#ProtoSyn.Peptides.categorize_ss_from_dihedral_angles","page":"State","title":"ProtoSyn.Peptides.categorize_ss_from_dihedral_angles","text":"categorize_ss_from_dihedral_angles(pose::Pose, [selection::Opt{ProtoSyn.AbstractSelection} = nothing]; [blur_amount::T = 0.5]) where {T <: AbstractFloat}\n\nThis method attempts to categorize the given Pose pose Residue instances in a 3-mode categorization format: \"H\" for helix, \"E\" for beta sheets and \"C\" for coils. The categorization takes into account:\n\nGeometrical criteria: accordance of the current phi ϕ, psi ψ and omega ω backbone angles to known potentials. Make sure the Pose pose is synched (see sync!);\nHydrogen bonding pattern: counts hydrogen bonds using generate_hydrogen_bond_network. Make sure the Pose pose has charges (see assign_default_charges!);\nFlanking Residue secondary structure: flanking Residue's secondary structure \"spills\" over and influences neighboring Residue instances. The influence amount can be set with blur_amount (0.5, by default);\nTerminal Residue instances: Terminal Residue instances tend to adopt coil conformations. \n\nukw: Note:\nIn ProtoSyn 1.1, this method offers notoriously sub-par predictions. Using external tools such as DSSP or RaptorX secondary structure prediction server is recommended.\n\nExamples\n\njulia> ProtoSyn.Peptides.categorize_ss_from_dihedral_angles(pose)\n\"CHHHHHHHHHHHHHHHHHHHCCCHHHHHHHHHHHHHHHHHHHHHHCCCHHHHHHHHHHHHHHHHHHHHHHHHC\"\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#peptides-pose-methods","page":"Pose","title":"Pose","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Included in the Peptides are a set of methods who primarily act on a Pose instance, expanding on the list of availabe Core functions (See Pose methods). These are subdivided by topics, for organization purposes:","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Appending and inserting fragments\nMutating an aminoacid\nRemoving and adding sidechains\nRemoving and adding N- and C- terminal caps\nDiagnosing poses","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#Appending-and-inserting-fragments","page":"Pose","title":"Appending and inserting fragments","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Expanding on the homologous Core functions, the next methods allow the user to append and insert Fragment instances in Pose instances (from Fragment instances or from a derivation (for example, seq\"AAA\", a triplet of alanine aminoacids)). These expanded methods all add the possibility to set the Secondary Structure of the appendage (using the setss! method) and correct certain bond orientation artifacts introduced by the Core functions, specific to peptidic structures.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"append_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Pose{Segment}; ::Opt{SecondaryStructureTemplate}, ::Any)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.append_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Fragment}","page":"Pose","title":"ProtoSyn.Peptides.append_fragment!","text":"append_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, frag::Pose{Segment}; [ss::Opt{SecondaryStructureTemplate} = nothing], [op = \"α\"])\n\nAdd the Fragment frag to the given Pose pose, appending it after the given Residue residue. This residue and the new Fragment frag will be connected using operation op (\"α\" by default) of the given LGrammar grammar. If given, a SecondaryStructureTemplate ss can be applied to the new appendage (using the setss! method). In either case, the C=O bond position is re-calculated and set (in the first residue of the appendage). Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nukw: Note:\nThis function is an extension of ProtoSyn.append_fragment!.\n\nSee also\n\ninsert_fragment!\n\nExamples\n\njulia> ProtoSyn.Peptides.append_fragment!(pose, pose.graph[1][end], res_lib, frag)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn Peptides Append)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Figure 1 | Two example applications of the append_fragment! method. 1 - Appending a new Fragment (which can be one or more aminoacids) to the end of a peptidic structure (the Fragment is displayed in dark grey). The Residue instances are re-indexed (using the reindex! method) and inserted in the Pose graph (sharing the root). 2 - A Fragment can also be appended to a severed cut (using the unbond! method or the fragment! method, for example). In this case, naturally, the downstream Residue instances are connected to the Pose root. Note that the appended aminoacids are ordered in such a way as to continue numerate (on index) from the Residue instance appended to.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"insert_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Pose{Segment}; ::Opt{SecondaryStructureTemplate}, ::Any)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.insert_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Fragment}","page":"Pose","title":"ProtoSyn.Peptides.insert_fragment!","text":"insert_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, frag::Pose{Segment}; ss::Opt{SecondaryStructureTemplate} = nothing, op = \"α\")\n\nInsert the Fragment frag in the given pose, on the position of the provided Residue instance residue (the residue gets shifted downstream). This first downstream Residue and the new Fragment will be connected using operation op (\"α\" by default) from [LGrammar] grammar. Also connects to the upstream Residue instance, using the same operation. If given, a SecondaryStructureTemplate ss can be applied to the new appendage (using the setss! method). If the appendage is not being inserted at the root, the C=O bond position is re-calculated and set (in the anchor for the first residue of the appendage). If the appendage is being inserted at the root, perform a soft uncap of the terminal hydrogen atoms (removes \"H2\" and \"H3\", leaves \"H1\", renames it to \"H\") and recalculate the N-H bond position (at the first downstream Residue). Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nukw: Note:\nThis function is an extension of ProtoSyn.insert_fragment!.\n\nSee also\n\nappend_fragment!\n\nExamples\n\njulia> ProtoSyn.Peptides.insert_fragment!(pose, pose.graph[1][1], res_lib, frag)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn Peptides Insert)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Figure 2 | Two example applications of the insert_fragment! method. 1 - Inserting a new Fragment (which can be one or more aminoacids) to the middle of a peptidic structure (the Fragment is displayed in dark grey). The Residue instances are re-indexed (using the reindex! method) and inserted in the Pose graph (sharing the root), while being connected in both upstream and downstream ends. 2 - A Fragment can also be inserted at position 1 of the peptidic chain (in the beginning).","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#Mutating-an-aminoacid","page":"Pose","title":"Mutating an aminoacid","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"In a design effort, the objetive is to change the nature of an aminoacid (i.e.: change its sidechain), in order to stabilize a given interaction or conformation. Naturally, the main component necessary in such an algorithm is the ability to mutate an aminoacid, as explored in the next section.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"mutate!\nforce_mutate!","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.mutate!","page":"Pose","title":"ProtoSyn.Peptides.mutate!","text":"mutate!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation)\n\nMutate the given Pose pose at Residue residue, changing it's aminoacid to be derivation, as given by the template at grammar. This function changes the sidechain only (± 7x faster than force_mutate!). When mutating to Proline, falls back to force_mutate!. If ignore_existing_sidechain is set to true (false by default), existing sidechains are first removed and then re-added, regardless of being of the same type (which normally are ignored, if no mutation is required).\n\nmutate!(pose::Pose{Topology}, sele::AbstractSelection, grammar::LGrammar, derivation)\n\nMutate the given Pose pose at Residue residue selected by the AbstractSelection sele. Note that this selection can only return a single aminoacid at a time.\n\nukw: Note:\nSidechains are selected based on the Atom.name (backbone Atom instances must be named N, H, CA, C and O, exclusively. Non backbone Atom instances should have other names, such as HB1, HB2, etc.) This function attempts to keep terminal caps intact (doesn't remove any atom named H1, H2, etc or OXT).\n\nSee also\n\nforce_mutate!\n\nExamples\n\njulia> ProtoSyn.Peptides.mutate!(pose, pose.graph[1][3], res_lib, seq\"K\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 354\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.force_mutate!","page":"Pose","title":"ProtoSyn.Peptides.force_mutate!","text":"force_mutate!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation, op = \"α\")\n\nMutate the given Pose pose at Residue residue, changing it's aminoacid to be derivation, as given by the template at grammar. This function changes the whole residue (backbone included). By default, the user should use mutate! instead of this function, except for uncommon aminoacids.\n\nSee also mutate!\n\nExamples\n\njulia> ProtoSyn.Peptides.force_mutate!(pose, pose.graph[1][3], res_lib, seq\"K\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 354\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn Mutate)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Figure 3 | Example of an aminoacid mutation cycle.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#Removing-and-adding-sidechains","page":"Pose","title":"Removing and adding sidechains","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Certain coarse-grain EnergyFunctionComponent instances might not require an explicit sidechain. In certain algorithms, it might be, therefore, useful to remove the sidechains, lowering the degrees of freedom of a system and reducing the amount of particles simulated. In the next section, the methods used in ProtoSyn to remove and add sidechains in peptidic systems are explored.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"remove_sidechains!\nforce_remove_sidechains!\nadd_sidechains!","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.remove_sidechains!","page":"Pose","title":"ProtoSyn.Peptides.remove_sidechains!","text":"remove_sidechains!(pose::Pose{Topology}, res_lib::LGrammar, Opt{AbstractSelection} = nothing)\n\nRemoves the sidechain atoms of the given Pose pose. If an AbstractSelection selection is provided, only the sidechain atoms belonging to the Residue instances of that selection are considered for possible removal. Essentially, the selected Residue instances are mutated to Glycine, based on the provided residue library res_lib, without changing the peptide sequence. Therefore, the original sequence can be recovered using the add_sidechains! method and energy components such as neighbour_vector can perform correctly.\n\nukw: Note:\nProline residues are ignored.\n\nukw: Note:\nCaping Atom instances (N-terminal -NH3 and C-terminal -CO2) are also removed by this function. See cap! to recover from this.\n\nSee also\n\nforce_remove_sidechains!\n\nExamples\n\njulia> ProtoSyn.Peptides.remove_sidechains!(pose, res_lib)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 147\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.Peptides.remove_sidechains!(pose, res_lib, rn\"ALA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 147\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.force_remove_sidechains!","page":"Pose","title":"ProtoSyn.Peptides.force_remove_sidechains!","text":"force_remove_sidechains!(pose::Pose{Topology}, selection::Opt{AbstractSelection} = nothing)\n\nRemoves the sidechain Atom instances of the given Pose pose. If an AbstractSelection selection is provided, only the sidechain Atom instances belonging to that selection are considered for possible removal. This function completly removes any atom other than backbone atoms (may break Cα coordination, consider using the remove_sidechains! method instead).\n\nukw: Note:\nProline residues are ignored.\n\nukw: Note:\nCaping Atom instances (N-terminal -NH3 and C-terminal -CO2) are also removed by this function. See cap! to recover from this.\n\nSee also\n\nremove_sidechains!\n\nExamples\n\njulia> ProtoSyn.Peptides.force_remove_sidechains!(pose)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 105\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.Peptides.force_remove_sidechains!(pose, rn\"ALA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 105\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.add_sidechains!","page":"Pose","title":"ProtoSyn.Peptides.add_sidechains!","text":"add_sidechains!(pose::Pose{Topology}, grammar::LGrammar, selection::Opt{AbstractSelection} = nothing)\n\nAdd the sidechain Atom instances to the given Pose pose, based on the templates of the provided grammar. If an AbstractSelection selection is given, only the residues of that selection (promoted to Residue instances, using the default aggregator function) are considered for sidechain addition. The addition is performed using the mutate! function, and follows the current Pose sequence.\n\nExamples\n\njulia> ProtoSyn.Peptides.add_sidechains!(pose, res_lib)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.Peptides.add_sidechains!(pose, res_lib, rn\"ALA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn Remove Sidechains)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Figure 4 | Example of application of the remove_sidechains! and [add_sidechains!] methods. Note that, when re-adding the sidechains, the Rotamer conformation is set to be a default position, not recovering the initial conformation without further processing.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#Removing-and-adding-N-and-C-terminal-caps","page":"Pose","title":"Removing and adding N- and C- terminal caps","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"When extending a peptide (by appending new Residue instances, for example), it might be useful to remove the N- and C-terminal caps, as well as add them back at a later point in the algorithm or design process. In this section, two methods for this task are explored.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"is_N_terminal\nis_C_terminal\nidentify_c_terminal\nuncap!\ncap!","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.is_N_terminal","page":"Pose","title":"ProtoSyn.Peptides.is_N_terminal","text":"is_N_terminal(res::Residue)\n\nReturn true if the provided Residue residue is a child of the residue's container root.\n\nExamples\n\njulia> ProtoSyn.Peptides.is_N_terminal(pose.graph[1][1])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.is_C_terminal","page":"Pose","title":"ProtoSyn.Peptides.is_C_terminal","text":"is_C_terminal(res::Residue)\n\nReturn true if the provided Residue residue has no children.\n\nExamples\n\njulia> ProtoSyn.Peptides.is_C_terminal(pose.graph[1][end])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.identify_c_terminal","page":"Pose","title":"ProtoSyn.Peptides.identify_c_terminal","text":"identify_c_terminal(seg::Segment; supress_warn::Bool = false)\n\nAttempts to identify the C terminal of a given Segment seg, using the following criteria:\n\nBonding patter: the C terminal follows the bonding pattern C-C-N-C, there the C-terminal is the first C atom of the pattern.\nBond number: the C terminal must not exceed 3 bonds.\nBy atom name: the C terminal must be bonded to an atom named CA\n\nAs such, this method does not use parenthood relationships to identify the C terminal. If the supress_warn is set to true (false, by default), any generated warnings are ignored.\n\nExamples\n\njulia> ProtoSyn.Peptides.identify_c_terminal(pose.graph[1])\nAtom{/2a3d:40139/A:1/ASN:73/C:1138}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.uncap!","page":"Pose","title":"ProtoSyn.Peptides.uncap!","text":"uncap!(pose::Pose, selection::Opt{AbstractSelection} = nothing)\n\nRemove all bonded Atom instances to the N- and C-terminal (except Cα) of the provided Pose pose. If an AbstractSelections selection is provided, search for terminal residues only in the given selection. A terminal is identified based on the following criteria (see is_N_terminal and is_C_terminal methods):\n\nIs a child of the Pose pose root;\nHas no children;\n\nReturn the modified (in-place) Pose pose. Does not sync!.\n\nExamples\n\njulia> ProtoSyn.Peptides.uncap!(pose)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 341\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.cap!","page":"Pose","title":"ProtoSyn.Peptides.cap!","text":"cap!(pose::Pose, selection::Opt{AbstractSelection} = nothing)\n\nAdd template terminals to the N- and C- terminals of the given Pose pose. If an AbstractSelection selection is provided, search for terminal residues only in the given selection. A terminal is identified based on the following criteria (see is_N_terminal and is_C_terminal methods):\n\nIs a child of the Pose pose root;\nHas no children;\n\nReturn the modified (in-place) Pose pose. Performs sync! operation.\n\nExamples\n\njulia> ProtoSyn.Peptides.cap!(pose)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 346\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn Remove Caps)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Figure 5 | Example of application of the uncap! and [cap!] methods. Uncapping a terminal end of a peptide is usefull when appending new Residue instances, extending or adding an appendage.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#pose-diagnose-peptides","page":"Pose","title":"Diagnosing poses","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"The following methods extend the usage of Diagnosing poses methods (from the Core module) to include Peptides specific standards.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"diagnose","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.diagnose","page":"Pose","title":"ProtoSyn.Peptides.diagnose","text":"diagnose(pose::Pose; [return_issues::Bool = false], [atom_order_search_algorithm::F = Peptides.IUPAC], [res_lib::LGrammar = Peptides.grammar]) where {F <: ProtoSyn.SearchAlgorithm}\n\nMeasure several agreement criteria on the given Pose pose:\n\nAll diagnostics from ProtoSyn.diagnose, except using the given atom_order_search_algorithm (Peptides.IUPAC, by default)\nCheck if Atom and Residue names are in accordance to the templates in the provided [LGrammar] res_lib\nCheck for missing hydrogens (in comparison with the templates in the provided [LGrammar] res_lib)\n\nIf return_issues is set to true (false, by default) doesn't print results to stdout, returns them as a Vector{String} instead.\n\nExamples\n\njulia> ProtoSyn.Peptides.diagnose(pose)\n ⬤   Diagnosing pose 2a3d ...\n |\n ├──  • Residue-level graph OK\n |\n ├──  • Pose indexation OK\n |\n ├──  • Atom-level graph OK\n |\n ├──  • Pose synchronization status (1 issue identified)\n |    └── Pose is requesting internal to cartesian coordinates synchronization. Consider using the sync! function.\n |\n ├──  • Pose charges (1 issue identified)\n |    └── Sum of charges in the pose is not 0.0.\n |\n ├──  • (Peptides only) Residue and atom naming OK\n |\n └──  • (Peptides only) Missing atoms (1 issue identified)\n      └── Pose seems to be missing hydrogens. Suggested fix: Consider using ProtoSyn.add_hydrogens!\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#Other","page":"Pose","title":"Other","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"The following as miscellaneous methods that may help workflows in the Peptides module.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"measure_similarity","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.measure_similarity","page":"Pose","title":"ProtoSyn.Peptides.measure_similarity","text":"measure_similarity(sequence1::String, sequence2::String)\n\nShowcase the total similarity and average similarity of two peptidic sequences according to the ProtoSyn.Peptides.aminoacid_similarity map (this is a mutation tolerance measure map by Stephenson et al. (2013) (see https://link.springer.com/article/10.1007/s00239-013-9565-0)).\n\nExamples\n\njulia> ProtoSyn.Peptides.measure_similarity(ProtoSyn.sequence(pose1), ProtoSyn.sequence(pose2))\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/sasa/","page":"SASA","title":"SASA","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/calculators/sasa/#calculators-sasa","page":"SASA","title":"SASA","text":"","category":"section"},{"location":"protosyn-api/core/calculators/sasa/","page":"SASA","title":"SASA","text":"SASA stands for Solvent Accessible Surface Area and is a measure of the total surface area of a given solute. Multiple approaches have been proposed for the accurate estimation of this property. ProtoSyn, by default, employs the Overlapping Spheres (OLS) algorithm, a variant of the Shrake and Rupley algorithm (for more details, see https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2712621/ and the calc_sasa docstring). This section includes the following topics:","category":"page"},{"location":"protosyn-api/core/calculators/sasa/","page":"SASA","title":"SASA","text":"SASA EnergyFunctionComponent\nSASA solvation EnergyFunctionComponent","category":"page"},{"location":"protosyn-api/core/calculators/sasa/#SASA-EnergyFunctionComponent","page":"SASA","title":"SASA EnergyFunctionComponent","text":"","category":"section"},{"location":"protosyn-api/core/calculators/sasa/","page":"SASA","title":"SASA","text":"The following EnergyFunctionComponent returns an energy value proportional to the system's SASA.","category":"page"},{"location":"protosyn-api/core/calculators/sasa/","page":"SASA","title":"SASA","text":"Calculators.SASA.calc_sasa\nCalculators.SASA.get_default_sasa","category":"page"},{"location":"protosyn-api/core/calculators/sasa/#ProtoSyn.Calculators.SASA.calc_sasa","page":"SASA","title":"ProtoSyn.Calculators.SASA.calc_sasa","text":"calc_sasa([::Type{A}], pose::Pose, [selection::Opt{AbstractSelection} = an\"CA\"], [update_forces::Bool = false]; [probe_radius::T = 1.4], [n_points::Int = 100]) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat}\n\nApproximates the given Pose pose Surface Accessible Surface Area (SASA) using the Overlapping Spheres (OLS) algorithm, a variant of the Shrake and Rupley algorithm (for more details, see https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2712621/). In this algorithm, a sphere of points is generated around each Atom instance (using the fibonacci_sphere method). The spherical distance to the Atom is given by probe_radius (1.4 Å, by default) and the number of points is given by n_points (100, by default). For all other considered Atom instances, points from the generated sphere are removed if they are within probe_radius cut-off. The SASA value is approximated by the number of remaining points in the generated sphere (not within probe_radius of any other Atom instance). If an AbstractSelection selection is provided, the subset of Atom instances considered for the calculation is restricted to the selected atoms (selects atoms named \"CA\", by default; will promote all provided AbstractSelection instances to be of Atom type). This Calculator does not calculate forces. As such, update_forces has no effect and exists only in order to standardize calls between Calculators. An optional parameter Type{<: AbstractAccelerationType} can be provided, stating the acceleration type used to calculate this energetic contribution (See ProtoSyn acceleration types, if not provided defaults to ProtoSyn.acceleration.active). Besides the Pose pose energy and forces (set to nothing on this Calculator), also returns the individually calculated SASA values (for each considered Atom instance) and the cartesian coordinates of all remaining points in each considered Atom sphere.\n\nSee also\n\nget_default_sasa calc_sasa_energy\n\nExamples\n\njulia> ProtoSyn.Calculators.SASA.calc_sasa(pose)\n(36597.0, nothing, [...], [...])\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/sasa/#ProtoSyn.Calculators.SASA.get_default_sasa","page":"SASA","title":"ProtoSyn.Calculators.SASA.get_default_sasa","text":"get_default_sasa(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default SASA EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance, 1.0 by default). This function employs calc_sasa as the :calc function.\n\nSettings\n\nn_points::Int - The number of points to generate in each Atom sphere (higher number of points leads to higher accuracy, at the expense of performance);\nprobe_radius::T - The distance of each point in a generated sphere to the central Atom instance. Any point within probe_radius of any other atom is considered buried Residue name (where T <: AbstractFloat).\n\nSee also\n\ncalc_sasa\n\nExamples\n\njulia> ProtoSyn.Calculators.SASA.get_default_sasa()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | SASA                             |\n| Alpha (α)      | 1.0                              |\n| Update forces  | false                            |\n| Calculator     | calc_sasa                        |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | probe_radius                  | 1.4                                              |\n |    | n_points                      | 100                                              |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/sasa/","page":"SASA","title":"SASA","text":"ukw: Note:\nModern implicit solvation models often employ a hybrid approach, dubbed \"SASA/GB\". In short, the Generalized Born model attempts to estimate the enthalpic contribution of solvating a given molecule, and the SASA model calculates the entropy contribution of \"opening space\" for the solvation of such a molecule. Both models act together to provide a more clear picture of the solvation potential of that system. Consider employing the get_default_sasa EnergyFunctionComponent in conjunction with the get_default_gb EnergyFunctionComponent.","category":"page"},{"location":"protosyn-api/core/calculators/sasa/#SASA-solvation-EnergyFunctionComponent","page":"SASA","title":"SASA solvation EnergyFunctionComponent","text":"","category":"section"},{"location":"protosyn-api/core/calculators/sasa/","page":"SASA","title":"SASA","text":"In contrast with the get_default_sasa EnergyFunctionComponent, the SASA solvation EnergyFunctionComponent attempts to attribute a solvation energy value to each Residue in the system, based on an hydrophobicity map. In sum, exposed hydrophobic Residue instances are penalized while exposed hydrophilic Residue instances are rewarded (and vice-versa for buried Residue instances).","category":"page"},{"location":"protosyn-api/core/calculators/sasa/","page":"SASA","title":"SASA","text":"Calculators.SASA.calc_sasa_energy\nCalculators.SASA.get_default_sasa_energy","category":"page"},{"location":"protosyn-api/core/calculators/sasa/#ProtoSyn.Calculators.SASA.calc_sasa_energy","page":"SASA","title":"ProtoSyn.Calculators.SASA.calc_sasa_energy","text":"calc_sasa_energy([::Type{A}], pose::Pose, [selection::Opt{AbstractSelection} = an\"CA\"], [update_forces::Bool = false]; [probe_radius::T = 1.4], [n_points::Int = 100], [residue_selection::AbstractSelection = TrueSelection{Residue}()], [hydrophobicity_map::Opt{Dict{String, T}} = nothing], [max_sasas::Opt{Dict{String, T}} = nothing], [Ω::T = 0.0]) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat}\n\nApproximates the given Pose pose Surface Accessible Surface Area (SASA) energy using the Overlapping Spheres (OLS) algorithm (See calc_sasa for more information on how SASA is calculated). In this Calculator, the calculated SASA of a Residue (using the n_points sphere at probe_radius from all considered Atom instances) is compared to reference values (max_sasas, define the maximum SASA value of a Residue completly solvated). The average exposure value Ω defines the average ratio of max_sasas that is exposed in a given system. Any SASA value bellow the Ω * maxsasa is considered buried, and vice-versa. This burial/exposure scale is then multiplied by that Residue specific hydrophobiciy index (provided in the `hydrophobicitymap). Hydrophilic/exposed and hydrophobic/buried [Residue](@ref) instances should be rewarded and vice-versa. Since SASA approximation is [Atom](@ref) based, any providedAbstractSelectionselectionlimits the subset of considered [Atom](@ref) instances for SASA calculation. Each [Atom](@ref) individual contribution is summed to the [Residue](@ref) level, only for [Residue](@ref) instances selected byresidueselection. This Calculator does not calculate forces. As such,updateforceshas no effect and exists only in order to standardize calls between Calculators. An optional parameterType{<: AbstractAccelerationType}can be provided, stating the acceleration type used to calculate this energetic contribution (See [ProtoSyn acceleration types](@ref), if not provided defaults toProtoSyn.acceleration.active`).\n\nSee also\n\nget_default_sasa_energy calc_sasa\n\nExamples\n\njulia> ProtoSyn.Calculators.SASA.calc_sasa_energy(pose, hydrophobicity_map = ProtoSyn.Peptides.doolitle_hydrophobicity)\n(-37074.2, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/sasa/#ProtoSyn.Calculators.SASA.get_default_sasa_energy","page":"SASA","title":"ProtoSyn.Calculators.SASA.get_default_sasa_energy","text":"get_default_sasa_energy(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default SASA energy EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance, 1.0 by default). This function employs calc_sasa as the :calc function.\n\nSettings\n\nn_points::Int - The number of points to generate in each Atom sphere (higher number of points leads to higher accuracy, at the expense of performance);\nprobe_radius::T - The distance of each point in a generated sphere to the central Atom instance. Any point within probe_radius of any other atom is considered buried Residue name (where T <: AbstractFloat);\nhydrophobicity_map::Dict{String, T} - A dictionary of hydrophobicity values for each Residue name, positive values indicate hydrophobicity and vice-versa (where T <: AbstractFloat);\nmax_sasas::Dict{String, T} - A dictionary of max_sasa values (SASA values for fully-solvated Residue instances) for each Residue name (where T <: AbstractFloat);\nΩ::T - The average exposure value (between 0.0 and 1.0), any SASA value bellow this percentage of max_sasa is considered buried (where T <: AbstractFloat).\n\nSee also\n\ncalc_sasa_energy\n\nExamples\n\njulia> ProtoSyn.Calculators.SASA.get_default_sasa_energy()\n🞧  Energy Function Component:\n+---------------------------------------------------+\n| Name           | SASA_Solvation                   |\n| Alpha (α)      | 1.0                              |\n| Update forces  | false                            |\n| Calculator     | calc_sasa_energy                 |\n+---------------------------------------------------+\n |    +----------------------------------------------------------------------------------+\n ├──  ● Settings                      | Value                                            |\n |    +----------------------------------------------------------------------------------+\n |    | max_sasas                     | Dict{String, Float64}(0 components)              |\n |    | hydrophobicity_map            | Dict{String, Float64}(22 components)             |\n |    | Ω                             | 0.0                                              |\n |    | probe_radius                  | 1.4                                              |\n |    | n_points                      | 100                                              |\n |    +----------------------------------------------------------------------------------+\n |    \n └──  ○  Selection: nothing\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/mutators/mutators-backrub/","page":"Backrub Mutators","title":"Backrub Mutators","text":"CurrentModule = ProtoSyn.Mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-backrub/#Backrub-Mutator","page":"Backrub Mutators","title":"Backrub Mutator","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-backrub/","page":"Backrub Mutators","title":"Backrub Mutators","text":"A BackrubMutator instance changes a Pose State by introducing random translational movements in the Atom instances.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-backrub/","page":"Backrub Mutators","title":"Backrub Mutators","text":"BackrubMutator","category":"page"},{"location":"protosyn-api/core/mutators/mutators-backrub/#ProtoSyn.Mutators.BackrubMutator","page":"Backrub Mutators","title":"ProtoSyn.Mutators.BackrubMutator","text":"BackrubMutator(translation_vector_sampler::Function, p_mut::AbstractFloat, step_size::AbstractFloat, selection::Opt{AbstractSelection})\n\nReturn a BackrubMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(backrub_mutator::BackrubMutator)(pose::Pose)\n\nThe BackrubMutator AbstractMutator loops through all the Atom instances in a given Pose and applies a translation movement if a random number (rand()) is bellow a given probability of mutation p_mut (therefore a higher p_mut value applies a larger number of translation movements per call). The translation vector is sampled from the translation_vector_sampler, multiplied by the given step_size. The resulting value is then added to the selected Atom.t. Note that a new translation vector is sampled for each selected Atom instance. If an AbstractSelection selection is provided, only the selected Atom instances are looped over. If the given AbstractSelection selection is not of selection type Atom, it will be promoted to this type (using promote with default aggregator any). Note that the BackrubMutator syncs any pending internal to cartesian coordinate conversion (using the i2c! method). Requests cartesian to internal coordinates conversion (using request_c2i! method). Does not sync! the given Pose afterwards.\n\nThe BackrubMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(backrub_mutator::BackrubMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\ntranslation_vector_sampler::Function - Should return a Vector{Float} axis (X, Y and Z dimensions). Is called with no input arguments;\np_mut::AbtractFloat - Compared against a rand() call, applies this Mutator to Atom instances where rand() < p_mut;\nstep_size::AbstractFloat - Multiplies the sampled vector by this value;\nselection::Opt{AbstractSelection} - If given, this Mutator will only loop over the selected Atom instances.\n\nSee also\n\nTranslationRigidBodyMutator\n\nExamples\n\n⚯  Backrub Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | translation_vector_sampler  | Function rand_vector_in_sphere |\n| 2     | p_mut                       | 1.0000                         |\n| 3     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ○  Selection: Not Set\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/mutators/mutators-backrub/","page":"Backrub Mutators","title":"Backrub Mutators","text":"(Image: ProtoSyn Backrub Mutator)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-backrub/","page":"Backrub Mutators","title":"Backrub Mutators","text":"Figure 1 | A schematic representation of a BackrubMutator instance. In this example, the BackrubMutator selects all the Atom instances of the peptide. For each atom, a random translation vector in a sphere is generated and applied (multiplied by the mutator step_size). This AbstractMutator, in conjunction with a quick SteepestDescent energy minimization, can be helpful, among other things, as a protocol to generate \"in-target\" poses (slight variations of a given pose with small RMSD changes and similar secondary structure content).","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#Rotamers","page":"Rotamers","title":"Rotamers","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"The Rotamers is a submodule of ProtoSyn.Peptides module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"A Rotamer is a collection of chi angles for a specific conformation for the sidechain of an aminoacid. Although virtually all dihedral angles are allowed, for each chi dihedral, certain conformations are energetically more favourable and therefore have a higher natural probability of observation. The allowed Rotamers can be further dependent on certain backbone dihedral angles (for the phi and psi dihedrals). All this information can be gathered in a Rotamer Library, a useful tool when trying to answer the question: \"What set of sidechain conformations stabilize the protein structure?\", sometimes also referred to as the sidechain packaging problem. Multiple such rotamer libraries have been proposed. ProtoSyn makes available a set of types and methods that allow the manipulation and application of rotamer libraries, while using, as a default, the 2011 Dunbrack library. This is further explored in the following section, sub-divided as follows for organizational purposes:","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"Organizing a Rotamer Library\nApplying a Rotamer Library\nLoading a Rotamer Library","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#Organizing-a-Rotamer-Library","page":"Rotamers","title":"Organizing a Rotamer Library","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"Rotamer\nBBI_RotamerLibrary\nBBD_RotamerLibrary","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.Rotamer","page":"Rotamers","title":"ProtoSyn.Peptides.Rotamer","text":"Rotamer{T <: AbstractFloat}(name::String, chis::Dict{AbstractSelection, Tuple{T, T}})\n\nA Rotamer holds information regarding a single conformation for all chi dihedral angles of a sidechain belonging to an aminoacid identified by the  given name. The chis list is, therefore, a dictionary, where the key is the AbstractSelection (chi1, chi2, chi3 or chi4) and the value is a Tuple{T, T}, where the first entry is the average dihedral angle and the second entry is the standard deviation expected for that dihedral angle.\n\nSee also\n\nget_rotamer apply!\n\nExamples\n\njulia> rot_lib[\"LYS\"][35°, -35°][1]\nRotamer{Float64}: LYS | Chi1:   -67.5° ±  6.9 | Chi2:  -179.6° ±  9.7 | Chi3:  -179.7° ± 11.8 | Chi4:   178.5° ± 12.0\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.BBI_RotamerLibrary","page":"Rotamers","title":"ProtoSyn.Peptides.BBI_RotamerLibrary","text":"BBI_RotamerLibrary{T <: AbstractFloat}(rotamers::Vector{Rotamer{T}}, weights::Weights{T, T, Array{T, 1}})\n\nA BBI_RotamerLibrary is a backbone-independent list of Rotamer instances, ordered based on the natural probability of occurrence, where each position in the rotamers list has a corresponding position in the weights list.\n\nSee also\n\nsample_rotamer\n\nExamples\n\njulia> rot_lib[\"VAL\"][35°, -35°]\n\n+---------------------------------------------------------------------------------------------------------------------------+\n| Index | Probability | Rotamer description                                                                                 |\n+---------------------------------------------------------------------------------------------------------------------------+\n| 1     |      82.07% | VAL | Chi1:   175.8° ±  5.6 | Chi2: --              | Chi3: --              | Chi4: --              |\n| 2     |      13.74% | VAL | Chi1:    64.7° ±  7.5 | Chi2: --              | Chi3: --              | Chi4: --              |\n| 3     |       4.18% | VAL | Chi1:   -61.6° ±  6.4 | Chi2: --              | Chi3: --              | Chi4: --              |\n+---------------------------------------------------------------------------------------------------------------------------+\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.BBD_RotamerLibrary","page":"Rotamers","title":"ProtoSyn.Peptides.BBD_RotamerLibrary","text":"BBD_RotamerLibrary{T <: AbstractFloat}(name::String, phis::Vector{T}, psis::Vector{T}, rotamer_stacks::Matrix{BBI_RotamerLibrary}) where {T <: AbstractFloat}\n\nA BBD_RotamerLibrary is a 2D backbone dependent matrix of BBI_RotamerLibrary instances (rotamer_stacks), indexed by both the list of backbone phi dihedrals (phis) and the list of backbone psi dihedrals (psis). Each BBD_RotamerLibrary only hold information regarding one type of aminoacid, identified by the name. Each entry in the rotamer_stacks matrix only holds information of the list of rotamers available/plausible for a specific set of phi and psi backbone dihedrals.\n\nSee also\n\nload_dunbrack\n\nExamples\n\njulia> rot_lib[\"VAL\"]\nName: VAL | Shape: (37, 37)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"(Image: ProtoSyn Rotamer Library)","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"Figure 1 | A diagram representation of a ProtoSyn Rotamer Library organization. For each entry in a dictionary (where the keys are the aminoacid names with a rotatable sidechain), a BBD_RotamerLibrary can be queried for with the backbone phi and psi dihedral angles, retrieving the backbone dependent BBI_RotamerLibrary. This object organizes all the plausible Rotamer conformations, based on the probability of natural occurrence, from where a specific Rotamer can be sampled. Finally, a Rotamer is simply a list of chi dihedral angles (and the corresponding standard deviation), and can be applied to a Pose (using the apply! method).","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#Applying-a-Rotamer-Library","page":"Rotamers","title":"Applying a Rotamer Library","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"apply!\nsample_rotamer\nget_rotamer","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.apply!","page":"Rotamers","title":"ProtoSyn.Peptides.apply!","text":"apply!(state::State, rotamer::Rotamer, residue::Residue)\n\nApply the given Rotamer rotamer to the sidechain of Residue residue, on the provided State state. Return the applied Rotamer rotamer, without applying the sync! method to the State state.\n\nExamples\n\njulia> ProtoSyn.Peptides.apply!(pose.state, rot_lib[\"GLU\"][35°, -35°][1], pose.graph[1][2])\nRotamer{Float64}: GLU | Chi1:   -55.6° ±  0.0 | Chi2:   187.7° ±  0.0 | Chi3:    -2.6° ±  0.0 | Chi4: --   \n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.sample_rotamer","page":"Rotamers","title":"ProtoSyn.Peptides.sample_rotamer","text":"sample_rotamer(rs::BBI_RotamerLibrary{T}, [n::Int = -1]) where {T <: AbstractFloat}\n\nSample a Rotamer instance from the given BBI_RotamerLibrary rs, taking the natural probability of occurrence into consideraction. If a n value is given, sample only from the n most likely Rotamer instances. If n is 0 or lower (-1, by default), sample from all Rotamer instances. Return the sampled Rotamer instance.\n\nExamples\n\njulia> ProtoSyn.Peptides.sample_rotamer(rot_lib[\"GLU\"][35°, -35°])\nRotamer{Float64}: GLU | Chi1:   -66.8° ±  8.2 | Chi2:   179.1° ± 11.8 | Chi3:   -35.0° ±  8.5 | Chi4: --         \n\n\n\n\n\nsample_rotamer(rl::Dict{String, BBI_RotamerLibrary}, residue::Residue, n::Int = -1)\n\nSample a Rotamer instance from the corresponding BBI_RotamerLibrary for the given Residue residue name. This method takes the natural probability of occurrence into consideraction. If a n value is given, sample only from the n most likely Rotamer instances. If n is 0 or lower (-1, by default), sample from all Rotamer instances. Return the sampled Rotamer instance.\n\nExamples\n\njulia> ProtoSyn.Peptides.sample_rotamer(rot_lib, pose.graph[1][24])\nRotamer{Float64}: SER | Chi1:   179.7° ±  8.4 | Chi2: --              | Chi3: --              | Chi4: --      \n\n\n\n\n\nsample_rotamer(pose::Pose, rl::Dict{String, BBD_RotamerLibrary}, residue::Residue, [n::Int = -1], [random_inexistent_phi_psi::Bool = false])\n\nSample a Rotamer instance from the corresponding BBD_RotamerLibrary for the given Residue residue name. Since the BBD_RotamerLibrary is backbone-dependent, the current State of the provided Pose pose is read to sample a Rotamer. This method takes the natural probability of occurrence into consideraction. If a n value is given, sample only from the n most likely Rotamer instances. If n is 0 or lower (-1, by default), sample from all Rotamer instances. If random_inexistent_phi_psi is set to true (false, by default), randomly assigns a phi or psi angle value when none exists (for example, in terminal Residue instances), allowing for a Rotamer to still be sampled. Return the sampled Rotamer instance.\n\nExamples\n\njulia> ProtoSyn.Peptides.sample_rotamer(pose, rot_lib, pose.graph[1][6])\nRotamer{Float64}: GLU | Chi1:   -65.5° ±  9.5 | Chi2:    81.7° ±  9.6 | Chi3:     7.3° ±  8.5 | Chi4: --       \n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.get_rotamer","page":"Rotamers","title":"ProtoSyn.Peptides.get_rotamer","text":"get_rotamer(pose::Pose, residue::Residue)\n\nMeasure the existent chi dihedral angles in Residue residue on the given Pose pose, saving the information in a new Rotamer instance.\n\nExamples\n\njulia> ProtoSyn.Peptides.get_rotamer(pose, pose.graph[1][2])\nRotamer{Float64}: GLU | Chi1:   180.0° ±  0.0 | Chi2:  -180.0° ±  0.0 | Chi3:    90.0° ±  0.0 | Chi4: --     \n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/rotamers/#Loading-a-Rotamer-Library","page":"Rotamers","title":"Loading a Rotamer Library","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"load_dunbrack","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.load_dunbrack","page":"Rotamers","title":"ProtoSyn.Peptides.load_dunbrack","text":"load_dunbrack([::Type{T}], [filename::String]) where {T <: AbstractFloat}\n\nLoad a Dunbrack styled rotamer library from file filename (if no filename is given, will load the default rotamer library from the resources directory). If no type T is provided, will use ProtoSyn.Units.defaultFloat. Return a dictionary where each key is the name of an aminoacid type and the value is the corresponding loaded BBD_RotamerLibrary instance. Note that not all aminoacid types have sidechains, and therefore, have an associated  BBD_RotamerLibrary instance.\n\nExamples\n\njulia> rot_lib = ProtoSyn.Peptides.load_dunbrack(Float64)\nDict{String, ProtoSyn.Peptides.BBD_RotamerLibrary} with 19 entries:\n  \"GLN\" => Name: GLN | Shape: (37, 37)…\n  \"LYS\" => Name: LYS | Shape: (37, 37)…\n  \"ASN\" => Name: ASN | Shape: (37, 37)…\n  \"TRP\" => Name: TRP | Shape: (37, 37)…\n  \"THR\" => Name: THR | Shape: (37, 37)…\n  \"VAL\" => Name: VAL | Shape: (37, 37)…\n  \"HIS\" => Name: HIS | Shape: (37, 37)…\n  \"SER\" => Name: SER | Shape: (37, 37)…\n  \"PRO\" => Name: PRO | Shape: (37, 37)…\n  \"ASP\" => Name: ASP | Shape: (37, 37)…\n  \"PHE\" => Name: PHE | Shape: (37, 37)…\n  \"ILE\" => Name: ILE | Shape: (37, 37)…\n  \"TYR\" => Name: TYR | Shape: (37, 37)…\n  \"HIE\" => Name: HIS | Shape: (37, 37)…\n  \"ARG\" => Name: ARG | Shape: (37, 37)…\n  \"LEU\" => Name: LEU | Shape: (37, 37)…\n  \"MET\" => Name: MET | Shape: (37, 37)…\n  ⋮     => ⋮\n\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/other/","page":"Auxiliary methods","title":"Auxiliary methods","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/methods/other/#Auxiliary-methods","page":"Auxiliary methods","title":"Auxiliary methods","text":"","category":"section"},{"location":"protosyn-api/core/methods/other/","page":"Auxiliary methods","title":"Auxiliary methods","text":"The following methods include auxiliary functions for various tasks.","category":"page"},{"location":"protosyn-api/core/methods/other/","page":"Auxiliary methods","title":"Auxiliary methods","text":"rand_vector_in_sphere\nrotation_matrix_from_axis_angle\nunit_circle\nhalf_unit_circle\nfibonacci_sphere\nhist_by_distance_by_elem","category":"page"},{"location":"protosyn-api/core/methods/other/#ProtoSyn.rand_vector_in_sphere","page":"Auxiliary methods","title":"ProtoSyn.rand_vector_in_sphere","text":"rand_vector_in_sphere([::Type{T}]) where {T <: AbstractFloat}\n\nReturn a random vector in a sphere, with norm = 1. The X, Y and Z cartesian coordinates are of type T. If not provided, the ProtoSyn.Units.defaultFloat type will be used.\n\nExamples\n\njulia> ProtoSyn.rand_vector_in_sphere()\n3-element Array{Float64,1}:\n 0.4182585394795512\n 0.4965570141814753\n 0.7605859095589471\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/other/#ProtoSyn.rotation_matrix_from_axis_angle","page":"Auxiliary methods","title":"ProtoSyn.rotation_matrix_from_axis_angle","text":"rotation_matrix_from_axis_angle(axis::Vector{T}, angle::T) where {T <: AbstractFloat}\n\nReturn a rotation matrix based on the provided axis and angle (in radians).\n\nExamples\n\njulia> ProtoSyn.rotation_matrix_from_axis_angle([1.1, 2.2, 3.3], π/2)\n3×3 Matrix{Float64}:\n  0.0714286  -0.658927  0.748808\n  0.944641    0.285714  0.16131\n -0.320237    0.695833  0.642857\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/other/#ProtoSyn.unit_circle","page":"Auxiliary methods","title":"ProtoSyn.unit_circle","text":"unit_circle(value::T) where {T <: AbstractFloat}\n\nMaps an angle value (in radians) from ]-∞, +∞[ to [0, 2π[ range. Returns value in radians.\n\nExamples\n\njulia> ProtoSyn.unit_circle(-2pi)\n0.0\n\njulia> ProtoSyn.unit_circle(-(3/2)pi)\n1.5707963267948966\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/other/#ProtoSyn.half_unit_circle","page":"Auxiliary methods","title":"ProtoSyn.half_unit_circle","text":"half_unit_circle(value::T) where {T <: AbstractFloat}\n\nMaps an angle value (in radians) from ]-∞, +∞[ to [-π, π[ range. Returns value in radians.\n\nExamples\n\njulia> ProtoSyn.half_unit_circle(-2pi)\n0.0\n\njulia> ProtoSyn.half_unit_circle(-(3/2)pi)\n-1.5707963267948966\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/other/#ProtoSyn.fibonacci_sphere","page":"Auxiliary methods","title":"ProtoSyn.fibonacci_sphere","text":"fibonacci_sphere([::Type{T}], n_points::Int = 1000) where {T <: AbstractFloat}\n\nGenerate a set n_points cartesian coordinates following the fibonnacci lattice (see http://extremelearning.com.au/how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice/). If provided, use the AbstractFloat type T (otherwise, will use ProtoSyn.Units.defaultFloat).\n\nExamples\n\njulia> ProtoSyn.fibonacci_sphere(10)\n10-element Vector{Vector{Float64}}:\n [0.0, 1.0, 0.0]\n [-0.4634653634889746, 0.7777777777777778, 0.42457223795379545]\n [0.07269269081806179, 0.5555555555555556, -0.8282957185649263]\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/other/#ProtoSyn.hist_by_distance_by_elem","page":"Auxiliary methods","title":"ProtoSyn.hist_by_distance_by_elem","text":"hist_by_distance_by_elem(pose::Pose, [selection::Opt{AbstractSelection} = nothing]; [cutoff::T = 16.0], [bin::T = 0.2], [elems::Vector{String} = [\"H\", \"O\", \"N\", \"C\", \"S\"]], [dm::Opt{Matrix{T}} = nothing]) where {T <: AbstractFloat}\n\nCalculates the given Pose pose distance histogram by Atom element. The output format matches the requirements for predict_igbr_nn_born_radii (for more information, see https://academic.oup.com/bioinformatics/article/36/6/1757/5613804). If an AbstractSelection selection is provided, only the selected subset of Atom instances is considered for the histogram calculation (promoted to Atom level using the promote method). The distance histogram is generated for all Atom instances within cutoff Å of the focused Atom, sub-divided in bins of bin Å. If a full_distance_matrix dm is provided, use it for distance calculation, otherwise a new distance matrix is generated. Each Atom histogram is divided by elements: one histogram is generated for each atomic element in elems containing all neighbouring Atom instances of that type. \n\nExamples\n\njulia> ProtoSyn.hist_by_distance_by_elem(pose)\n1140×400 Matrix{Int64}:\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"CurrentModule = ProtoSyn.Peptides.Calculators.Restraints","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/#peptides-calculators-potential-restraints","page":"Potential Restraints","title":"Potential restraints","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"As previously stated, Potential restraints are a family of EnergyFunctionComponent instances that apply any given potential to a selection of Atom instances, optionally further masked or mapped. For more details on how Potential restraints work in ProtoSyn (and how to set-up custom potentials) check the Core module Potential restraints section. In the Peptides module, new (or improved) Potential restraints are introduced, organized in the following sub-sections:","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Cα - Cα Clash Restraint\nSidechain Clash Restraint\nContact Restraint","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/#Cα-Cα-Clash-Restraint","page":"Potential Restraints","title":"Cα - Cα Clash Restraint","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"The Cα - Cα Clash Restraint is a potential restraint (See Potential restraints for more details), applying a penalty for pairs of interacting Cα atoms with distances lower than a set value, thus reducing the occurrence of Residue overlaps (also known as clashes).","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"get_default_ca_clash_restraint","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/#ProtoSyn.Peptides.Calculators.Restraints.get_default_ca_clash_restraint","page":"Potential Restraints","title":"ProtoSyn.Peptides.Calculators.Restraints.get_default_ca_clash_restraint","text":"get_default_ca_clash_restraint(;[α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default Cα-Cα clash restraint EnergyFunctionComponent. α sets the component weight (on an EnergyFunction). If a mask is provided, the component will apply that mask every calculation (fixed mask) - recommended, except for design efforts. Otherwise, the default get_diagonal_mask function will be used, which calculates a new diagonal mask every calculation (effectly ignoring the same atom energetic contributions).\n\nukw: Note:\nBy default, this EnergyFunctionComponent does not calculate forces, as they would only be applied to the Cα atoms. This setting can be re-defined in component.update_forces.\n\nCα clash energy settings\n\n:d1, :d2, :d3, :d4 -> set each of the distances defining a flat-bottom potential (in Angstrom Å);\n:selection -> defines the atom selection limiting the considered atoms for the calculation; \n:mask -> defines the mask applied to the energy and forces result;\n\nSee also\n\nProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint ProtoSyn.Calculators.get_diagonal_mask\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Restraints.get_default_ca_clash_restraint()\n         Name : Cα-Cα_Clash_Restraint\n   Weight (α) : 1.0\nUpdate forces : false\n      Setings :\n       :d4 => Inf\n:selection => FieldSelection › Atom.name = CA\n       :d2 => 3.0\n     :mask => _diagonal_mask\n       :d1 => 1.0\n       :d3 => Inf\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"(Image: ProtoSyn CA-CA Restraint)","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Figure 1 | A diagram representation of the Cα - Cα Clash Restraint EnergyFunctionComponent. The applied potential is a flat bottom function, with only the lower bound having and energy penatly. The d1 and d2 settings can be customly parametrized. This energy is only calculated for pair of interacting Cα Atom instances (in different Residue instances, as defined the the provided AbstractSelection and mask).","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/#Sidechain-Clash-Restraint","page":"Potential Restraints","title":"Sidechain Clash Restraint","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"The Sidechain Clash Restraint is a potential restraint (See Potential restraints for more details), applying a penalty for pairs of interacting atoms (belonging to different sidechains) with distances under a given threshold.","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"get_default_sidechain_clash_restraint","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/#ProtoSyn.Peptides.Calculators.Restraints.get_default_sidechain_clash_restraint","page":"Potential Restraints","title":"ProtoSyn.Peptides.Calculators.Restraints.get_default_sidechain_clash_restraint","text":"get_default_sidechain_clash_restraint(;[α::T = 1.0], [mask::Opt{ProtoSyn.Mask} = nothing]) where {T <: AbstractFloat}\n\nReturn the default sidechain clash restraint EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). If a mask is provided, the component will apply that mask every calculation (fixed mask) - recommended, except for design efforts. Otherwise, the default get_intra_residue_mask function will be used, which calculates a new intra-residue mask every calculation.\n\nSidechain clash energy settings\n\n:d1, :d2, :d3, :d4 -> set each of the distances defining a flat-bottom potential (in Angstrom Å);\n:selection -> defines the atom selection limiting the considered atoms for the calculation; \n:mask -> defines the mask applied to the energy and forces result;\n\nSee also\n\nProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint ProtoSyn.Calculators.get_intra_residue_mask\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Restraints.get_default_sidechain_clash_restraint()\n     Name : Clash_Sidechain_Restraint\nWeight(α) : 1.0\n Settings :\n            :d4 => Inf\n            :selection => UnarySelection ❯ ! \"not\" (Atom)\n                          └── FieldSelection › Atom.name = r\"^CA$|^N$|^C$|^H$|^O$\"\n            :d2 => 1.5\n          :mask => _intra_residue_mask\n            :d1 => 1.0\n            :d3 => Inf\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"(Image: ProtoSyn Sidechain Clash Restraint)","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Figure 1 | A diagram representation of the Sidechain Clash Restraint EnergyFunctionComponent. The applied potential is a flat bottom function, with only the lower bound having and energy penatly. The d1 and d2 settings can be customly parametrized. This energy is only calculated for pair of interacting Atom instances in sidechains of different Residue instances (as defined the the provided AbstractSelection and mask).","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/#Contact-Restraint","page":"Potential Restraints","title":"Contact Restraint","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"The Contact Restraint is a potential restraint (See Potential restraints for more details), applying a penalty for pairs of interacting Cα atoms with distances larger than a set value defined in a contact map. For contact map generation, consider using the RaptorX prediction server.","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"get_default_contact_restraint","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/#ProtoSyn.Peptides.Calculators.Restraints.get_default_contact_restraint","page":"Potential Restraints","title":"ProtoSyn.Peptides.Calculators.Restraints.get_default_contact_restraint","text":"   get_default_contact_restraint(filename::String; [α::T = 1.0]) where {T <: AbstractFloat}\n\nReturn the default contact map restraint    EnergyFunctionComponent    by reading the given filename. α sets the component weight (on an    EnergyFunction).\n\n!!! ukw \"Note:\"        Since the contact map is fixed, any EnergyFunction containing this EnergyFunctionComponent can only be applied to one protein/sequence (no design). The attached contact map can be re-defined in component.settings[:mask].\n\n!!! ukw \"Note:\"        By default, this EnergyFunctionComponent does not calculate forces, as they would only be applied to the Cα Atom instances. This setting can be re-defined in component.update_forces.\n\nContact energy settings\n\n:d1, :d2, :d3, :d4 -> set each of the distances defining a flat-bottom potential (in Angstrom Å);\n:selection -> defines the atom selection limiting the considered atoms for the calculation; \n:mask -> defines the mask applied to the energy and forces result;\n\nSee also\n\nProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint    ProtoSyn.Calculators.load_map\n\nExamples\n\n```    julia> ProtoSyn.Peptides.Calculators.Restraints.getdefaultcontactrestraint(\"contactmapexample.txt\")    Name : ContactMap    Weight (α) : 1.0 Update forces : false       Setings :            :d4 => 12.0     :selection => FieldSelection › Atom.name = CA\n\n       :d2 => 0.0\n     :mask => Matrix{Float64}((73, 73)\n       :d1 => 0.0\n       :d3 => 8.0\n\n```\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"(Image: ProtoSyn Contact Restraint)","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Figure 1 | A diagram representation of the Contact Restraint EnergyFunctionComponent. The applied potential is a flat bottom function, with only the upper bound having and energy penatly. The d3 and d4 settings can be customly parametrized. This energy is only calculated for pair of interacting Cα Atom instances (in different Residue instances, as defined the the provided AbstractSelection and mask). The penalty scale is defined in the loaded contact map file.","category":"page"},{"location":"protosyn-api/peptides/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"ukw: Note:\nMost Potential restraints employ dynamic masks, by default. This can have a detrimental effect on performance. If no design effort is being performed, consider converting the dynamic masks to static masks. See ProtoSyn.Calculators.fixate_mask!.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-compound/","page":"Compound Mutators","title":"Compound Mutators","text":"CurrentModule = ProtoSyn.Mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-compound/#Compound-Mutator","page":"Compound Mutators","title":"Compound Mutator","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-compound/","page":"Compound Mutators","title":"Compound Mutators","text":"The Compound Mutator is an aggregating type of AbstractMutator. The sole function of this mutator is to apply multiple inner AbstractMutator instances in sequence. Optionally, if a selection is provided, all inner AbstractMutator instance's selection is merged with this common selection.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-compound/","page":"Compound Mutators","title":"Compound Mutators","text":"CompoundMutator","category":"page"},{"location":"protosyn-api/core/mutators/mutators-compound/#ProtoSyn.Mutators.CompoundMutator","page":"Compound Mutators","title":"ProtoSyn.Mutators.CompoundMutator","text":"CompoundMutator(mutators::Vector{AbstractMutator}, selection::Union{AbstractSelection, Nothing})\n\nReturn a CompoundMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(compound_mutator::CompoundMutator)(pose::Pose)\n\nA CompoundMutator loops over a list of one or more AbstractMutator instances, applying them in the provided sequence to a Pose instance. If an AbstractSelection selection is provided, the same selection will be used when applying each AbstractMutator, merged with any possible inner selection specific for each mutator (using the & \"and\" operator). For example, a DihedralMutator may have an an\"CA\" selection attached. When called from a CompoundMutator with a rid\"1:10\" selection attached, only the CA Atom instances from the region between Residue 1 to Residue 10 will be considered for application of the DihedralMutator. Note that, when applying each mutator, any required sync! call and request for internal to cartesian coordinate conversion (or vice-versa) are handled by each AbstractMutator independently.\n\nThe CompoundMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator (i.e.: CompoundMutator of a CompoundMutator).\n\n(compound_mutator::CompoundMutator)(pose::Pose, atoms::Vector{Atom})\n\nukw: Note:\nThis AbstractMutator requires that the mutators provided in the list have a (compound_mutator::CompoundMutator)(pose::Pose, atoms::Vector{Atom}) signature. Check each AbstractMutator documentation entry and Creating custom mutators section for details. \n\nFields\n\nmutators::Vector{AbstractMutator} - The list of AbstractMutator instances this mutator will loop over and apply sequentially;\nselection::Union{AbstractSelection, Nothing} - If provided, all inner AbstractMutator instances will be applied to each individual selection (if present) merged with this common selection.\n\nSee also\n\nCompoundDriver\n\nExamples\n\njulia> m = ProtoSyn.Mutators.CompoundMutator([rrbm, trbm], an\"CBZ\")\n⚯  Compound Mutator:\n ├──  ● Inner Mutators (2 elements):\n |    ├── ⚯  Rotation Rigid Body Mutator:\n |    |   +----------------------------------------------------------------------+\n |    |   | Index | Field                       | Value                          |\n |    |   +----------------------------------------------------------------------+\n |    |   | 1     | axis_sampler                | Function rand_vector_in_sphere |\n |    |   | 2     | angle_sampler               | Function randn                 |\n |    |   | 3     | pivot_sampler               | Function center_of_mass        |\n |    |   | 4     | step_size                   | 0.4000                         |\n |    |   +----------------------------------------------------------------------+\n |    |    ● Selection: Set\n |    |    └── BinarySelection ❯  & \"and\" (Atom)\n |    |         ├── FieldSelection › Atom.name = CA\n |    |         └── FieldSelection › Atom.name = CB\n |    |   \n |    └── ⚯  Translation Rigid Body Mutator:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                       | Value                          |\n |        +----------------------------------------------------------------------+\n |        | 1     | translation_vector_sampler  | Function rand_vector_in_sphere |\n |        | 2     | step_size                   | 1.0000                         |\n |        +----------------------------------------------------------------------+\n |         ○  Selection: Not Set\n |   \n └──  ● Selection: Set\n      └── FieldSelection › Atom.name = CBZ\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/mutators/mutators-compound/","page":"Compound Mutators","title":"Compound Mutators","text":"(Image: ProtoSyn Compound Mutator)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-compound/","page":"Compound Mutators","title":"Compound Mutators","text":"Figure 1 | A diagram of an example CompoundMutator instance. In this example, the CompoundMutator.mutators list is comprised of a RotationRigidBodyMutator and a TranslationRigidBodyMutator, both without any internal selections. The CompoundMutator itself, however, has a RandomSelectionFromList AbstractSelection which will randomly select one of the two provided RangeSelection instances and apply both the rotation and translation rigid body mutators.","category":"page"},{"location":"protosyn-api/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"protosyn-api/internals/#How-did-you-get-here?!","page":"Internals","title":"How did you get here?!","text":"","category":"section"},{"location":"protosyn-api/internals/","page":"Internals","title":"Internals","text":"The following docstrings are a dump for non-exported private & internal functions. These provide basic internal functionality that should rarely be employed by an end-user. In either case, docstrings exist to explain the inner-workings of methods for potential developers.","category":"page"},{"location":"protosyn-api/internals/","page":"Internals","title":"Internals","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/internals/","page":"Internals","title":"Internals","text":"ProtoSyn.Calculators.TorchANI.r_xml_travel!\nProtoSyn.Clustering.dunn_index\nProtoSyn.Calculators.get_available_energy_function_components\nBase.resize!(::ProtoSyn.Calculators.VerletList, ::Int64)\nProtoSyn.Common\nProtoSyn.AbstractContainer\nProtoSyn.Peptides.Calculators.Caterpillar.nc_scalling_exposed_only\nProtoSyn.Peptides.Calculators.Caterpillar.nv_scalling_exposed_only\nProtoSyn.Peptides.Calculators.Caterpillar.nc_non_scalling_exposed_only\nProtoSyn.Peptides.Calculators.Caterpillar.nv_non_scalling_exposed_only\nProtoSyn.Peptides.Calculators.Caterpillar.nc_scalling_all_contributions\nProtoSyn.Peptides.Calculators.Caterpillar.nv_scalling_all_contributions\nProtoSyn.Peptides.Calculators.Caterpillar.nc_non_scalling_all_contributions\nProtoSyn.Peptides.Calculators.Caterpillar.nv_non_scalling_all_contributions\nProtoSyn.cross2d\nProtoSyn.@cross\nProtoSyn.@dot\nProtoSyn.Calculators.@reduce\nProtoSyn.get_lead\nProtoSyn.Calculators.distance_matrix_kernel\nProtoSyn.Clustering.complete_diameter_distances\nProtoSyn.Clustering.davies_bouldin_index\nProtoSyn.Clustering.rmsd_matrix\nProtoSyn.Clustering.average_diameter_distances\nProtoSyn.tile\nProtoSyn.tile!\nProtoSyn.Mutators\nProtoSyn.Peptides.Mutators\nProtoSyn.Peptides\nProtoSyn.Materials\nProtoSyn.GMX\nProtoSyn.Peptides.GMX\nProtoSyn.GMX.check_installation\nProtoSyn.Calculators.neighbours\nProtoSyn.Calculators.Restraints\nProtoSyn.print_diagnose_results\nProtoSyn.XMLRPC.ClientProxy\nProtoSyn.read_yml\nProtoSyn.gpu_allocation\nProtoSyn.promote","category":"page"},{"location":"protosyn-api/internals/#ProtoSyn.Calculators.TorchANI.r_xml_travel!","page":"Internals","title":"ProtoSyn.Calculators.TorchANI.r_xml_travel!","text":"r_xml_travel!(xml::Union{XMLDocument, XMLElement}, query::String, results::Vector{T}) where {T <: AbstractFloat}\n\nRecursively travel the XMLDocument or XMLElement and gather all entrys of label type query, pushing them to the results vector (a parse for the correct T type is attempted).\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Clustering.dunn_index","page":"Internals","title":"ProtoSyn.Clustering.dunn_index","text":"dunn_index(intra::Vector{T}, inter::Vector{T}) where {T <: AbstractFloat}\n\nGiven a vector with all intra-distances of all clusters considered and an inter-distance matrix between all clusters considered, return the Dunn Index. Note: The higher the Dunn Index, the better is the clustering.\n\nExamples\n\njulia> ProtoSyn.Clustering.dunn_index(intra, inter)\n1.0097267039046134\n\nSee also\n\nProtoSyn.Clustering.davies_bouldin_index\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Calculators.get_available_energy_function_components","page":"Internals","title":"ProtoSyn.Calculators.get_available_energy_function_components","text":"get_available_energy_function_components([m::Module = ProtoSyn.Calculators])\n\nReturns all available EnergyFunctionComponent instances in the provided Module m (defaults to ProtoSyn.Calculators). Recursivelly searches any inner Module.\n\nSee also\n\nshow_available_energy_function_components\n\nExamples\n\njulia> ProtoSyn.Calculators.get_available_energy_function_components(ProtoSyn.Calculators) 14-element Vector{Function}:  get_default_custom_ref_energy (generic function with 1 method)  get_default_coulomb (generic function with 1 method)  (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#Base.resize!-Tuple{ProtoSyn.Calculators.VerletList, Int64}","page":"Internals","title":"Base.resize!","text":"resize!(verlet_list::VerletList, n::Int)\n\n    Resize a Verlet list to hold 'n' particles. If 'n' is higher than the\n    current length of the list, appends 0's.\n\nExample:\n\n    resize!(vl, 8)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/internals/#ProtoSyn.Common","page":"Internals","title":"ProtoSyn.Common","text":"The Common module stores functions with higher levels of abstraction and\nthat are common practice in ProtoSyn algorithms.\n\n\n\n\n\n","category":"module"},{"location":"protosyn-api/internals/#ProtoSyn.AbstractContainer","page":"Internals","title":"ProtoSyn.AbstractContainer","text":"AbstractContainer{T}\n\nSupertype for a container of elements of type T.\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/internals/#ProtoSyn.Peptides.Calculators.Caterpillar.nc_scalling_exposed_only","page":"Internals","title":"ProtoSyn.Peptides.Calculators.Caterpillar.nc_scalling_exposed_only","text":"nc_scalling_exposed_only(Ωi::Union{Int, T}; hydrophobicity_map_value::T = 0.0, Ω::Union{Int, T} = 0.0) where {T <: AbstractFloat}\n\nReturn the hydrophobicity weight w2 where all buried residues contributions are set to 0.0. The exposed residues contribution is a scaled difference between the given Ωi and the cut-off Ω, multiplied by the hydrophobicity_map_value.\n\nSee also\n\nnc_non_scalling_exposed_only nc_scalling_all_contributions nc_non_scalling_all_contributions\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.nc_scalling_exposed_only(10.0, hydrophobicity_map_value = 1.0, Ω = 5.0)\n5.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Peptides.Calculators.Caterpillar.nv_scalling_exposed_only","page":"Internals","title":"ProtoSyn.Peptides.Calculators.Caterpillar.nv_scalling_exposed_only","text":"nv_scalling_exposed_only(Ωi::Union{Int, T}; hydrophobicity_map_value::T = 0.0, Ω::Union{Int, T} = 0.0) where {T <: AbstractFloat}\n\nReturn the hydrophobicity weight w2 where all buried residues contributions are set to 0.0. The exposed residues contribution is a scaled difference between the given Ωi and the cut-off Ω, multiplied by the hydrophobicity_map_value.\n\nSee also\n\nnv_non_scalling_exposed_only nv_scalling_all_contributions nv_non_scalling_all_contributions\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.nv_scalling_exposed_only(10.0, hydrophobicity_map_value = 1.0, Ω = 5.0)\n5.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Peptides.Calculators.Caterpillar.nc_non_scalling_exposed_only","page":"Internals","title":"ProtoSyn.Peptides.Calculators.Caterpillar.nc_non_scalling_exposed_only","text":"nc_non_scalling_exposed_only(Ωi::Union{Int, T}; hydrophobicity_map_value::T = 0.0, Ω::Union{Int, T} = 0.0) where {T <: AbstractFloat}\n\nReturn the hydrophobicity weight w2 where all buried residues contributions are set to 0.0. The exposed residues contribution is the non scaled hydrophobicity_map_value.\n\nSee also\n\nnc_scalling_exposed_only nc_scalling_all_contributions nc_non_scalling_all_contributions\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.nc_non_scalling_exposed_only(10.0, hydrophobicity_map_value = 1.0, Ω = 5.0)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Peptides.Calculators.Caterpillar.nv_non_scalling_exposed_only","page":"Internals","title":"ProtoSyn.Peptides.Calculators.Caterpillar.nv_non_scalling_exposed_only","text":"nv_non_scalling_exposed_only(Ωi::Union{Int, T}; hydrophobicity_map_value::T = 0.0, Ω::Union{Int, T} = 0.0) where {T <: AbstractFloat}\n\nReturn the hydrophobicity weight w2 where all buried residues contributions are set to 0.0. The exposed residues contribution is the non scaled hydrophobicity_map_value.\n\nSee also\n\nnv_scalling_exposed_only nv_scalling_all_contributions nv_non_scalling_all_contributions\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.nv_non_scalling_exposed_only(10.0, hydrophobicity_map_value = 1.0, Ω = 5.0)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Peptides.Calculators.Caterpillar.nc_scalling_all_contributions","page":"Internals","title":"ProtoSyn.Peptides.Calculators.Caterpillar.nc_scalling_all_contributions","text":"nc_scalling_all_contributions(Ωi::Union{Int, T}; hydrophobicity_map_value::T = 0.0, Ω::Union{Int, T} = 0.0) where {T <: AbstractFloat}\n\nReturn the hydrophobicity weight w2 where all residue contributions are considered. Both the exposed and buried residues contributions are a scaled difference between the given Ωi and the cut-off Ω, multiplied by the hydrophobicity_map_value.\n\nSee also\n\nnc_scalling_exposed_only nc_non_scalling_exposed_only nc_non_scalling_all_contributions\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.nc_scalling_all_contributions(10.0, hydrophobicity_map_value = 1.0, Ω = 20.0)\n-10.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Peptides.Calculators.Caterpillar.nv_scalling_all_contributions","page":"Internals","title":"ProtoSyn.Peptides.Calculators.Caterpillar.nv_scalling_all_contributions","text":"nv_scalling_all_contributions(Ωi::Union{Int, T}; hydrophobicity_map_value::T = 0.0, Ω::Union{Int, T} = 0.0) where {T <: AbstractFloat}\n\nReturn the hydrophobicity weight w2 where all residue contributions are considered. Both the exposed and buried residues contributions are a scaled difference between the given Ωi and the cut-off Ω, multiplied by the hydrophobicity_map_value.\n\nSee also\n\nnv_scalling_exposed_only nv_non_scalling_exposed_only nv_non_scalling_all_contributions\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.nv_scalling_all_contributions(10.0, hydrophobicity_map_value = 1.0, Ω = 20.0)\n-10.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Peptides.Calculators.Caterpillar.nc_non_scalling_all_contributions","page":"Internals","title":"ProtoSyn.Peptides.Calculators.Caterpillar.nc_non_scalling_all_contributions","text":"nc_non_scalling_all_contributions(Ωi::Union{Int, T}; hydrophobicity_map_value::T = 0.0, Ω::Union{Int, T} = 0.0) where {T <: AbstractFloat}\n\nReturn the hydrophobicity weight w2 where all residue contributions are considered. Both the exposed and buried residues contributions are the non scaled hydrophobicity_map_value.\n\nSee also\n\nnc_scalling_exposed_only nc_non_scalling_exposed_only nc_scalling_all_contributions\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.nc_non_scalling_all_contributions(10.0, hydrophobicity_map_value = 1.0, Ω = 20.0)\n-1.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Peptides.Calculators.Caterpillar.nv_non_scalling_all_contributions","page":"Internals","title":"ProtoSyn.Peptides.Calculators.Caterpillar.nv_non_scalling_all_contributions","text":"nv_non_scalling_all_contributions(Ωi::Union{Int, T}; hydrophobicity_map_value::T = 0.0, Ω::Union{Int, T} = 0.0) where {T <: AbstractFloat}\n\nReturn the hydrophobicity weight w2 where all residue contributions are considered. Both the exposed and buried residues contributions are the non scaled hydrophobicity_map_value.\n\nSee also\n\nnv_scalling_exposed_only nv_non_scalling_exposed_only nv_scalling_all_contributions\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.nv_non_scalling_all_contributions(10.0, hydrophobicity_map_value = 1.0, Ω = 20.0)\n-1.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.cross2d","page":"Internals","title":"ProtoSyn.cross2d","text":"cross2d(m1::Mask{T}, m2::Mask{T}) where {T <: AbstractContainer}\n\nCombine both the provided Mask instances m1 and m2, so that the returned result is a 2D Mask where each position (N, M) is the result of combining m1[N] & m2[M].\n\ncross2d(m1::Mask{T}) where {T <: AbstractContainer}\n\nIf only 1 Mask m1 is provided, return the cross2d result of m1 and m1' (m1 transpose).\n\nSee also\n\ntile\n\nExamples\n\njulia> m = ProtoSyn.Mask{Atom}(4); m[1] = m[3] = true; m\nProtoSyn.Mask{Atom}(4,)\n4-element BitArray{1}:\n 1\n 0\n 1\n 0\n\njulia> ProtoSyn.cross2d(m)\nProtoSyn.Mask{Atom}(4, 4)\n4×4 BitArray{2}:\n 1  0  1  0\n 0  0  0  0\n 1  0  1  0\n 0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.@cross","page":"Internals","title":"ProtoSyn.@cross","text":"@macroexpand @cross u outu au b_u\n\nquote     out1 = a2 * b3 - a3 * b2     out2 = a3 * b1 - a1 * b3     out3 = a1 * b2 - a2 * b_1 end\n\n\n\n\n\n","category":"macro"},{"location":"protosyn-api/internals/#ProtoSyn.@dot","page":"Internals","title":"ProtoSyn.@dot","text":"@macroexpand @dot u au bu\n\n:(a1 * b1 + a2 * b2 + a3 * b3)\n\n\n\n\n\n","category":"macro"},{"location":"protosyn-api/internals/#ProtoSyn.Calculators.@reduce","page":"Internals","title":"ProtoSyn.Calculators.@reduce","text":"@reduce(n::Int, op::Symbol, ex::Expr)\n\n    Wrapping macro for @ncall. Is equivalent and generates\n    op(ex_1, ..., ex_n)\n\nExample:\n\n    @reduce 2 (+) u -> v_u^2\n    > Generates +(v_1^2, v_2^2)\n\n\n\n\n\n","category":"macro"},{"location":"protosyn-api/internals/#ProtoSyn.get_lead","page":"Internals","title":"ProtoSyn.get_lead","text":"get_lead(level_code::Opt{LevelCode} = nothing)\n\nAuxiliary function, uses level codes to show inheritance in the terminal for complex types.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Calculators.distance_matrix_kernel","page":"Internals","title":"ProtoSyn.Calculators.distance_matrix_kernel","text":"distance_matrix_kernel(coords::CuDeviceArray{T}, distance_matrix::CuDeviceMatrix{T}, n::Int) where {T <: AbstractFloat}\n\nKernel for CUDA2 acceleration of `distancematrix` calculation.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Clustering.complete_diameter_distances","page":"Internals","title":"ProtoSyn.Clustering.complete_diameter_distances","text":"complete_diameter_distances([T], assignments::Vector{Int}, rm::Matrix{T}) where {T <: AbstractFloat}\n\nGiven an assignment vector (see Clustering package) and a RMSD matrix (see ProtoSyn.Clustering.rmsd_matrix), return the intra- and inter-cluster complete diameter distances. Note: The complete diameter distance is the distance between the two most remote objects is the same cluster (intra-distance) or in two clusters (inter-distance).\n\nExamples\n\njulia> intra, inter = ProtoSyn.Clustering.complete_diameter_distances(clusters.assignments, rmsd_matrix)\n([8.611851425604167, 13.379156063323348], [0.0 13.509291152844908; 0.0 0.0])\n\nSee also\n\nProtoSyn.Clustering.average_diameter_distances\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Clustering.davies_bouldin_index","page":"Internals","title":"ProtoSyn.Clustering.davies_bouldin_index","text":"davies_bouldin_index(intra::Vector{T}, inter::Vector{T}) where {T <: AbstractFloat}\n\nGiven a vector with all intra-distances of all clusters considered and an inter-distance matrix between all clusters considered, return the Davies-Bouldin Index. Note: The lower the Davies-Bouldin Index, the better is the clustering.\n\nExamples\n\njulia> ProtoSyn.Clustering.davies_bouldin_index(intra, inter)\n0.8139215907082012\n\nSee also\n\nProtoSyn.Clustering.davies_bouldin_index\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Clustering.rmsd_matrix","page":"Internals","title":"ProtoSyn.Clustering.rmsd_matrix","text":"rmsd_matrix([T], poses::Vector{Pose})\nrmsd_matrix([T], poses::Vector{Pose}, selection::AbstractSelection)\n\nGiven a vector of Poses, calculate the pairwise RMSD (see ProtoSyn.rmsd) values between all members, after alignment (see ProtoSyn.align! for more information). If an optional type T <: AbstractFloat is given, use this type. Otherwise, will use ProtoSyn.Units.defaultFloat. If an AbstractSelection (selection) is given, use that sub-set of atoms for the alignment and RMSD calculation.\n\nExamples\n\njulia> a = ProtoSyn.Clustering.rmsd_matrix(poses, an\"CA\")\n3×3 Array{Float64,2}:\n0.0      7.18633  9.9984\n7.18633  0.0      7.01093\n9.9984   7.01093  0.0\n\nSee also\n\nProtoSyn.align! ProtoSyn.rmsd  ProtoSyn.Clustering.complete_diameter_distances  ProtoSyn.Clustering.average_diameter_distances\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Clustering.average_diameter_distances","page":"Internals","title":"ProtoSyn.Clustering.average_diameter_distances","text":"average_diameter_distances([T], assignments::Vector{Int}, rm::Matrix{T}) where {T <: AbstractFloat}\n\nGiven an assignment vector (see Clustering package) and a RMSD matrix (see ProtoSyn.Clustering.rmsd_matrix), return the intra- and inter-cluster average diameter distances. Note: The average diameter distance is the average linkage distance between all the objects is the same cluster (intra-distance) or all the objects in two clusters (inter-distance).\n\nExamples\n\njulia> intra, inter = ProtoSyn.Clustering.average_diameter_distances(clusters.assignments, rmsd_matrix)\n([6.19984080693077, 7.566813059033408], [0.0 8.551225161132669; 0.0 0.0])\n\nSee also\n\nProtoSyn.Clustering.complete_diameter_distances\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.tile","page":"Internals","title":"ProtoSyn.tile","text":"tile(m::Mask{T}) where {T <: AbstractContainer}\n\nRepeat and return the content of the provided Mask m N times, where N is the length of m, along the horizontal dimension. Note that this function expects a 1D Mask as input, otherwise will just return the received Mask.\n\nSee also\n\ntile!\n\nExamples\n\njulia> m = ProtoSyn.Mask{Atom}(4); m[1] = true; m\nProtoSyn.Mask{Atom}(4,)\n4-element BitArray{1}:\n 1\n 0\n 0\n 0\n\njulia> ProtoSyn.tile(m)\nProtoSyn.Mask{Atom}(4, 4)\n4×4 BitArray{2}:\n 1  1  1  1\n 0  0  0  0\n 0  0  0  0\n 0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.tile!","page":"Internals","title":"ProtoSyn.tile!","text":"tile!(m::Mask{T}) where {T <: AbstractContainer}\n\nRepeat the content of the provided Mask m N times, where N is the length of m. Note that this function expects a 1D Mask as input, otherwise will just return the received Mask. Overwrite the contents of the input Mask with the output.\n\nSee also\n\ntile\n\nExamples\n\njulia> m = ProtoSyn.Mask{Atom}(4); m[1] = true; m\nProtoSyn.Mask{Atom}(4,)\n4-element BitArray{1}:\n 1\n 0\n 0\n 0\n\njulia> ProtoSyn.tile!(m)\nProtoSyn.Mask{Atom}(4, 4)\n4×4 BitArray{2}:\n 1  1  1  1\n 0  0  0  0\n 0  0  0  0\n 0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Mutators","page":"Internals","title":"ProtoSyn.Mutators","text":"Mutators\n\nMutators are complex functions that perform 1 specific change in a system. Currently, ProtoSyn-base makes available the following mutators:\n\nDihedralMutator\nCrankshaftMutator\nRotationRigidBodyMutator\nTranslationRigidBodyMutator\nBackrubMutator\nCompoundMutator\n\n\n\n\n\n","category":"module"},{"location":"protosyn-api/internals/#ProtoSyn.Peptides.Mutators","page":"Internals","title":"ProtoSyn.Peptides.Mutators","text":"Mutators\n\nMutators are complex functions that perform 1 specific change in a system. Besides the list of available Mutators at ProtoSyn.Mutators, the Peptides module adds the following Mutators:\n\nRotamerMutator\nDesignMutator\n\n\n\n\n\n","category":"module"},{"location":"protosyn-api/internals/#ProtoSyn.Peptides","page":"Internals","title":"ProtoSyn.Peptides","text":"Peptides\n\nThe Peptides modules introduces Calculators, Mutators and Drivers (among other methods) specific for proteins and peptides.\n\n\n\n\n\n","category":"module"},{"location":"protosyn-api/internals/#ProtoSyn.Materials","page":"Internals","title":"ProtoSyn.Materials","text":"Materials\n\nThe Materials modules introduces several methods related to different types of materials (such as atomic lattices, etc).\n\n\n\n\n\n","category":"module"},{"location":"protosyn-api/internals/#ProtoSyn.GMX","page":"Internals","title":"ProtoSyn.GMX","text":"GMX (Module)\n\nHolds utilitary methods for preparing and launching GROMCAS simulations.\n\n\n\n\n\n","category":"module"},{"location":"protosyn-api/internals/#ProtoSyn.Peptides.GMX","page":"Internals","title":"ProtoSyn.Peptides.GMX","text":"GMX (module)\n\nHolds auxiliary methods for generating .itp, .top and other necessary files for GROMACS simulations.\n\n\n\n\n\n","category":"module"},{"location":"protosyn-api/internals/#ProtoSyn.GMX.check_installation","page":"Internals","title":"ProtoSyn.GMX.check_installation","text":"check_installation()\n\nChecks the current machine for necessary packages: gmx, antechamber & acpype. Make sure these programs are in the system's PATH.\n\nExamples\n\njulia> ProtoSyn.GMX.check_installation()\n✓ All necessary packages were found!\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Calculators.neighbours","page":"Internals","title":"ProtoSyn.Calculators.neighbours","text":"neighbours(verlet_list::VerletList, atom_index::Int)\n\nReturn a list of the neighbouring Atom instances of Atom with :index atom_index, according to the provided VerletList verlet_list. \n\nExamples\n\njulia> ProtoSyn.Calculators.neighbours(vl, 1)\n11-element Vector{Int64}:\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n 10\n 11\n 12\n 13\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.Calculators.Restraints","page":"Internals","title":"ProtoSyn.Calculators.Restraints","text":"module Restraints\n\nContains restraint energy components, such as bond_distance_restraint.\n\n\n\n\n\n","category":"module"},{"location":"protosyn-api/internals/#ProtoSyn.print_diagnose_results","page":"Internals","title":"ProtoSyn.print_diagnose_results","text":"print_diagnose_results(title::String, issues::Vector{String}, init_level_code::LevelCode, level::Int)\n\nPrints a list of issues (under the scop of title grouping) in a stylized way (uses init_level_code and adds inner LevelCode instances at level). \n\nukw: Note:\nThis function is intended to be employed from diagnose, and not as a standalone.\n\nExamples\n\njulia> ProtoSyn.print_diagnose_results(\"Charges\", [\"Missing charges\", \"Charges sum is not 0.0\"], LevelCode(), 4)\n |\n └──  • Charges (2 issues identified)\n      ├── Missing charges\n      └── Charges sum is not 0.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.XMLRPC.ClientProxy","page":"Internals","title":"ProtoSyn.XMLRPC.ClientProxy","text":"ClientProxy(host::String, port::Int)\n\nInstantiate a client proxy listening on hostand  port. This object is meant to act as a proxy to a remote service implementing the XML/RPC protocol, and was designed to work with Python and PyMOL. For more detailed information, please read:\n\nhttps://blog.papercut.com/write-xml-rpc-clients/\n\nhttps://wiki.python.org/moin/XmlRpc\n\nExamples\n\njulia> ProtoSyn.XMLRPC.ClientProxy(\"http://localhost\", 50000)\nProtoSyn.XMLRPC.ClientProxy(\"http://localhost\", 50000, \"http://localhost:50000\")\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/internals/#ProtoSyn.read_yml","page":"Internals","title":"ProtoSyn.read_yml","text":"read_yml(_filename::String)\n\nOpen and read the contents of a .yml file.\n\nExamples\n\njulia> ProtoSyn.read_yml(\"resources/Peptides/grammars.yml\")\nDict{Any, Any} with 2 entries:\n (...)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.gpu_allocation","page":"Internals","title":"ProtoSyn.gpu_allocation","text":"gpu_allocation()\n\nReturn the current fraction of the GPU memory allocated (in range [0, 1]).\n\nExamples\n\njulia> ProtoSyn.gpu_allocation()\n0.07821749405343822\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/internals/#ProtoSyn.promote","page":"Internals","title":"ProtoSyn.promote","text":"promote(sele::AbstractSelection, ::Type{T2}, [aggregator::Function = any]) where {T2 <: AbstractContainer}\n\nReturn a PromoteSelection instance for selection sele, promoting to the requested type T2 <: AbstractContainer. If this is an upwards promotion, use the given aggregator function (default: any).\n\nExamples\n\njulia> ProtoSyn.promote(rn\"ALA\", Atom)\nPromoteSelection ❯ From Residue to Atom\n └── FieldSelection › Residue.name = ALA\n\n\n\n\n\npromote(m1::Mask{T1}, m2::Mask{T2}, container::AbstractContainer) where {T1, T2}\n\nPromote one of the 2 given Masks (m1 and m2) to the lowest ranking common type (Ex. promote(m1::Mask{Residue}, m2::Mask{Atom}) => (Mask{Atom}, Mask{Atom)).\n\nExamples\n\njulia> m1 = an\"CB\"(pose);\n\njulia> m2 = rn\"LEU\"(pose);\n\njulia> ProtoSyn.promote(m1, m2, pose.graph);\n\n\n\n\n\npromote(mask::Mask{T1}, ::Type{T2}, container::AbstractContainer, f::Function = any)::Mask where {T1 <: AbstractContainer, T2 <: AbstractContainer}\n\nCast a Mask of type T1 to be of type T2, in the context of the given container. If casting to a higher ranking type (upwards promotion - Ex. Atom -> Residue), a function f establishes the grouping operation (any occurrence (by default) or all occurrences of lower ranking type must be true to set the higher ranking entry to true.)\n\nExamples\n\njulia> m1 = an\"CB\"(pose);\n\njulia> ProtoSyn.promote(m1, Residue, pose.graph);\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"CurrentModule = ProtoSyn.Peptides.Calculators.Electrostatics","category":"page"},{"location":"protosyn-api/peptides/calculators/electrostatics/#peptides-calculators-electrostatics","page":"Electrostatics","title":"Electrostatics","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"The Peptides module Electrostatics section expands the Core module methods (See Electrostatics) specifically to assign default charges on protein and peptide sequences. ","category":"page"},{"location":"protosyn-api/peptides/calculators/electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"assign_default_charges!","category":"page"},{"location":"protosyn-api/peptides/calculators/electrostatics/#ProtoSyn.Peptides.Calculators.Electrostatics.assign_default_charges!","page":"Electrostatics","title":"ProtoSyn.Peptides.Calculators.Electrostatics.assign_default_charges!","text":"assign_default_charges!(pose::Pose, [res_lib::LGrammar = Peptides.grammar], [selection::Opt{AbstractSelection}]; [supress_warn::Bool = false])\n\nAssign default charges to Pose pose from the given LGrammar res_lib entry, by Atom name. If an AbstractSelection selection is provided, only apply charges to the selected Atom instances. For non-canonical aminoacids and ligands (any Residue without an entry on ProtoSyn.three_2_one dictionary) and any Residue whose template have different Atom names, a warning is shown. Set supress_warn to true to ignore these warnings (false, by default).\n\nukw: Note:\nThis method is an overload of assign_default_charges!. Check it's documentation page for more information. In comparison, this method is specialized for Peptides (automatically identifies terminal atoms and adds correct charges their caps).\n\nSee also\n\nassign_acc2_eem_charges_from_file!\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Electrostatics.assign_default_charges!(pose)\n1143-element Vector{Float64}:\n -0.025115728872692304\n -0.025115728872692304\n -0.025115728872692304\n (...)\n\n\n\n\n\n","category":"function"}]
}
