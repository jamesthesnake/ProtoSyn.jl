var documenterSearchIndex = {"docs":
[{"location":"getting-started/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"ProtoSyn.jl version 1.0 has been developed in tested for Julia 1.5.","category":"page"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"After setting up you Julia installation, open a new REPL and add ProtoSyn.jl using the package manager.","category":"page"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"julia> ] add ProtoSyn.jl","category":"page"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"All Julia-based dependencies should automatically installed/updated. In order to use TorchANI's energy function, you'll also need to install Python with both Torch and TorchANI libraries.","category":"page"},{"location":"getting-started/installation/","page":"Installation","title":"Installation","text":"A visualization macro for PyMOL is included in ProtoSyn's core module, and it's the reccomended visualization tool. ","category":"page"},{"location":"protosyn-api/peptides/calculators/contact-restraint/","page":"Contact Restraint","title":"Contact Restraint","text":"CurrentModule = ProtoSyn.Peptides.Calculators.Restraints","category":"page"},{"location":"protosyn-api/peptides/calculators/contact-restraint/#Contact-Restraint","page":"Contact Restraint","title":"Contact Restraint","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/contact-restraint/","page":"Contact Restraint","title":"Contact Restraint","text":"The Contact Restraint is a potential restraint (See Potential restraints for more details), applying a penalty for pairs of interacting Cα atoms with distances larger than a set value defined in a contact map.","category":"page"},{"location":"protosyn-api/peptides/calculators/contact-restraint/","page":"Contact Restraint","title":"Contact Restraint","text":"get_default_contact_restraint","category":"page"},{"location":"protosyn-api/peptides/calculators/contact-restraint/#ProtoSyn.Peptides.Calculators.Restraints.get_default_contact_restraint","page":"Contact Restraint","title":"ProtoSyn.Peptides.Calculators.Restraints.get_default_contact_restraint","text":"   get_default_contact_restraint(filename::String; α::T = 1.0) where {T <: AbstractFloat}\n\nReturn the default contact map restraint    EnergyFunctionComponent    by reading the given filename. α sets the component weight (on an    EnergyFunction).\n\n!!! ukw \"Note:\"        Since the contact map is fixed, any EnergyFunction containing this EnergyFunctionComponent can only be applied to one protein/sequence (no design). The attached contact map can be re-defined in component.settings[:mask].\n\n!!! ukw \"Note:\"        By default, this EnergyFunctionComponent does not calculate forces, as they would only be applied to the Cα Atom instances. This setting can be re-defined in component.update_forces.\n\nContact energy settings\n\n:d1, :d2, :d3, :d4 -> set each of the distances defining a flat-bottom potential (in Angstrom Å);\n:selection -> defines the atom selection limiting the considered atoms for the calculation; \n:mask -> defines the mask applied to the energy and forces result;\n\nSee also\n\nProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint    ProtoSyn.Calculators.load_map\n\nExamples\n\n```    julia> ProtoSyn.Peptides.Calculators.Restraints.getdefaultcontactrestraint(\"contactmapexample.txt\")    Name : ContactMap    Weight (α) : 1.0 Update forces : false       Setings :            :d4 => 12.0     :selection => FieldSelection › Atom.name = CA\n\n       :d2 => 0.0\n     :mask => Matrix{Float64}((73, 73)\n       :d1 => 0.0\n       :d3 => 8.0\n\n```\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/contact-restraint/","page":"Contact Restraint","title":"Contact Restraint","text":"(Image: ProtoSyn Contact Restraint)","category":"page"},{"location":"protosyn-api/peptides/calculators/contact-restraint/","page":"Contact Restraint","title":"Contact Restraint","text":"Figure 1 | A diagram representation of the Contact Restraint EnergyFunctionComponent. The applied potential is a flat bottom function, with only the upper bound having and energy penatly. The d3 and d4 settings can be customly parametrized. This energy is only calculated for pair of interacting Cα Atom instances (in different Residue instances, as defined the the provided AbstractSelection and mask). The penalty scale is defined in the loaded contact map file.","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/types/#core-types","page":"Types","title":"Types","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"In this section we will explore the main struct instances that compose the core of ProtoSyn's engine, divided in the following topics, for organization purposes:","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Pose\nFragment\nGraph\nState","category":"page"},{"location":"protosyn-api/core/types/#Pose","page":"Types","title":"Pose","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"A pose holds all necessary information regarding a molecular system. This information is divided in the Graph and State .","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Pose","category":"page"},{"location":"protosyn-api/core/types/#ProtoSyn.Pose","page":"Types","title":"ProtoSyn.Pose","text":"Pose{T <: AbstractContainer}(graph::T, state::State)\n\nReturn a Pose instance. A Pose is a complete description of a molecular system  at any given point, having both the interaction graph and the current state of the system coordinates represented. A Pose is typed by an [AbstractContainer], usually a Topology.\n\nPose(::T, frag::Fragment) where {T <: AbstractContainer}\n\nReturn a Pose instance from a Fragment, where the State is empty/blank. The graph contents are copied to the new Pose. If no type T <: AbstractFloat is provided, the Units.defaultFloat will be used.\n\nSee also\n\nFragment\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#Fragment","page":"Types","title":"Fragment","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"ProtoSyn.jl package uses a pose of a single Segment (therefore without a Root) to carry information during certain processes (such as [Building a new peptide from a sequence]).","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Fragment","category":"page"},{"location":"protosyn-api/core/types/#ProtoSyn.Fragment","page":"Types","title":"ProtoSyn.Fragment","text":"Fragment\n\nA Fragment is a type overload for Pose{Segment} and therefore does not contain a root/origin. These are usually used as temporary carriers of information, without the ability to be directly incorporated in simulations.\n\nSee also\n\nfragment\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#graph-types","page":"Types","title":"Graph","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"The birectional graph holds the information regarding the hierarchical organization of a molecular system, where the top level of organization is a Topology instance, which can contain one or more instances of Segment. This structure, in turn, is comprised of one or more Residue instances, which are themselves a set of Atom instances, this being the lowest level of data organization in ProtoSyn.","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"(Image: ProtoSyn graph)","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Topology\nSegment\nResidue","category":"page"},{"location":"protosyn-api/core/types/#ProtoSyn.Topology","page":"Types","title":"ProtoSyn.Topology","text":"Topology <: AbstractContainer{Segment}\nTopology(name::String, id::Int)\n\nConstruct a Topology, with the given name and id. A Topology is the top level of hierarchy in a Graph, and holds a Root Residue, therefore initializing the internal coordinates system in the corresponding [State] of a Pose.  Note: Topology is of super type AbstractTopology, which is an AbstractContainer.\n\nFields\n\nname::String - The name of the Topology\nid::Int - The ID of the Topology\nitems::Vector{Segment} - All the Segment instances in this Topology (default: empty)\nsize::Int - The number of Segment instances in this Topology (default: 0)\nroot::Residue - The root Residue of this Topology\ncontainer::Nothing - Used to identify the root Residue  (default: nothing)\n\nukw: Note:\nWhen in a Pose, both the Topology and the corresponding State need to share the same :id. This is used to identify situations where a change in one of this structures was not reflected on the other.\n\nSee also\n\nroot Segment\n\nExamples\n\njulia> top = Topology(\"UNK\", 1)\nTopology{/UNK:1}\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#ProtoSyn.Segment","page":"Types","title":"ProtoSyn.Segment","text":"Segment <: AbstractContainer{Residue}\nSegment(name::String, id::Int)\n\nConstruct a Segment, with the given name and id. The created segment has no container. A Segment is a group of Residue instances. Note: Segment is of super type AbstractSegment, which is an AbstractContainer.\n\nFields\n\nname::String - The name of the Segment\nid::Int - The ID of the Segment\nindex::Int - The index of the Segment (default: same as :id)\ncode::Char - A 1-letter code for the chain (used in PDB formatting) (default: '?')\nitems::Vector{Residue} - A list of Residue instances in this Segment (default: empty)\ncontainer::Opt{AbstractTopology} - An optional container for this Segment (default: nothing)\nsize::Int - The number of Residue instances in this Segment (default: 0)\n\nSee also\n\nTopology Residue\n\nExamples\n\njulia> res = Segment(\"UNK\", 1)\nSegment{/UNK:1}\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#ProtoSyn.Residue","page":"Types","title":"ProtoSyn.Residue","text":"Residue <: AbstractContainer{Atom}\nResidue(name::String, id::Int)\n\nConstruct a Residue, with the given name and id. The created residue has no container; it is also a free directed-graph node (no parent/children). A Residue is a group of Atom instances. Note: Residue is of super type AbstractResidue, which is an AbstractContainer.\n\nFields\n\nname::ResidueName - The name of the Residue\nid::Int - The ID of the Residue\nindex::Int - The index of the Residue (default: same as :id)\nitems::Vector{Atom} - A list of Atom instances in this Residue (default: empty)\nitemsbyname::Dict{String, Atom} - A Dict object containing a link to each of the Atom instances in this Residue bsed on the :name of the Atom (default: empty)\ncontainer::Opt{AbstractSegment} - An optional container for this Residue (default: nothing)\nsize::Int - The number of Atom instances in this Residue (default: 0)\nvisited::Bool - Check whether this Residue has been visited (used by a some functions) (default: false)\nparent::Opt{Residue} - Optionally, the parent of this Residue in the directional graph (default: nothing)\nchildren::Vector{Residue} - Optionally, the list of children Residue instances downstream of this Residue (default: empty)\nascedents::Opt{NTuple{4, Int}} - Optionally, the list of 4 ascendents, including this Residue (default: nothing)\n\nSee also\n\nSegment Atom ascendents ResidueName\n\nExamples\n\njulia> res = Residue(\"UNK\", 1)\nResidue{/UNK:1}\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"ukw: Note:\nInstead of defining Residue.name as a String, ProtoSyn uses a specific type (ResidueName) to accomodate specific conventions in aminoacid naming.","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"ProtoSyn.ResidueName\nAtom","category":"page"},{"location":"protosyn-api/core/types/#ProtoSyn.ResidueName","page":"Types","title":"ProtoSyn.ResidueName","text":"ResidueName(s::String) <: AbstractString\n\nA string overload to accomodate different known and expected denominations of certain residues (\"HIS\" == \"HIE\" for example).\n\nExample\n\njulia> ProtoSyn.ResidueName(\"HIS\")\nHIS\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#ProtoSyn.Atom","page":"Types","title":"ProtoSyn.Atom","text":"Atom <: AbstractContainer{Nothing}\n\nAn Atom type.\n\nAtom(name::String, id::Int, index::Int, symbol::String)\n\nConstruct an Atom, with the given name, id, index, and symbol. The created atom has no bonds and container; it is also a free directed-graph node (no parent/children). Note: Atom is of super type AbstractAtom, which is an AbstractContainer.\n\nFields\n\nname::String - The name of the Atom\nid::Int - The ID of the Atom\nindex::Int - The index of the Atom (default: same as :id)\nsymbol::String - The chemical element symbol of this Atom\nbonds::Vector{Atom} - A list of Atom instances connected to this Atom by a bond (default: empty)\ncontainer::Opt{AbstractResidue} - An optional container for this Atom (default: nothing)\nvisited::Bool - Check whether this Atom has been visited (used by a some functions) (default: false)\nparent::Opt{Atom} - Optionally, the parent of this Atom in the directional graph (default: nothing)\nchildren::Vector{Atom} - Optionally, the list of children Atom instances downstream of this Atom (default: empty)\nascedents::Opt{NTuple{4, Int}} - Optionally, the list of 4 ascendents, including this Atom (default: nothing)\n\nSee also\n\nResidue [ascendents]\n\nExamples\n\njulia> at = Atom(\"H1\", 1, 1, \"H\")\nAtom{/H1:1}\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#state-types","page":"Types","title":"State","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"A State structure is responsible for holding the current state of the internal and cartesian coordinates, as well as the forces felt on each atom and the resulting energy of the system (as calculated by an [EnergyFunction]). This structure is sub-divided in a list of AtomState instances and a StateMatrix. Both of these structures are complementary, meaning that any change in one in synched in the other. While AtomState instances hold both the internal and cartesian coordinates relative to a single Atom, StateMatrix is a 2D matrix of all cartesian coordinates of the atoms in a given Pose.","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"State\nAtomState\nStateMatrix","category":"page"},{"location":"protosyn-api/core/types/#ProtoSyn.State","page":"Types","title":"ProtoSyn.State","text":"State([::T]) where {T <: AbstractFloat}\n\nA State is a complete representation of a given molecular system regarding the position, the forces felt and the resulting energetic contribution by each atom. Each AtomState in a system.\n\nState([::T], n::Int) where {T <: AbstractFloat}\n\nReturn a State with size n, with all items set to be an empty AtomState.\n\nState([::T], items::Vector{AtomState{T}}) where {T <: AbstractFloat}\n\nReturn a State with size length(items), with all the given items.\n\nukw: Note:\nIf no type T <: AbstractFloat is provided, Units.defaultFloat will be used.\n\nFields\n\nitems::Vector{AtomState{T}} - The list of AtomState instances in this State (default: empty)\nsize::Int - The number of AtomState instances in this State (default: 0)\nid::Int - The Id (to be matched to the corresponding Topology in a Pose) (default: -1)\ni2c::Bool - Flag indicating this State needs to be synched to cartesian coordinates (default: false)\nc2i::Bool - Flag indicating this State needs to be synched to internal coordinates (default: false)\nindex_offset::Int - Ignore the first N AtomState instances (default: 3)\nx::StateMatrix{T} - The cartesian coordinate matrix of all AtomState instances in this State (default: empty)\nf::Matrix{T} - The force matrix of all AtomState instances in this State (default: empty)\ne::Dict{Symbol, T} - The list of all energetic components evaluated for this State (default: empty)\n\nSee also\n\nTopology AtomState StateMatrix\n\nExamples\n\njulia> State(4)\nState{Float64}:\n Size: 4\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#ProtoSyn.AtomState","page":"Types","title":"ProtoSyn.AtomState","text":"AtomState{T}(parent::Any, index::Int, t::MVector{3, T}, r::MMatrix{3, 3, T, 9}, b::T, θ::T, ϕ::T, Δϕ::T, changed::Bool) where {T <: AbstractFloat}\n\nAn AtomState instance. Holds information regarding the state of the atom, including the cartesian and internal coordinates.\n\nAtomState([::T]) where {T <: AbstractFloat}\n\nReturn an empty AtomState instance, with all default values.\n\nukw: Note:\nIf no type T <: AbstractFloat is provided, Units.defaultFloat will be used.\n\nukw: Note:\nChanging this AtomState cartesian coordinates will update and sync changes with a sibling StateMatrix, as long as this structs parent is correctly set.\n\nFields\n\nparent::Any - If set, should point to the parent State containing this AtomState (default: nothing)\nindex::Int - the index of this AtomState\nt::MVector{3, T} - The translation vector from origin (cartesian coordinates) (default: empty)\nr::MMatrix{3, 3, T, 9} - The rotation matrix for cartesian to internal coordinate sync (default: empty)\nb::T - Distance (in Angstrom Å) to parent atom (default: 0)\nθ::T - Angle (in radians) to ascendent atoms (default: 0)\nϕ::T - Dihedral angle (in radians) to ascendent atoms (default: 0)\nΔϕ::T - Dihedral angle change (in radians) to be applied to children atoms (default: 0)\nchanged::Bool - Flag indicating whether this AtomState has been modified (useful in some functions such as i2c! and c2i!) (default: false)\n\nukw: Note:\nThe Δϕ field in AtomState allows for easy set-up of dihedral angles in molecular structures. By modifying Δϕ in an atom, all child atoms will be rotated by the same amount, even in being branched structures.\n\nSee also\n\nState StateMatrix\n\nExamples\n\njulia> AtomState()\nAtomState{Float64}:\n Index: -1\n T: [0.000, 0.000, 0.000]\n b: 0.000 Å | θ:  0.000 rad (   0.00°) | ϕ:  0.000 rad (   0.00°) | Δϕ:  0.000 rad (   0.00°)\n Changed: false\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#ProtoSyn.StateMatrix","page":"Types","title":"ProtoSyn.StateMatrix","text":"StateMatrix{T}(parent::Any, coords::Matrix{T}) where {T <: AbstractFloat}\n\nA StateMatrix instance holds the cartesian coordinates of all AtomState instances in a State. It is an overload of a Matrix struct, and used to efficiently apply substantial changes to a system or a large number of atoms. \n\nukw: Note:\nIf no type T <: AbstractFloat is provided, Units.defaultFloat will be used.\n\nukw: Note:\nChanging this StateMatrix cartesian coordinates will update and sync changes with a sibling AtomState, as long as this structs parent is correctly set. In such case, the parent.c2i flag is also set to true.\n\nFields\n\nparent::Any - If set, should point to the parent State containing this StateMatrix (default: nothing)\ncoords::Matrix - The cartesian coordinates matrix\n\nSee also\n\nState AtomState\n\nExamples\n\njulia> StateMatrix(zeros(3, 3))\nStateMatrix{Float64}:\n Parent set: false\n3×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/types/#Array-of-Structures-vs-Structure-of-Arrays","page":"Types","title":"Array of Structures vs Structure of Arrays","text":"","category":"section"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Given this organization of cartesian coordinates in a Pose, a decades old dilemma naturally emerges: should the data be organized in Array of Structures or in a Structure of Arrays. The differences are illustrated bellow:","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Structure of Arrays (SoA) - The main object is a single structure which holds a vector for each of the coordinates of all Atom instances. Each coordinate vector of all Atom instances is contiguous in memory.\nArray of Structures (AoS) - The main object is a vector of Atom instances, where each Atom structure holds a field for each coordinate. Each Atom set of coordinates is contiguous in memory.","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"(Image: ProtoSyn Energy Function)","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Figure 1 | Visualization of Atom instances organization in memory: Structure of Arrays (SoA) vs Array of Structures (AoS). In one hand, when employing the Structure of Arrays (SoA) paradigm, memory is contiguous when accessing all the X coordinates of each Atom instance (for example). On the other hand, when employing the Array of Structures (AoS) paradigm, memory is contiguous when accessing all the X, Y and Z coordinates of a single atom (or adjacently indexed atoms).","category":"page"},{"location":"protosyn-api/core/types/","page":"Types","title":"Types","text":"Given that Julia is a column major programming language and based on performance benchmarks during early development cycles, ProtoSyn is developed using the Array of Structures (AoS) paradigm (each State contains an array of structures AtomState).","category":"page"},{"location":"protosyn-api/peptides/calculators/sidechain-clash-restraint/","page":"Sidechain Clash Restraint","title":"Sidechain Clash Restraint","text":"CurrentModule = ProtoSyn.Peptides.Calculators.Restraints","category":"page"},{"location":"protosyn-api/peptides/calculators/sidechain-clash-restraint/#Sidechain-Clash-Restraint","page":"Sidechain Clash Restraint","title":"Sidechain Clash Restraint","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/sidechain-clash-restraint/","page":"Sidechain Clash Restraint","title":"Sidechain Clash Restraint","text":"The Sidechain Clash Restraint is a potential restraint (See Potential restraints for more details), applying a penalty for pairs of interacting atoms (belonging to different sidechains) with distances under a given threshold.","category":"page"},{"location":"protosyn-api/peptides/calculators/sidechain-clash-restraint/","page":"Sidechain Clash Restraint","title":"Sidechain Clash Restraint","text":"get_default_sidechain_clash_restraint","category":"page"},{"location":"protosyn-api/peptides/calculators/sidechain-clash-restraint/#ProtoSyn.Peptides.Calculators.Restraints.get_default_sidechain_clash_restraint","page":"Sidechain Clash Restraint","title":"ProtoSyn.Peptides.Calculators.Restraints.get_default_sidechain_clash_restraint","text":"get_default_sidechain_clash_restraint(;α::T = 1.0, mask::Opt{ProtoSyn.Mask} = nothing) where {T <: AbstractFloat}\n\nReturn the default sidechain clash restraint EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). If a mask is provided, the component will apply that mask every calculation (fixed mask) - recommended, except for design efforts. Otherwise, the default get_intra_residue_mask function will be used, which calculates a new intra-residue mask every calculation.\n\nSidechain clash energy settings\n\n:d1, :d2, :d3, :d4 -> set each of the distances defining a flat-bottom potential (in Angstrom Å);\n:selection -> defines the atom selection limiting the considered atoms for the calculation; \n:mask -> defines the mask applied to the energy and forces result;\n\nSee also\n\nProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint ProtoSyn.Calculators.get_intra_residue_mask\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Restraints.get_default_sidechain_clash_restraint()\n     Name : Clash_Sidechain_Restraint\nWeight(α) : 1.0\n Settings :\n            :d4 => Inf\n            :selection => UnarySelection ❯ ! \"not\" (Atom)\n                          └── FieldSelection › Atom.name = r\"^CA$|^N$|^C$|^H$|^O$\"\n            :d2 => 1.5\n          :mask => _intra_residue_mask\n            :d1 => 1.0\n            :d3 => Inf\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/sidechain-clash-restraint/","page":"Sidechain Clash Restraint","title":"Sidechain Clash Restraint","text":"(Image: ProtoSyn Sidechain Clash Restraint)","category":"page"},{"location":"protosyn-api/peptides/calculators/sidechain-clash-restraint/","page":"Sidechain Clash Restraint","title":"Sidechain Clash Restraint","text":"Figure 1 | A diagram representation of the Sidechain Clash Restraint EnergyFunctionComponent. The applied potential is a flat bottom function, with only the lower bound having and energy penatly. The d1 and d2 settings can be customly parametrized. This energy is only calculated for pair of interacting Atom instances in sidechains of different Residue instances (as defined the the provided AbstractSelection and mask).","category":"page"},{"location":"protosyn-api/core/submodules/builder/#core-builder","page":"Builder","title":"Builder","text":"","category":"section"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"The Builder is a submodule of ProtoSyn.Core module. As such, the following core introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"The following sections offer a more in-depth view of the available types and methods for building molecular structures from template libraries:","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"Defining and loading a Stochastic L-Grammar\nBuilding a molecular structure\nManipulating a molecular structure by adding new residues from templates","category":"page"},{"location":"protosyn-api/core/submodules/builder/#core-builder-1","page":"Builder","title":"Defining and loading a Stochastic L-Grammar","text":"","category":"section"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"A core feature of ProtoSyn is the generation of structures from scratch, using residue templates as building blocks for complex structures. The Builder submodule introduces this functionality by providing support for Stochastic L-grammars. As a succint summary, L-grammar systems provide a simple syntax to encode rather complex structures, supporting ramifications (as in carbohydrates and glycoproteins) and random generation of compositions by stochastic rules.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"In ProtoSyn, several different L-Grammar systems are provided, based on the type of variables. For example, in the Peptides module, a peptide-based L-Grammar is made available, where the alphabet/variables are the 20 natural aminoacids. In this case, since peptides are a linear chain, there isn't a stochastic rule: each aminoacid, when expanded, simply returns itself. Finally, the main operator (α) is a peptidic bond generator, connecting two residues in a row. Therefore, as an example of employment of Peptides L-Grammar, the string \"GME\" could be easily expanded and built into a 3D structure of 3 aminoacids: Glycine-Methionine-Glutamic Acid, connected by peptidic bonds.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"ukw: Note:\nSince L-grammars are specific for a given type/family of molecules, no default grammar is provided by ProtoSyn.Core module. The following examples and details are discussed by using the Peptides default L-grammar. ","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"(Image: ProtoSyn L-grammar)","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"Figure 1 | A diagram representation of the Peptides default L-grammar. Any L-grammar in ProtoSyn is composed of 3 elements: [1] a variables library containing the templates of all the building blocks available. Each variable is a complete description of all internal associations between Atom instances (Bonds and Parenthood relationships) as well as all internal coordinates). This information, once loaded, forms an independent Fragment object and is indexed by a :name or a :code. In the case of the Peptides L-Grammar, there are 20 variables, one for each of the 20 natural aminoacids; [2] one or more operators, describing bridging connections between 2 of the L-Grammar variables. These, once loaded, return a function that bonds (and applies the correct Parenthood relationships) the requested Atom instances, while also applying specific internal coordinates to the involved Atom instances. In the case of the Peptides L-Grammar, the only available operator describes a peptidic bond; [3] optionally, a set of stochastic rules for choosing an operator. ProtoSyn employs stochastic rules for choosing what operator to apply to any 2 given templates, meaning that different operators can be randomly applied based on a set of weights, generating complex structures in a random way, if desired. In the case of the Peptides L-grammar, such rules are not applied, since there is only 1 operator to be applied.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"As previously explored, ProtoSyn supports Stochastic L-Grammar structures for defining semi-random and ramified molecular structures. The following types and methods explore how this is achieved in more detail.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"LGrammar\nStochasticRule\nload_grammar_from_file","category":"page"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.LGrammar","page":"Builder","title":"ProtoSyn.LGrammar","text":"LGrammar{T <: AbstractFloat, K, V}(rules::Dict{K, Vector{StochasticRule{K,V}}}, variables::Dict{K, Fragment}, operators::Dict{K, Function}, defop::Opt{Function})\n\nAn LGrammar instance. Holds information regarding a stochastic L-Grammar system, made up of a set of variables connectable by one or more operators. Optionally, stochastic rules can randomly pick the operator to apply, based on a set of weights.\n\nLGrammar{T, K, V}() where {T <: AbstractFloat, K, V}\n\nReturn an empty LGrammar instance.\n\nFields:\n\nrules::Dict{K, Vector{StochasticRule{K,V}}} - A dictionary of StochasticRule instances indexed by the variable key over which the given rule will operate; \nvariables::Dict{K, Fragment} - A dictionary of variables (Fragment templates) indexed by the corresponding code;\noperators::Dict{K, Function} - A dictionary of operator Function instances indexed by a named String;\ndefop::Opt{Function} - Default operator. If no operator is described in the given derivation (during the build process), uses this operator.\n\nSee also\n\nStochasticRule build load_grammar_from_file\n\nukw: Note:\nAs a general rule, LGrammar instances are loaded from an .YML file (using the load_grammar_from_file method). Check this entry for a more in-depth description of the file format.\n\nExamples\n\njulia> grammar = LGrammar{Float64, String, Vector{String}}()\nLGrammar{Float64, String, Vector{String}}:\n Rules: None.\n Variables: None.\n Operators: None.\n\njulia> grammar = ProtoSyn.Peptides.grammar()\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.StochasticRule","page":"Builder","title":"ProtoSyn.StochasticRule","text":"StochasticRule(p::T, rule::Pair{K, V}) where {T <: AbstractFloat, K, V}\n\nReturn a new StochasticRule instance with the given probability of occurrence p. The rule is a Pair{K, V} where in most cases K is an instance of type String (i.e.: a Key) and V is an instance of type Vector{String} (i.e.: a Vector of instructions). These are also called of  \"production instructions\" and define the result of deriving the given \"key\" in any derivation. As an example, the pair \"A\" => [\"A\", \"ɑ\", \"A\"] would be interpreted upon derivation, and the entry A would be expanded to AA, where both new A instances are joined by the ɑ operator, with a probability of occurrence of p.\n\nFields\n\np::T - The probability of occurrence;\nsource::K - The key of the rule on this StochasticRule instance;\nproduction::V - The resulting vector of the derivation of this StochasticRule instance on the given source.\n\nSee also\n\nLGrammar\n\nExamples\n\njulia> sr = StochasticRule(1.0, \"A\" => [\"A\", \"ɑ\", \"A\"])\nA(p=1.0) -> [\"A\", \"ɑ\", \"A\"]\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.load_grammar_from_file","page":"Builder","title":"ProtoSyn.load_grammar_from_file","text":"load_grammar_from_file([::Type{T}], filename::AbstractString, key::String; [verbose::Bool = true]) where {T <: AbstractFloat}\n\nCreate an LGrammar instance from the contents of a grammar file (in .YML format) under the key entry. The file contents are parsed by the lgfactory method. Any numerical entry is parsed to the provided type T (or Units.defaultFloat if no type is provided). Return the parsed LGrammar instance. If verbose is set to true (is, by default), print the loading status.\n\nSee also\n\nLGrammar lgfactory\n\nExamples\n\njulia> lgrammar = load_grammar_from_file(Float64, filename, \"peptide\")\n\njulia> lgrammar = load_grammar_from_file(filename, \"peptide\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"(Image: ProtoSyn L-grammar)","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"Figure 2 | An exploration of the .YML file format describing a new LGrammar instance (and loaded by the load_grammar_from_file method). Templates for the variables entry can be in any of the supported formats by ProtoSyn (such as .YML and .PDB). Usually .YML formats are employed, since extra information such as the Parenthood relationships between intra-residue atoms can be easily included. ProtoSyn is able to parse certain unit symbols, such as the degree symbol (°). Otherwise, the default units are in radians.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"lgfactory\nProtoSyn.opfactory","category":"page"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.lgfactory","page":"Builder","title":"ProtoSyn.lgfactory","text":"lgfactory([::Type{T}], template::Dict) where {T <: AbstractFloat}\n\nCreate an LGrammar instance from the contencts of a template Dict (normally read from a grammar file). Any numerical entry is parsed to the provided type T (or Units.defaultFloat if no type is provided). The operators entry is parsed by the opfactory method. Return the parsed LGrammar instance. If verbose is set to true (is, by default), print the loading status.\n\nSee also\n\nLGrammar load_grammar_from_file opfactory\n\nukw: Note:\nThis is an internal method of ProtoSyn and shouldn't normally be used directly.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.opfactory","page":"Builder","title":"ProtoSyn.opfactory","text":"opfactory(args::Any)\n\nReturn the operation function (as a closure) given the input arguments args (normally read from a grammar file). \n\nSee also\n\nlgfactory\n\nukw: Note:\nThe resulting operation function is responsible for setting the internal coordinates of residues in the system when connecting, building and manipulating poses.\n\nukw: Note:\nThis is an internal method of ProtoSyn and shouldn't normally be used directly.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/builder/#core-builder-2","page":"Builder","title":"Building a molecular structure","text":"","category":"section"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"The main goal of an L-Grammar in ProtoSyn is to facilitate building a molecular structure from a sequence by joining together template variables as building blocks. A vector of codes describes the desired structure. In the case of Peptides, for example, this is simply a linear sequence of aminoacids, while more complex structures, such as ramified carbohydrates or glycoproteins might have an equally more complex vector of codes. The following methods explore further on how to use ProtoSyn's L-Grammar system to build new molecular structures from a template libraries.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"@seq_str\nfragment(::LGrammar{T, K, V}, ::Any) where {T <: AbstractFloat, K, V}\nbuild","category":"page"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.@seq_str","page":"Builder","title":"ProtoSyn.@seq_str","text":"@seq_str(s::String)\n\nConstruct a vector of strings from the provided string. Helpful when providing a derivation to any building method (such as build).\n\nShort syntax\n\nseq\"...\"\n\nExamples\n\njulia> seq\"ABC\"\n3-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n\n\n\n\n\n","category":"macro"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.fragment-Union{Tuple{V}, Tuple{K}, Tuple{T}, Tuple{LGrammar{T, K, V}, Any}} where {T<:AbstractFloat, K, V}","page":"Builder","title":"ProtoSyn.fragment","text":"fragment(grammar::LGrammar{T, K, V}, derivation) where {T <: AbstractFloat, K, V}\n\nCreate and return a new Fragment (Pose instance with just a single Segment) using the given derivation sequence on the provided LGrammar grammar instructions. The main purpose of fragments is to be temporary carriers of information, such as during the building process of a new peptide from a sequence. Therefore, these structures often don't have any real meaning and are, as such, deprived of a root/origin for the graph. Actual structures should instead be of the slightly more complete type Pose.\n\nSee also\n\nbuild\n\nExamples\n\njulia> frag = fragment(res_lib, seq\"AAA\")\nFragment(Segment{/UNK:63875}, State{Float64}:\n Size: 30\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.build","page":"Builder","title":"ProtoSyn.build","text":"build(grammar::LGrammar{T}, derivation)\n\nBuild a new Pose instance using the given derivation sequence on the provided LGrammar grammar instructions. Return the generated Pose after synching (using the sync! method).\n\nSee Also\n\nfragment\n\nExamples\n\njulia> res_lib = ProtoSyn.Peptides.grammar(Float64);\n\njulia> pose = ProtoSyn.build(res_lib, seq\"GME\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 39\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/builder/#core-builder-3","page":"Builder","title":"Manipulating a molecular structure by adding new residues from templates","text":"","category":"section"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"Once built (or loaded), a molecular structure can be manipulated and changed in various ways. Several methods available to add, modify and remove Residue instances from a molecular structure are discussed in the following section. The Builder submodule also includes methods allowing the insertion of template residues from a sequence of vector of codes.","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"append_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Any; ::Any)\ninsert_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Any; ::Any, ::Bool)","category":"page"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.append_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Any}","page":"Builder","title":"ProtoSyn.append_fragment!","text":"append_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation; op::Any = \"α\")\n\nBased on the provided grammar, add the residue sequence from derivation to the given Pose pose, appending it after the given Residue residue. This residue and the new Fragment will be connected using operation op (\"α\" by default). Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nSee also\n\ninsert_fragment!\n\nExamples\n\njldoctest julia> ProtoSyn.append_fragment!(pose, pose.graph[1][36], res_lib, seq\"MMM\") Pose{Topology}(Topology{/2a3d:532}, State{Float64}:  Size: 628  i2c: true | c2i: false  Energy: Dict(:Total => Inf) )\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/builder/#ProtoSyn.insert_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Any}","page":"Builder","title":"ProtoSyn.insert_fragment!","text":"insert_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation; op::Any = \"α\", connect_upstream::Bool = true)\n\nBased on the provided grammar, add the residue sequence from derivation to the given pose, inserting it on the position of the given Residue instance residue (the residue gets shifted downstream). The first downstream Residue and the new Fragment will be connected using operation op (\"α\" by default). If connect_upstream is set to true (is, by default), also connect to the upstream Residue instances using the same operation op. Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nSee also\n\nappend_fragment!\n\nExamples\n\njulia> ProtoSyn.unbond!(pose, pose.graph[1][1][\"C\"], pose.graph[1, 2, \"N\"])\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.insert_fragment!(pose, pose.graph[1][2], res_lib, seq\"A\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 353\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"(Image: ProtoSyn Manipulation)","category":"page"},{"location":"protosyn-api/core/submodules/builder/","page":"Builder","title":"Builder","text":"Figure 3 | Some examples of the application of molecular manipulation methods: [1] Appending Residue instances at the end of a Segment using the append_fragment! method; [2] Adding Residue instances at the center and [3] at the beggining of an existing Segment, using the insert_fragment! method. In the schematic representation of the molecular structure, R denotes the Topology root.","category":"page"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/peptides/types/#peptides-types","page":"Types","title":"Types","text":"","category":"section"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"The Peptides module introduces two main types: the Dihedral and the Secondary Structure. In the next section, a more in depth exploration of the usage and utility of each of these types is provided, divided in the following subsections for organization purposes:","category":"page"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"Dihedral\nSecondary Structure","category":"page"},{"location":"protosyn-api/peptides/types/#Dihedral","page":"Types","title":"Dihedral","text":"","category":"section"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"The Dihedral struct allows a user to select a given dihedral in a Pose by it's name in the context of a protein structure (i.e.: select the \"phi\" dihedral or the \"chi-2\" dihedral). This is programmed as a Julia module for sugar syntax.","category":"page"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"ProtoSyn.Peptides.Dihedral","category":"page"},{"location":"protosyn-api/peptides/types/#ProtoSyn.Peptides.Dihedral","page":"Types","title":"ProtoSyn.Peptides.Dihedral","text":"Dihedral\n\nAn auxiliary struct for Dihedral selection by name. Each of the available dihedrals (under the abstract type DihedralType, see bellow) can be called using the following signature, returning the respective representative atom:\n\n(dihedral::DihedralType)(residue::Residue)\n\nAvailable dihedrals\n\nDihedral.phi Dihedral.psi Dihedral.omega Dihedral.chi1 Dihedral.chi2 Dihedral.chi3 Dihedral.chi4\n\nExamples\n\njulia> ProtoSyn.Peptides.Dihedral.phi(pose.graph[1][1])\nAtom{/UNK:1/UNK:1/SER:1/C:10}\n\njulia> atom = ProtoSyn.Peptides.Dihedral.chi2(pose.graph[1][2])\nAtom{/UNK:1/UNK:1/GLU:2/CD:22}\n\njulia> ProtoSyn.getdihedral(pose.state, atom)\n-3.141165\n\n\n\n\n\n","category":"module"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"(Image: ProtoSyn Chi Dihedral Atoms)","category":"page"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"Figure 1 | In ProtoSyn, peptide atoms are named according to the IUPAC and Protein Data Bank nomeculature (see the Atomic Coordinate and Bibliographic Entry Format Description - page 26). As such, in the table above, the names of the representative atoms of each chi angle are shown. These are the atoms returned by the call to the Dihedral auxiliary struct, and can be used in other functions, such as getdihedral or setdihedral!.","category":"page"},{"location":"protosyn-api/peptides/types/#Secondary-Structure","page":"Types","title":"Secondary Structure","text":"","category":"section"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"The following types allow the maintenance of Secondary Structure information (i.e.: the psi, psi and omega backbone angles that result in any given Secondary Structure, such as an alpha helix or a beta sheet, for example).","category":"page"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"SecondaryStructureTemplate\nSecondaryStructure","category":"page"},{"location":"protosyn-api/peptides/types/#ProtoSyn.Peptides.SecondaryStructureTemplate","page":"Types","title":"ProtoSyn.Peptides.SecondaryStructureTemplate","text":"SecondaryStructureTemplate{T}(ϕ::T, ψ::T, ω::T) where {T <: AbstractFloat}\n\nReturn a new SecondaryStructureTemplate with the given phi ϕ, psi ψ and omega ω backbone angles (in radians).\n\nExamples\n\njulia> t = ProtoSyn.Peptides.SecondaryStructureTemplate(-60°, -45°, 180°)\nSecondary Structure Template:\n └─ Phi (ϕ):  -1.047 rad | Psi (ψ):  -0.785 rad | Omega (ω):   3.142 rad\n             -60.000 deg |          -45.000 deg |            180.000 deg\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/types/#ProtoSyn.Peptides.SecondaryStructure","page":"Types","title":"ProtoSyn.Peptides.SecondaryStructure","text":"SecondaryStructure\n\nThis constant holds default values for common SecondaryStructureTemplate instances: :helix, :linear, :parallel_sheet and :antiparallel_sheet.\n\nExamples\n\njulia> t = ProtoSyn.Peptides.SecondaryStructure[:helix]\nSecondary Structure Template:\n └─ Phi (ϕ):  -1.047 rad | Psi (ψ):  -0.785 rad | Omega (ω):   3.142 rad\n             -60.000 deg |          -45.000 deg |            180.000 deg\n\n\n\n\n\n","category":"constant"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"(Image: ProtoSyn Backbone SS)","category":"page"},{"location":"protosyn-api/peptides/types/","page":"Types","title":"Types","text":"Figure 2 | The default SecondaryStructureTemplate instances in ProtoSyn, defined in the SecondaryStructure dictionary. A SecondaryStructureTemplate can be applied to a Pose, for example, using the setss! method.","category":"page"},{"location":"protosyn-api/materials/introduction/#Materials","page":"Introduction","title":"Materials","text":"","category":"section"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"Besides the Core module, ProtoSyn comes with several other extra modules that build on top of and expand the base methods, types and submodules. These ProtoSyn modules are specific for a given topic. In the case of the Materials module, all new or expanded methods and types explore the topic of atom lattices, MOFs, etc. With this extra constraint, most methods can be especialized.","category":"page"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"In sum, the Materials module makes available several methods, types and submodules specific for atom lattices and other atomic material structures.","category":"page"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"ukw: Note:\n🛠 Under construction. This module is not finished: several bugs and incomplete features can be found. The existing code is provided as is, and should be mainly used for further improvement and development.","category":"page"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"In order to use this module, including the following call is often useful:","category":"page"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn","category":"page"},{"location":"protosyn-api/materials/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn.Materials","category":"page"},{"location":"protosyn-api/peptides/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/methods/io/#peptides-io","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"The following methods allow the user to load and export models and data from and to files, and build on top of the Core methods (See Input and Output (IO)).","category":"page"},{"location":"protosyn-api/peptides/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"load","category":"page"},{"location":"protosyn-api/peptides/methods/io/#ProtoSyn.Peptides.load","page":"Input and Output (IO)","title":"ProtoSyn.Peptides.load","text":"load([::Type{T}], filename::AbstractString; bonds_by_distance::Bool = false) where {T <: AbstractFloat}\n\nLoad the given filename into a Pose, parametrized by T. If this is not provided, the default ProtoSyn.Units.defaultFloat is used instead. The file format is infered from the extension (Supported: .pdb, .yml). If bonds_by_distance is set to true (false, by default), the CONECT records will be complemented with bonds infered by distance. The threshold distances for each pair of atoms is defined in ProtoSyn.bond_lengths. Infers parenthood and ascedence from bonds (N-Residue instances have the connected C-Residue as child).\n\nukw: Note:\nThis function is an extension of ProtoSyn.load.\n\nExamples\n\njulia> ProtoSyn.Peptides.load(\"1ctf.pdb\", bonds_by_distance = true)\nPose{Topology}(Topology{/2a3d:61708}, State{Float64}:\n Size: 1140\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"CurrentModule = ProtoSyn.Calculators","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#Calculators-section","page":"Calculators Section","title":"Calculators section","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Each module in ProtoSyn may contain a Calculators section which contains types and methods that allow ProtoSyn to measure the fitness of a given State, according to a specific EnergyFunction instance. The resulting energy value is stored in the State.e field, as a Dictionary of EnergyFunctionComponent instances. The :total energy of the system is the sum of each component contribution. Each module in ProtoSyn (such as the Peptides module) adds new components and methods specific of that module. As a starting point, the Core module sets up all necessary types and methods transversal to all modules, as well as a few basic energetic components. In the next section, a further exploration on how to develop and set-up custom EnergyFunction instances is provided, organized in the following sections:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Energy functions & energy function components\nCreating a custom EnergyFunctionComponent\nProtoSyn acceleration types\nVerlet lists\nDistance matrix calculation\nAvailable EnergyFunctionComponents","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#Energy-functions-and-energy-function-components","page":"Calculators Section","title":"Energy functions & energy function components","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"An EnergyFunction is the main high-level object of ProtoSyn for energy calculation of a Pose instance, whose building blocks are the EnergyFunctionComponent instances.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Calculators.EnergyFunctionComponent\nCalculators.EnergyFunction","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.EnergyFunctionComponent","page":"Calculators Section","title":"ProtoSyn.Calculators.EnergyFunctionComponent","text":"EnergyFunctionComponent(name::String, calc::Function, settings::Dict{Symbol, Any}, α::T, update_forces::Bool)\n\nReturn a new EnergyFunctionComponent instance with the given name. An EnergyFunctionComponent object is responsible to calculate an energetic contribution to the system, based on a given interaction, model or restraint (for example, a Bond Distance Restraint is responsible to calculate the energetic contribution by bonds with lengths superior to a given threshold). The :total energy of a Pose is, therefore, the sum of all EnergyFunctionComponent applied in a given calculation. Each  EnergyFunctionComponent has a calc Function that receives a Pose and outputs an energy value. Optionally, this calc Function can also return a set of forces felt on all considered atoms, based on the potential or model used, which is calculated if the update_forces flag is set to true. For a more detailed explanation see the Creating a custom EnergyFunctionComponent section of the documentation). Additionally, certain EnergyFunctionComponent instances can have a settings dictionary, containing kwargs that are passed to the calc Function. These usually parametrize and fine tune the calculations perform (such as setting the flat bottom restraint distances, as an example). When calling an EnergyFunctionComponent calculation from an EnergyFunction, the relative weight of this EnergyFunctionComponent in relation to others is given by the α field.\n\nFields\n\nname::String - The name of this EnergyFunctionComponent. Used to index by name when in an EnergyFunction;\ncalc::Function - The calculation Function used to calculate this contribution;\nsettings::Dict{Symbol, Any} - (Optional) A dictionary of kwargs provided to the calc Function, parameterizing its usage;\nα::T - The relative weight of this EnergyFunctionComponent when in an EnergyFunction;\nupdate_forces::Bool - Toggle forces calculation by this EnergyFunctionComponent when in an EnergyFunction. \n\nSee also\n\nEnergyFunction\n\nExamples\n\njulia> ProtoSyn.Calculators.Restraints.get_default_bond_distance_restraint()\n         Name : Bond_Distance_Restraint\n   Weight (α) : 1.0\nUpdate forces : true\n      Setings :\n          :x0 => 2.0\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.EnergyFunction","page":"Calculators Section","title":"ProtoSyn.Calculators.EnergyFunction","text":"EnergyFunction(components::Vector{EnergyFunctionComponent}, clean_cache_every::Int16, cache::Int16, components_by_name::Dict{String, Int})\n\nConstruct and return a new EnergyFunction instance. An EnergyFunction is a collection of EnergyFunctionComponent instances, where each of these components calculates an energetic contribution to the :total energy and forces acting on a system. An EnergyFunctionComponent can be retrieved by its index or by its name (as saved in components_by_name). The Julia cache is automatically cleaned by garbage collection. However, in certain cases (such as using the TorchANI EnergyFunctionComponent), a manual call to garbage collection is necessary (see Issue 55140). In such cases, the EnergyFunction object has an internal cache that is cleaned (by calling garbage collection) at intervals of clean_cache_every calls. This interval is automatically adjusted down by measuring the current load on the GPU, calling garbage collection once the memory allocation is greater than ProtoSyn.Units.max_gpu_allocation.\n\nEnergyFunction([::Type{T}])\n\nConstruct and return an empty EnergyFunction instance. The :clean_cache_every field is set to ProtoSyn.Units.defaultCleanCacheEvery.\n\nEnergyFunction(components::Vector{EnergyFunctionComponent{T}}) where {T <: AbstractFloat}\n\nConstruct and return a new EnergyFunction instance filled with the given list of EnergyFunctionComponent instances components. The :clean_cache_every field is set to ProtoSyn.Units.defaultCleanCacheEvery.  \n\nFields\n\ncomponents::Vector{EnergyFunctionComponent} - The list of EnergyFunctionComponent instances in this EnergyFunction;\nclean_cache_every::Int16 - Forcefully call garbage collection every N calls;\ncache::Int16 - Current number of calls performed. Resets to zero every clean_cache_every;\ncomponents_by_name::Dict{String, Int} - The list of EnergyFunctionComponent instances in this EnergyFunction, indexed by :name.\n\nSee also\n\nEnergyFunctionComponent\n\nExamples\n\njulia> energy_function = ProtoSyn.Calculators.EnergyFunction()\n🗲  Energy Function (0 components):\n+----------------------------------------------------------+\n| Index | Component name                      | Weight (α) |\n+----------------------------------------------------------+\n+----------------------------------------------------------+\n\njulia> push!(energy_function, Calculators.Restraints.get_default_bond_distance_restraint())\n🗲  Energy Function (1 components):\n+----------------------------------------------------------+\n| Index | Component name                      | Weight (α) |\n+----------------------------------------------------------+\n| 1     | Bond_Distance_Restraint             | 1.000      |\n+----------------------------------------------------------+\n\njulia> energy_function[\"Bond_Distance_Restraint\"].α = 0.5\n0.5\n\njulia> energy_function\n🗲  Energy Function (1 components):\n+----------------------------------------------------------+\n| Index | Component name                      | Weight (α) |\n+----------------------------------------------------------+\n| 1     | Bond_Distance_Restraint             | 0.500      |\n+----------------------------------------------------------+\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"An EnergyFunction instance is actually a functor, meaning it is callable in order to apply any energy function type to any Pose instance, using the following signature:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"(energy_function::EnergyFunction)(pose::Pose, update_forces::Bool = false)","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"An application example is provided bellow:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"using ProtoSyn\nusing ProtoSyn.Peptides\nusing ProtoSyn.Calculators\nres_lib = Peptides.grammar(Float64)\npose = ProtoSyn.build(res_lib, seq\"GME\")\ntorchani = Calculators.TorchANI.get_default_torchani_model()\nenergy_function = Calculators.EnergyFunction([torchani])\nenergy_function(pose)","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"torchani = Calculators.TorchANI.get_default_torchani_model()\nenergy_function = Calculators.EnergyFunction([torchani])\nenergy_function(pose)\nenergy_function(pose, true) # Calculating forces ...\npose.state.f","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"(Image: ProtoSyn Energy Function)","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Figure 1 | A diagram representation of the EnergyFunction organization as a set of EnergyFunctionComponent instances. Each component contribution is summed to evaluate the :total energy of the system, according to each component's scaling factor ɑ (in this example, 1.0 for the TorchANI Ensemble EnergyFunctionComponent and 0.8 for the Contact Map EnergyFunctionComponent). Some components may be able to calculate the set of forces acting on each atom of the system, in which case this contribution can be toggled on and off by the :update_forces flag. Furthermore, each component may be parametrized by a set of options. In this example, the Contact Map EnergyFunctionComponent can be further parametrized by setting the :d1, :d2, :d3 and :d4 values (controlling the flat bottom restraint potential), as well as the :selection on which to act and the :mask applied. Such settings are specific to each type of EnergyFunctionComponent and are explored in detail in each entry.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#Creating-a-custom-EnergyFunctionComponent","page":"Calculators Section","title":"Creating a custom EnergyFunctionComponent","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"As stated before, an EnergyFunctionComponent is mostly a smart wrapper around a :calc Function responsible for calculating a given energetic contribution based on a specific method, model or restraint type (as an example). Therefore, when developing custom EnergyFunctionComponent instances, certain aspects need to be taken into consideration. The following section lists particular restraints when creating custom EnergyFunctionComponent instances.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"The calc Function signature:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"When being called from an EnergyFunction instance, ProtoSyn expects the following calc Function signature.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"calc(pose::Pose, update_forces::Bool = false; kwarg1::Type{kwarg1} = default_value1, kwarg2::Type{kwarg2} = default_value2, ...)","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"The pose::Pose and update_forces::Bool = false arguments are necessary and expected. Optionally, these can be followed by a variable number of arguments (kwargs), parameterizing and fine-tuning the usage of the calc Function. When calling this EnergyFunctionComponent from an EnergyFunction, these kwargs are passed from the EnergyFunctionComponent.settings dictionary, and can therefore be automatically and continuously adjusted in a simulation. Since it may happen that one or more kwargs may not be defined in the EnergyFunctionComponent.settings, defining a default value for each of the kwargs is considered a good practice when creating a custom EnergyFunctionComponent.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Examples:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"calc_torchani_ensemble(pose::Pose, update_forces::Bool = false)\n\ncalc_flat_bottom_restraint(pose::Pose, update_forces::Bool; d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf, selection::Opt{AbstractSelection} = nothing, mask::MaskMap = nothing) where {T <: AbstractFloat}","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"The EnergyFunctionComponent.settings field","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"As previously stated, the EnergyFunctionComponent.settings are optional. If present, these are passed to the EnergyFunctionComponent.calc Function as kwargs, and therefore should match and have the same name (as a Symbol instead). This allows for easy access and modification of internal parameters of the calculation on the fly.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Examples:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Dict{Symbol, Any}(:d1 => 1.0, :d2 => 3.0, :d3 => Inf, :d4 => Inf, :selection => an\"CA\", :mask => Calculators.get_diagonal_mask(an\"CA\"))","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn-acceleration-types","page":"Calculators Section","title":"ProtoSyn acceleration types","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Certain EnergyFunctionComponent instances in ProtoSyn require specific software and hardware on the machine performing the calculation, or at least have specific implementations of the code based on the availability or not os said features (for example, certain functions have specific implementations for CUDA and GPU acceleration). For this reason, ProtoSyn defines 3 levels of acceleration (3 different acceleration types, loosely based on Flynn's Taxonomy):","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"SISD_0 - Single Instruction Single Data: uses CPU, should work on most modern processors;\nSIMD_1 - Single Instruction Multiple Data: uses CPU, parallelizes a single instruction in a vector of data, available in modern processors with MMX, SSE and AVX/AVX-512 technologies, among others;\nCUDA_2 - Compute Unified Device Architecture: parallel computing platform and API enabling GPU acceleration of code. If CUDA is available, this is the default acceleration type set up in ProtoSyn.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"As start-up, ProtoSyn tries to identify the available software and hardware available and sets the fastest acceleration type possible as ProtoSyn.acceleration.active. This can, however, be overridden:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"ProtoSyn.acceleration.active\nProtoSyn.acceleration.active = ProtoSyn.SIMD_1","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#Verlet-lists","page":"Calculators Section","title":"Verlet lists","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"A Verlet list is a common data structure in molecular manipulation and simulation softwares that maintains a list of particles inside a given cut-off distance to eachother. The main objective of Verlet lists is to speed up calculations by ignoring most of the long-distance interactions between Atom instances, as these would have negligent effects in the simulation, while reducing the amount of memory allocated as a whole. Note that, given the movement and displacement of Atom instances in a simulation, this list rapidly becomes obsolete and needs to be re-updated.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Calculators.VerletList\nCalculators.update!","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.VerletList","page":"Calculators Section","title":"ProtoSyn.Calculators.VerletList","text":"VerletList(size::Int, capacity::Int, cutoff::Float64, offset::Vector{Int}, list::Vector{Int})\n\nHold information regarding the neighbouring particles of each particle in the system (with number of particles size). A VerletList is comprised of two arrays: the list, containing the neighbouring atoms j of atom i, with sequential atoms divided by an invalid -1 entry; and the offset array, containing the positions in array list for each atom i. Neighbouring atoms are defined as having a distance bellow the defined cutoff. The main objective of a VerletList is to speed up calculations (by ignoring long-range interactions between Atom instances) and to lower the total amount of memory allocated (the number of allocated Atom entries is at most the capacity of the VerletList). Note that, given the motion of particles in a simulation, a VerletList can quickly become obsolete, and needs to be updated using update!.\n\nVerletList(size::Int)\n\nCreates a new VerletList with infinite cutoff (holds all atoms in the molecule).\n\nFields\n\nsize::Int - The number of Atom instances this VerletList makes reference to. Should be the size of :offset field;\ncapacity::Int - Maximum number of interaction pairs listed in this VerletList; \ncutoff::Float64 - Interactions are considered when the distance between two Atom instances is less than this value;\noffset::Vector{Int} - Vector with the starting index for the neighbouring Atom.id entries in the :list field;\nlist::Vector{Int} - Vector with the neighbouring Atom.id entries, in sectors separated by invalid entries (such as -1).\n\nSee also\n\nupdate! distance\n\nExamples\n\njulia> ProtoSyn.Calculators.VerletList(4)\nProtoSyn.Calculators.VerletList(4, 4, Inf, [0, 0, 0, 0], [0, 0, 0, 0])\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.update!","page":"Calculators Section","title":"ProtoSyn.Calculators.update!","text":"update!([::Type{ProtoSyn.SISD_0}], verlet_list::VerletList, pose::Pose, [selection::Opt{ProtoSyn.AbstractSelection} = nothing])\nupdate!([::Type{ProtoSyn.SIMD_1}], verlet_list::VerletList, pose::Pose, [selection::Opt{ProtoSyn.AbstractSelection} = nothing])\n\nUpdates the given VerletList (using a SISD_0 or SIMD_1 acceleration approach) according to the defined 'verlet_list.cutoff' and the given coordinates in the Pose pose (in AoS format). If the acceletarion type is not given, the default ProtoSyn.acceleration.active is employed. If an AbstractSelection selection is provided, only include the pair of Atom instances as interacting, in the VerletList, if both instances are selected. \n\nExamples\n\njulia> ProtoSyn.Calculators.update!(verlet_list, pose)\n    ...\n\njulia> ProtoSyn.Calculators.update!(verlet_list, pose, an\"CA\")\n    ...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"(Image: ProtoSyn Verlet List)","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Figure 2 | A diagram representation of the VerletList organization. Usually, a VerletList is comprised of two arrays: the :list and the :offset. The :offset vector contains 1 entry for each Atom instance in a given Pose, whose Atom.id is the index of the vector. The actual content of the vector is an index on the :list array, defining the starting point from which to read this vector in order to find all the Atom instances intercating with the currently selected Atom. As such, the :list vector is a collection of Atom.id records, with contiguous sectors separated by invalid entries (such as -1). Each one of these contigous sectors is a collection of Atom.id values belonging to the Atom instances that interact with a common Atom. As an example, consider the represented schematic. The considered range of interactions is represnted in light grey, with radius a and centered on the selected Atom 2. As such, the Atom instances 5, 9 and 12 are inside the interaction radius, and should be considered for measurement. In the accompanying VerletList, index 2 in the :offset vector contains value 4. By reading the :list vector starting at index 4 (as indicated by the :offset vector) until an invalid position is found (such as -1), Atom.id 5, 9 and 12 are found. In the same schematic, the dashed grey line indicates a \"moving cut-off\". It's a common practice in the usage of VerletList instances to accomodate Atom movement in a simulation environment, in order to reduce the number of times the VerletList needs to be updated. In this case, radius b is added to the VerletList.cutoff, and should be equal to N x 2 x MD (where N is the number of steps before re-updating the VerletList and MD is the maximum displacement an Atom is allowed or expected to suffer each step of the simulation). Using this approach, Atom 1 (in the example) should be included in the :list vector, at the contiguous sector related to Atom 2.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"ukw: Note:\nAs of ProtoSyn 1.0, VerletList instances are only employable in distance calculations using distance_matrix methods. However, the underlying mechanisms of VerletList data structures can be useful elsewhere and are planned to be incorporated in default EnergyFunctionComponent instances in the future.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#Distance-matrix-calculation","page":"Calculators Section","title":"Distance matrix calculation","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"As previously stated, the Calculators section in Core exists mainly to set-up types and methods transversal to all ProtoSyn's Calculators in different modules (such as Peptides). One such method commonly employed in energy calculations is the ability to measure distance matrices. A distance matrix is a 2D matrix whose entries are the distance between the X and Y Atom, usually considering only the top triangular matrix. A full distance matrix can also be useful, as is available by using the full_distance_matrix method.","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Calculators.distance_matrix\nCalculators.full_distance_matrix","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.distance_matrix","page":"Calculators Section","title":"ProtoSyn.Calculators.distance_matrix","text":"Calculators.distance_matrix([::A], coords::Matrix{T}) where {A, T <: AbstractFloat}\nCalculators.distance_matrix([::A], state::State{T}) where {A, T <: AbstractFloat}\nCalculators.distance_matrix([::A], pose::Pose) where {A}\n\nReturn a distance matrix with the distance of all pairs of coordinates in coords (this should be a Matrix{T} in AoS format) above the triangular matrix. Instead of a Matrix{T} coords, a State or Pose can be provided, in which case the coordinates considered are all the existent in the State or Pose.state, respectively. The optional A parameter defines the acceleration mode used (SISD_0, SIMD_1 or CUDA_2). If left undefined the default ProtoSyn.acceleration.active mode will be used. Note: Make sure the given Pose pose in synched (using the sync! method).\n\nCalculators.distance_matrix([::A], pose::Pose, selection::ProtoSyn.AbstractSelection)\n\nReturn a distance matrix with the distance of all pairs of atoms in the Pose pose who are selected in the given AbstractSelection selection and above the triangular matrix. The optional A parameter defines the acceleration mode used (SISD_0, SIMD_1 or CUDA_2). If left undefined the default ProtoSyn.acceleration.active mode will be used.\n\nCalculators.distance_matrix([::A], coords::Matrix{T}, verlet_list::VerletList) where {T <: AbstractFloat}\nCalculators.distance_matrix([::A], state::State{T}, verlet_list::VerletList) where {T <: AbstractFloat}\nCalculators.distance_matrix([::A], pose::Pose, verlet_list::VerletList)\n\nReturn a top triangular distance matrix with the distance of all pairs of coordinates in the VerletList verlet_list. Instead of a Matrix{T} coords, a State or Pose can be provided, in which case the coordinates considered are existent in the State or Pose.state, respectively. The optional A parameter defines the acceleration mode used (SISD_0, SIMD_1). If left undefined the default ProtoSyn.acceleration.active mode will be used. Note: Using VerletList, CUDA_2 acceleration mode is not available. If the default ProtoSyn.acceleration.active is set to CUDA_2, SIMD_1 will be used instead.\n\nukw: Note:\nAbstractSelections can still be applied when using VerletList instances, but need to be applied when updating the lists themselves. Check VerletList and update! entries for a more in-depth look at how Verlet lists work.\n\nSee also\n\nfull_distance_matrix\n\nExamples\n\njulia> ProtoSyn.Calculators.distance_matrix(pose.state.x)\nN×N CUDA.CuArray{Float64,2}:\n    ...\n\njulia> ProtoSyn.Calculators.distance_matrix(pose, an\"CA\")\nN×N CUDA.CuArray{Float64,2}:\n    ...\n\njulia> ProtoSyn.Calculators.distance_matrix(pose, verlet_list)\nN×N CUDA.CuArray{Float64,2}:\n    ...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/calculators-section/#ProtoSyn.Calculators.full_distance_matrix","page":"Calculators Section","title":"ProtoSyn.Calculators.full_distance_matrix","text":"Calculators.full_distance_matrix([::A], coords::Matrix{T}) where {A, T <: AbstractFloat}\nCalculators.full_distance_matrix([::A], state::State{T}) where {A, T <: AbstractFloat}\nCalculators.full_distance_matrix([::A], pose::Pose) where {A}\n\nReturn a distance matrix with the distance of all pairs of coordinates in coords (this should be a Matrix{T} in AoS format). Instead of a Matrix{T} coords, a State or Pose can be provided, in which case the coordinates considered are all the existent in the State or Pose.state, respectively. The optional A parameter defines the acceleration mode used (SISD_0, SIMD_1 or CUDA_2). If left undefined the default ProtoSyn.acceleration.active mode will be used.\n\nCalculators.full_distance_matrix([::A], pose::Pose, selection::ProtoSyn.AbstractSelection)\n\nReturn a distance matrix with the distance of all pairs of atoms in the Pose pose who are selected in the given AbstractSelection selection. The optional A parameter defines the acceleration mode used (SISD_0, SIMD_1 or CUDA_2). If left undefined the default ProtoSyn.acceleration.active mode will be used.\n\nSee also\n\ndistance_matrix\n\nExamples\n\njulia> ProtoSyn.Calculators.full_distance_matrix(pose.state.x)\nN×N CUDA.CuArray{Float64,2}:\n ...\n\njulia> ProtoSyn.Calculators.distance_matrix(pose, an\"CA\")\nN×N CUDA.CuArray{Float64,2}:\n ...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/calculators-section/#Available-EnergyFunctionComponents","page":"Calculators Section","title":"Available EnergyFunctionComponents","text":"","category":"section"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Besides all the machinery to create custom energy components, ProtoSyn's Core module makes available some simple EnergyFunctionComponent instances. Since this is not a specialized module, available components should be indiferent to the type of molecular structure being evaluated. As of ProtoSyn 1.0, the following EnergyFunctionComponent instances are made available from the Core module, and can be further explored in the respectivelly dedicated pages of this manual:","category":"page"},{"location":"protosyn-api/core/calculators/calculators-section/","page":"Calculators Section","title":"Calculators Section","text":"Bond Distance Restraint\nTorchANI","category":"page"},{"location":"protosyn-api/core/drivers/drivers-ils/","page":"ILS","title":"ILS","text":"CurrentModule = ProtoSyn.Drivers","category":"page"},{"location":"protosyn-api/core/drivers/drivers-ils/#ILS-Driver","page":"ILS","title":"ILS Driver","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-ils/","page":"ILS","title":"ILS","text":"The ILS Driver performs the Iterated Local Search algorithm, introducing a large conformational change in between local optimization runs.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-ils/","page":"ILS","title":"ILS","text":"ILS\nILSState","category":"page"},{"location":"protosyn-api/core/drivers/drivers-ils/#ProtoSyn.Drivers.ILS","page":"ILS","title":"ProtoSyn.Drivers.ILS","text":"ILS(eval!::Union{Function, EnergyFunction}, jump!::Union{Function, AbstractMutator, Driver}, inner_driver!::Driver, callback::Opt{Callback}, max_steps::Int, temperature::Function)\n\nAn ILS Driver instance. As such, this object is callable as a functor with the following signature:\n\n(driver::ILS)(pose::Pose)\n\nThis simulation performs an Iterated Local Search algorithm. In this type of simulation, an inner_driver! takes the system from a state to another, possibly optimizing the structure into a local minimum. As an example, this can be a MonteCarlo or a SteepestDescent Driver. The resulting structure is evaluated (according to an eval! EnergyFunction instance or custom function) and accepted or rejected according to the Metropolis Criterion, based on the current temperature of the simulation (see MonteCarlo for more information regarding the Metropolis Criterion). In either case, the accepted structure or the recovered previous state structure is subjected to a jump!, that is, a large conformational change, taking the system to a new conformational space. This simulation loop runs for max_steps iteration. Each step, a call to an optional Callback callback is performed. A companion ILSState DriverState instance is also updated each step and provided to the Callback callback.\n\nFields\n\neval!::Union{Function, EnergyFunction} - The evaluator EnergyFunction or custom function for the outer loop, receives two input arguments: a Pose pose and a calc_forces::Bool boolean;\njump!::Union{Function, AbstractMutator, Driver} - The jump method, receives a Pose pose as the single input argument, should introduce a relative high change in the conformation;\ninner_driver!::Driver - The inner loop Driver;\ncallback::Opt{Callback} - An optional Callback instance for the outer loop, receives two input arguments: the current Pose pose and the current DriverState driver_state;\nmax_steps::Int - The total number of simulation steps to be performed in the outer loop;\ntemperature::Function - The temperature function thermostat for the outer loop (see Available thermostats), receives the current step (as an Int) as the single input argument.\n\nSee also\n\nILSState\n\nExamples\n\njulia> ils = ProtoSyn.Drivers.ILS(energy_function, dihedral_mutator, monte_carlo, cb, 1000, ProtoSyn.Drivers.get_linear_quench(1.0, 1000))\n⚒  ILS Driver:\n ├──  ●  Evaluator:\n |    └── 🗲  Energy Function (4 components):\n |        +----------------------------------------------------------------------+\n |        | Index | Component name                                | Weight (α)   |\n |        +----------------------------------------------------------------------+\n |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |        +----------------------------------------------------------------------+\n |   \n ├──  ● Jump:\n |    └── ⚯  Dihedral Mutator:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                       | Value                          |\n |        +----------------------------------------------------------------------+\n |        | 1     | angle_sampler               | Function randn                 |\n |        | 2     | p_mut                       | 0.0100                         |\n |        | 3     | step_size                   | 0.5000                         |\n |        +----------------------------------------------------------------------+\n |         ● Selection: Set\n |         └── FieldSelection › Atom.name = r\"C|N\"\n |   \n ├──  ● Inner Driver:\n |    └── ⚒  Monte Carlo Driver:\n |         ├──  ●  Evaluator:\n |         |    └── 🗲  Energy Function (4 components):\n |         |        +----------------------------------------------------------------------+\n |         |        | Index | Component name                                | Weight (α)   |\n |         |        +----------------------------------------------------------------------+\n |         |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |         |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |         |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |         |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |         |        +----------------------------------------------------------------------+\n |         |   \n |         ├──  ● Sampler:\n |         |    └── ⚯  Dihedral Mutator:\n |         |        +----------------------------------------------------------------------+\n |         |        | Index | Field                       | Value                          |\n |         |        +----------------------------------------------------------------------+\n |         |        | 1     | angle_sampler               | Function randn                 |\n |         |        | 2     | p_mut                       | 0.0100                         |\n |         |        | 3     | step_size                   | 0.5000                         |\n |         |        +----------------------------------------------------------------------+\n |         |         ● Selection: Set\n |         |         └── FieldSelection › Atom.name = r\"C|N\"\n |         |   \n |         ├──  ○  Callback: Not set\n |         |   \n |         └──  ● Settings:\n |               Max steps: 10\n |             Temperature: linear_quench\n |   \n ├──  ● Callback:\n |    └── ✉  Callback:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                     | Value                            |\n |        +----------------------------------------------------------------------+\n |        | 1     | Event                     | energy_step_frame                |\n |        | 2     | Frequency                 | 10                               |\n |        +----------------------------------------------------------------------+\n |   \n └──  ● Settings:\n       Max steps: 1000\n     Temperature: linear_quench\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-ils/#ProtoSyn.Drivers.ILSState","page":"ILS","title":"ProtoSyn.Drivers.ILSState","text":"ILSState{T <: AbstractFloat}(step::Int = 0, converged::Bool = false, completed::Bool = false, stalled::Bool = false, acceptance_count = 0, temperature::T = T(0.0))\nILSState{T <: AbstractFloat}()\n\nA ILSState instance is a DriverState that keeps track of a ILS simulation status. Besides the default :step, :converged, :completed and :stalled fields, a ILSState instance adds the following tracking fields specific for ILS simulations:\n\nacceptance_count::Int - The number of accepted Pose changes by the Metropolis criterion;\ntemperature::T - The current temperature of the simulation.\n\nSee also\n\nILS\n\nExamples\n\njulia> ProtoSyn.Drivers.ILSState{Float64}()\nProtoSyn.Drivers.ILSState{Float64}(0, false, false, false, 0, 0.0)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-ils/","page":"ILS","title":"ILS","text":"(Image: ProtoSyn ils-driver)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-ils/","page":"ILS","title":"ILS","text":"Figure 1 | A schematic overview of the different stages in a ILS Driver: (1) - A jump! introduces a relative large conformational change into the system's structure, taking the Pose into a new conformational space; (2) - An inner_driver! optimizes the new structure, finding new local minima.","category":"page"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/","page":"Rotamer Blitz","title":"Rotamer Blitz","text":"CurrentModule = ProtoSyn.Peptides.Drivers","category":"page"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/#Rotamer-Blitz-Driver","page":"Rotamer Blitz","title":"Rotamer Blitz Driver","text":"","category":"section"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/","page":"Rotamer Blitz","title":"Rotamer Blitz","text":"The Rotamer Blitz Driver is an algorithm for sidechain packaging, exhaustively looping through all Rotamer possibilities and setting the most stable conformation for the Residue sidechain.","category":"page"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/","page":"Rotamer Blitz","title":"Rotamer Blitz","text":"RotamerBlitz\nRotamerBlitzState","category":"page"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/#ProtoSyn.Peptides.Drivers.RotamerBlitz","page":"Rotamer Blitz","title":"ProtoSyn.Peptides.Drivers.RotamerBlitz","text":"RotamerBlitz(eval!::Union{Function, ProtoSyn.Calculators.EnergyFunction}, rotamer_library::Dict{String, ProtoSyn.Peptides.BBD_RotamerLibrary}, n_first::Int, max_steps::Int, callback::Opt{ProtoSyn.Drivers.Callback}, selection::Opt{AbstractSelection})\n\nA RotamerBlitz Driver instance. As such, this object is callable as a functor with the following signature:\n\n(driver::RotamerBlitz)(pose::Pose)\n\nThis simulation performs a sidechain packaging algorithm, where each step (until a maximum of n_steps), all Residue instances in the provided Pose pose (in random order) may suffer a rotamer conformation change. As such, for each Residue instance, all n_first most likely Rotamer instances in the rotamer_library (according to the current backbone phi and psi Dihedral angles) are applied (using the apply! method) and evaluated by the provided eval! EnergyFunction or custom function. Once all n_first most likely Rotamer instances are looped over, the most favourable (least energetic) one is re-applied. Each step, a call to an optional Callback callback is performed. A companion RotamerBlitzState DriverState instance is also updated each step and provided to the Callback callback.\n\nFields\n\neval!::Union{Function, EnergyFunction} - The evaluator EnergyFunction or custom function, receives two input arguments: a Pose pose and a calc_forces::Bool boolean;\nrotamer_library::Dict{String, ProtoSyn.Peptides.BBD_RotamerLibrary} - The rotamer library used to sample new Rotamer instances from;\nn_first::Int - Maximum number of Rotamer instances to try, ordered from most to less likely;\nmax_steps::Int - The total number of simulation steps to be performed;\ncallback::Opt{Callback} - An optional Callback instance, receives two input arguments: the current Pose pose and the current DriverState driver_state;\nselection::Opt{AbstractSelection} - If provided, only selected Residue instances will be considered as target for the RotamerBlitz simulation, otherwise, consider all Residue instances.\n\nSee also\n\nRotamerBlitzState\n\nExamples\n\njulia> rb = ProtoSyn.Peptides.Drivers.RotamerBlitz(energy_function, rot_lib, 1, 2, cb, an\"CA\")\n⚒  Rotamer Blitz Driver:\n ├──  ●  Evaluator:\n |    └── 🗲  Energy Function (4 components):\n |        +----------------------------------------------------------------------+\n |        | Index | Component name                                | Weight (α)   |\n |        +----------------------------------------------------------------------+\n |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |        +----------------------------------------------------------------------+\n |   \n ├──  ● Callback:\n |    └── ✉  Callback:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                     | Value                            |\n |        +----------------------------------------------------------------------+\n |        | 1     | Event                     | energy_step_frame                |\n |        | 2     | Frequency                 | 10                               |\n |        +----------------------------------------------------------------------+\n |   \n ├──  ● Selection:\n |    └── FieldSelection › Atom.name = CA\n |   \n └──  ● Settings:\n             Rotamer Library: Set ✓\n                   Max steps: 2\n     Search N first rotamers: 1\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/#ProtoSyn.Peptides.Drivers.RotamerBlitzState","page":"Rotamer Blitz","title":"ProtoSyn.Peptides.Drivers.RotamerBlitzState","text":"RotamerBlitzState{T <: AbstractFloat}(step::Int = 0, converged::Bool = false, completed::Bool = false, stalled::Bool = false, acceptance_count = 0)\nRotamerBlitzState{T <: AbstractFloat}()\n\nA RotamerBlitzState instance is a DriverState that keeps track of a RotamerBlitz simulation status. Besides the default :step, :converged, :completed and :stalled fields, a RotamerBlitzState does not add any additional tracking fields specific for RotamerBlitz simulations.\n\nSee also\n\nRotamerBlitz\n\nExamples\n\njulia> ProtoSyn.Peptides.Drivers.RotamerBlitzState()\nProtoSyn.Peptides.Drivers.RotamerBlitzState(0, false, false, false)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/","page":"Rotamer Blitz","title":"Rotamer Blitz","text":"(Image: ProtoSyn rotamer-blitz-driver)","category":"page"},{"location":"protosyn-api/peptides/drivers/rotamer-blitz-driver/","page":"Rotamer Blitz","title":"Rotamer Blitz","text":"Figure 1 | A schematic overview of the different stages in a RotamerBlitz Driver: (1) - For a single Residue, all N most likely Rotamer instances are applied (using the apply! method) and the resulting conformation's energy is evaluated; (2) - After trying all Rotamer instances, the less energetic conformation is recovered and applied. This is performed to all Residue instances in a given Pose, in random order; (3) - This process continues for a set amount of steps, resulting in a lower energy conformation for the sidechains in a Pose.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-compound/","page":"Compound Driver","title":"Compound Driver","text":"CurrentModule = ProtoSyn.Drivers","category":"page"},{"location":"protosyn-api/core/drivers/drivers-compound/#Compound-Driver","page":"Compound Driver","title":"Compound Driver","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-compound/","page":"Compound Driver","title":"Compound Driver","text":"Similar to the Compound Mutator, a Compound Driver joins and sequentially calls a set of Driver and AbstractMutator instances, as well as custom sampling functions (the only difference to a CompoundMutator is the addition of Driver instances as callable objects).","category":"page"},{"location":"protosyn-api/core/drivers/drivers-compound/","page":"Compound Driver","title":"Compound Driver","text":"CompoundDriver","category":"page"},{"location":"protosyn-api/core/drivers/drivers-compound/#ProtoSyn.Drivers.CompoundDriver","page":"Compound Driver","title":"ProtoSyn.Drivers.CompoundDriver","text":"CompoundDriver(drivers::Vector{Union{Function, AbstractMutator, Driver}})\n\nA CompoundDriver Driver instance. As such, this object is callable as a functor with the following signature:\n\n(driver::CompoundDriver)(pose::Pose)\n\nA CompoundDriver Driver groups several Driver, AbstractMutator and custom functions, calling each of the components sequentially. Does not sync! changes, this task is left to each individual Driver or AbstractMutator instance.\n\nukw: Note:\nIn contrast with CompoundMutator, this Driver does not accept an AbstractSelection modifier. This may change in future versions of ProtoSyn.\n\nExamples\n\njulia> ProtoSyn.Drivers.CompoundDriver([monte_carlo, monte_carlo])\n⚒  CompoundDriver Driver (2 elements):\n ├── ⚒  Monte Carlo Driver:\n |    ├──  ●  Evaluator:\n |    |    └── 🗲  Energy Function (4 components):\n |    |        +----------------------------------------------------------------------+\n |    |        | Index | Component name                                | Weight (α)   |\n |    |        +----------------------------------------------------------------------+\n |    |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |    |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |    |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |    |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |    |        +----------------------------------------------------------------------+\n |    |   \n |    ├──  ● Sampler:\n |    |    └── ⚯  Dihedral Mutator:\n |    |        +----------------------------------------------------------------------+\n |    |        | Index | Field                       | Value                          |\n |    |        +----------------------------------------------------------------------+\n |    |        | 1     | angle_sampler               | Function randn                 |\n |    |        | 2     | p_mut                       | 0.0100                         |\n |    |        | 3     | step_size                   | 0.5000                         |\n |    |        +----------------------------------------------------------------------+\n |    |         ● Selection: Set\n |    |         └── FieldSelection › Atom.name = r\"C|N\"\n |    |   \n |    ├──  ○  Callback: Not set\n |    |   \n |    └──  ● Settings:\n |          Max steps: 10\n |        Temperature: linear_quench\n |   \n └── ⚒  Monte Carlo Driver:\n      ├──  ●  Evaluator:\n      |    └── 🗲  Energy Function (4 components):\n      |        +----------------------------------------------------------------------+\n      |        | Index | Component name                                | Weight (α)   |\n      |        +----------------------------------------------------------------------+\n      |        | 1     | TorchANI_ML_Model                             |      1.000   |\n      |        | 2     | Caterpillar_Solvation                         |      0.010   |\n      |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n      |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n      |        +----------------------------------------------------------------------+\n      |   \n      ├──  ● Sampler:\n      |    └── ⚯  Dihedral Mutator:\n      |        +----------------------------------------------------------------------+\n      |        | Index | Field                       | Value                          |\n      |        +----------------------------------------------------------------------+\n      |        | 1     | angle_sampler               | Function randn                 |\n      |        | 2     | p_mut                       | 0.0100                         |\n      |        | 3     | step_size                   | 0.5000                         |\n      |        +----------------------------------------------------------------------+\n      |         ● Selection: Set\n      |         └── FieldSelection › Atom.name = r\"C|N\"\n      |   \n      ├──  ○  Callback: Not set\n      |   \n      └──  ● Settings:\n            Max steps: 10\n          Temperature: linear_quench\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"CurrentModule = ProtoSyn.Peptides.Mutators","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/#Rotamer-Mutator","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"","category":"section"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"One of the AbstractMutator types made available by the ProtoSyn.Peptides module is the RotamerMutator, allowing a user to sample the sidechain conformation of one or more Residue instances. This has, for example, applications in sidechain packaging, ligand adsorption stabilization or active site generation algorithms, among others.","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"RotamerMutator","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/#ProtoSyn.Peptides.Mutators.RotamerMutator","page":"Rotamer Mutator","title":"ProtoSyn.Peptides.Mutators.RotamerMutator","text":"RotamerMutator(rotamer_library::Dict{String, ProtoSyn.Peptides.BBD_RotamerLibrary}, p_mut::AbstractFloat, n_first::Int, selection::Opt{AbstractSelection}\n\nReturn a RotamerMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(rotamer_mutator::RotamerMutator)(pose::Pose)\n\nThe RotamerMutator AbstractMutator loops through all Atom instances in the given Pose and applies a Rotamer conformation change if a random number (rand()) is bellow a given probability of mutation p_mut (will skip any Residue with unnaccessible phi or psi Dihedral angles, such as the first and last Residue of a chain). A Rotamer conformation change is a concerted rotation of all sidechain Atom instances in the Residue of the selected Atom (therefore for a single attempt at Rotamer change, unique Atom names should be selected, an\"CA\", for example). If an AbstractSelection selection is provided, only Atom instances marked as true in this selection are considered for Rotamer conformational change. The applied Rotamer is sampled from the RotamerMutator.rotamer_library, based on the name of the Residue and current phi and psi Dihedral angle values. The n_first most likely Rotamer instances are taken into account during this sampling step. Note that the RotamerMutator syncs any pending cartesian to internal coordinate conversion (using the c2i! method). Requests internal to cartesian coordinates conversion (using request_i2c! method). Does not sync! the given Pose afterwards.\n\nThe RotamerMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(rotamer_mutator::RotamerMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\nrotamer_library::Dict{String, ProtoSyn.Peptides.BBD_RotamerLibrary} - A dictionary of BBD_RotamerLibrary instances, for each aminoacid type;\np_mut::AbtractFloat - Compared against a rand() call, applies this Mutator to Atom instances where rand() < p_mut;\nn_first::Int - Take only the N most likely Rotamer instances from the rotamer library;\nselection::Opt{AbstractSelection} - If given, this Mutator will only loop over the selected Atom instances;\n\nSee also\n\nDesignMutator\n\nExamples\n\njulia> rm = ProtoSyn.Peptides.Mutators.RotamerMutator(rot_lib, 1.0, 10, an\"CA\" & !rn\"PRO\")\n⚯  Rotamer Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | rotamer_library             | Set ✓                          |\n| 2     | p_mut                       | 1.000                          |\n| 3     | n_first                     | 10                             |\n+----------------------------------------------------------------------+\n ● Selection: Set\n └── BinarySelection ❯  & \"and\" (Atom)\n      ├── FieldSelection › Atom.name = CA\n      └── UnarySelection ❯ ! \"not\" (Residue)\n           └── FieldSelection › Residue.name = PRO\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"(Image: ProtoSyn Rotamer Mutator Card)","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"Figure 1 | Schematic description of the RotamerMutator. ","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"(Image: ProtoSyn Rotamer Mutator)","category":"page"},{"location":"protosyn-api/peptides/mutators/rotamer/","page":"Rotamer Mutator","title":"Rotamer Mutator","text":"Figure 2 | Example of the application of RotamerMutator to simulateously change the conformation of all sidechain Atom instances (except in Proline Residue instances). ","category":"page"},{"location":"protosyn-api/peptides/calculators/ca-ca-clash-restraint/","page":"Cα-Cα Clash Restraint","title":"Cα-Cα Clash Restraint","text":"CurrentModule = ProtoSyn.Peptides.Calculators.Restraints","category":"page"},{"location":"protosyn-api/peptides/calculators/ca-ca-clash-restraint/#Cα-Cα-Clash-Restraint","page":"Cα-Cα Clash Restraint","title":"Cα - Cα Clash Restraint","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/ca-ca-clash-restraint/","page":"Cα-Cα Clash Restraint","title":"Cα-Cα Clash Restraint","text":"The Cα - Cα Clash Restraint is a potential restraint (See Potential restraints for more details), applying a penalty for pairs of interacting Cα atoms with distances lower than a set value, thus reducing the occurrence of Residue overlap.","category":"page"},{"location":"protosyn-api/peptides/calculators/ca-ca-clash-restraint/","page":"Cα-Cα Clash Restraint","title":"Cα-Cα Clash Restraint","text":"get_default_ca_clash_restraint","category":"page"},{"location":"protosyn-api/peptides/calculators/ca-ca-clash-restraint/#ProtoSyn.Peptides.Calculators.Restraints.get_default_ca_clash_restraint","page":"Cα-Cα Clash Restraint","title":"ProtoSyn.Peptides.Calculators.Restraints.get_default_ca_clash_restraint","text":"get_default_ca_clash_restraint(;α::T = ProtoSyn.Units.defaultFloat(1.0)) where {T <: AbstractFloat}\n\nReturn the default Cα-Cα clash restraint EnergyFunctionComponent. α sets the component weight (on an EnergyFunction). If a mask is provided, the component will apply that mask every calculation (fixed mask) - recommended, except for design efforts. Otherwise, the default get_diagonal_mask function will be used, which calculates a new diagonal mask every calculation (effectly ignoring the same atom energetic contributions).\n\nukw: Note:\nBy default, this EnergyFunctionComponent does not calculate forces, as they would only be applied to the Cα atoms. This setting can be re-defined in component.update_forces.\n\nCα clash energy settings\n\n:d1, :d2, :d3, :d4 -> set each of the distances defining a flat-bottom potential (in Angstrom Å);\n:selection -> defines the atom selection limiting the considered atoms for the calculation; \n:mask -> defines the mask applied to the energy and forces result;\n\nSee also\n\nProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint ProtoSyn.Calculators.get_diagonal_mask\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Restraints.get_default_ca_clash_restraint()\n         Name : Cα-Cα_Clash_Restraint\n   Weight (α) : 1.0\nUpdate forces : false\n      Setings :\n       :d4 => Inf\n:selection => FieldSelection › Atom.name = CA\n       :d2 => 3.0\n     :mask => _diagonal_mask\n       :d1 => 1.0\n       :d3 => Inf\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/ca-ca-clash-restraint/","page":"Cα-Cα Clash Restraint","title":"Cα-Cα Clash Restraint","text":"(Image: ProtoSyn CA-CA Restraint)","category":"page"},{"location":"protosyn-api/peptides/calculators/ca-ca-clash-restraint/","page":"Cα-Cα Clash Restraint","title":"Cα-Cα Clash Restraint","text":"Figure 1 | A diagram representation of the Cα - Cα Clash Restraint EnergyFunctionComponent. The applied potential is a flat bottom function, with only the lower bound having and energy penatly. The d1 and d2 settings can be customly parametrized. This energy is only calculated for pair of interacting Cα Atom instances (in different Residue instances, as defined the the provided AbstractSelection and mask).","category":"page"},{"location":"protosyn-api/core/methods/aux/","page":"Auxiliary methods","title":"Auxiliary methods","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/methods/aux/#Auxiliary-methods","page":"Auxiliary methods","title":"Auxiliary methods","text":"","category":"section"},{"location":"protosyn-api/core/methods/aux/","page":"Auxiliary methods","title":"Auxiliary methods","text":"The following methods include auxiliary functions for various tasks.","category":"page"},{"location":"protosyn-api/core/methods/aux/","page":"Auxiliary methods","title":"Auxiliary methods","text":"rand_vector_in_sphere\nrotation_matrix_from_axis_angle\nunit_circle","category":"page"},{"location":"protosyn-api/core/methods/aux/#ProtoSyn.rand_vector_in_sphere","page":"Auxiliary methods","title":"ProtoSyn.rand_vector_in_sphere","text":"rand_vector_in_sphere([::Type{T}]) where {T <: AbstractFloat}\n\nReturn a random vector in a sphere, with norm = 1. The X, Y and Z cartesian coordinates are of type T. If not provided, the ProtoSyn.Units.defaultFloat type will be used.\n\nExamples\n\njulia> ProtoSyn.rand_vector_in_sphere()\n3-element Array{Float64,1}:\n 0.4182585394795512\n 0.4965570141814753\n 0.7605859095589471\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/aux/#ProtoSyn.rotation_matrix_from_axis_angle","page":"Auxiliary methods","title":"ProtoSyn.rotation_matrix_from_axis_angle","text":"rotation_matrix_from_axis_angle(axis::Vector{T}, angle::T) where {T <: AbstractFloat}\n\nReturn a rotation matrix based on the provided axis and angle (in radians).\n\nExamples\n\njulia> ProtoSyn.rotation_matrix_from_axis_angle([1.1, 2.2, 3.3], π/2)\n3×3 Matrix{Float64}:\n  0.0714286  -0.658927  0.748808\n  0.944641    0.285714  0.16131\n -0.320237    0.695833  0.642857\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/aux/#ProtoSyn.unit_circle","page":"Auxiliary methods","title":"ProtoSyn.unit_circle","text":"unit_circle(value::T) where {T <: AbstractFloat}\n\nMaps an angle value (in radians) from ]-∞, +∞[ to [0, 2π[ range. Returns value in radians.\n\nExamples\n\njulia> ProtoSyn.unit_circle(-2pi)\n0.0\n\njulia> ProtoSyn.unit_circle(-(3/2)pi)\n1.5707963267948966\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/submodules/selections/#core-selections","page":"Selections","title":"Selections","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"The Selections are a submodule of ProtoSyn.Core module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"ProtoSyn comes equipped with a powerful syntax for selecting parts of molecular systems based on several different parameters. The parent type of all Selections is an AbstractSelection, which is parametrized by 2 different static types:","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"First, a StateMode indicates whether an AbstractSelection is Stateful or Stateless.\nStateful selections require a State in order to correctly calculate the Selection. An example would be a Selection that selects all residues within 10Å of a given residue.\nStateless selections do not require a State. An example would be a Selection that selects all residues named \"ALA\".\nSecondly, a selection type is an instance of AbstractContainer (such as an Atom, Residue or Segment), and indicates the type of molecular structure that in being queried. For example, depending on the selection type, we can select all Residue instances named \"ALA\" or all Atom instances named \"ALA\".","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"ukw: Note:\nSome AbstractSelection types can use regular expressions (Regex) to search for the desired parameter. Such cases are discussed individually.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Selections, when applied to an AbstractContainer, return a binary Mask (see Masks section). These can be combined with others Masks (see Combining selections), used directly in [Methods] or gathered to a list of the actual instances of AbstractContainer (see Applying selections section).","category":"page"},{"location":"protosyn-api/core/submodules/selections/#Available-selection-functions","page":"Selections","title":"Available selection functions","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"In this section the list all available AbstractSelection types will be explored.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"SerialSelection\nRangeSelection\nFieldSelection\nTerminalSelection\nDistanceSelection\nRandomSelection\nRandomSelectionFromList\nRandomRangeSelection\nTrueSelection\nUnarySelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"SerialSelection\nRangeSelection\nFieldSelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.SerialSelection","page":"Selections","title":"ProtoSyn.SerialSelection","text":"SerialSelection{T}(serial::Int, field::Symbol) where {T <: AbstractContainer}\n\nA SerialSelection selects instances based on :id and :index. It takes an input serial (as an Int) and a field (as a Symbol) and outputs a Mask (of type T <: AbstractContainer) containing all instances of said type in the given container whose field matches the serial number given. This selection works similarly to FieldSelection, but is especialized in dealing with number variables.\n\nState mode\n\nThe state mode of SerialSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of SerialSelection can be any T <: AbstractContainer.\n\nShort syntax\n\nsid\"...\" = Segment ID;\nrid\"...\" = Residue ID;\naid\"...\" = Atom ID;\nsix\"...\" = Segment Index;\nrix\"...\" = Residue Index;\naix\"...\" = Atom Index;\n\nExamples\n\njulia> sele = SerialSelection{Segment}(1, :id)\nSerialSelection › Segment.id = 1\n\njulia> sele = SerialSelection{Atom}(2, :index)\nSerialSelection › Atom.index = 2\n\njulia> sele = sid\"1\"\nSerialSelection › Segment.id = 1\n\njulia> sele = aix\"2\"\nSerialSelection › Atom.index = 2\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.RangeSelection","page":"Selections","title":"ProtoSyn.RangeSelection","text":"RangeSelection{T}(range::UnitRange{Int}, field::Symbol) where {T <: AbstractContainer}\n\nA RangeSelection takes an input range (as an UnitRange{Int}) and a field (as a Symbol) and outputs a Mask (of type T <: AbstractContainer) containing all instances of said type in the given container whose field matches is in the range given. This selection works simillarly to FieldSelection, but is especialized in dealing with numbers.\n\nukw: Note:\nThe RangeSelection is inclusive, meaning the :id of :index given in the selection will also be included in the selected Mask.\n\nState mode\n\nThe state mode of RangeSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of RangeSelection can be any T <: AbstractContainer.\n\nShort syntax\n\nsid\"...\" = Segment ID\nrid\"...\" = Residue ID\naid\"...\" = Atom ID\nsix\"...\" = Segment Index;\nrix\"...\" = Residue Index;\naix\"...\" = Atom Index;\n\nExamples\n\njulia> sele = RangeSelection{Segment}(1:4, :id)\nRangeSelection › Segment.id between 1 and 4\n\njulia> sele = RangeSelection{Atom}(2:10, :index)\nRangeSelection › Atom.index between 2 and 10\n\njulia> sele = sid\"1:4\"\nRangeSelection › Segment.id between 1 and 4\n\njulia> sele = aix\"2:10\"\nRangeSelection › Atom.index between 2 and 10\n\nukw: Note:\nThis selection assumes that all Abstractcontainer instances are ordered (i.e: aid\"1:10\" will select atoms 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10).\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.FieldSelection","page":"Selections","title":"ProtoSyn.FieldSelection","text":"FieldSelection{T}(pattern::String, field::Symbol, [is_regex::Bool = false]) where {T <: AbstractContainer}\n\nA FieldSelection takes an input pattern (as a String) and a field (as a Symbol) and outputs a Mask (of type T <: AbstractContainer) containing all instances of said type in the given container whose field matches the pattern.\n\nukw: Note:\nThe given pattern can be considered as a Regular Expression (Regex), if is_regex flag is set to true. Optinally, when using a short syntax, appending an \"r\" flag at the end of the expression also sets is_regex to true. Check the examples bellow.\n\nState mode\n\nThe state mode of FieldSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of FieldSelection can be any T <: AbstractContainer.\n\nShort syntax\n\nan\"...\" = Atom name\nas\"...\" = Atom symbol\nrn\"...\" = Residue name\nsn\"...\" = Segment name\n\nExamples\n\njulia> sele = FieldSelection{Atom}(\"C\", :symbol)\nFieldSelection › Atom.symbol = C\n\njulia> sele = FieldSelection{Residue}(\"AL*\", :name, is_regex = true)\nFieldSelection › Residue.name = r\"AL*\"\n\njulia> sele = as\"C\"\nFieldSelection › Atom.symbol = C\n\njulia> sele = rn\"AL*\"r\nFieldSelection › Residue.name = r\"AL*\"\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn selections1)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 1 | An example of a Serial, Range and Field selections being employed.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"TerminalSelection\nDistanceSelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.TerminalSelection","page":"Selections","title":"ProtoSyn.TerminalSelection","text":"TerminalSelection()\n\nA TerminalSelection returns a Mask selecting only the terminal Residue instances in a Pose or AbstractContainer. Terminal Residue instancs are considered when either:\n\nAre children of the respective pose's root residue;\nAre residues without children;\n\nState mode\n\nThe state mode of TerminalSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of TerminalSelection T is forced to be Residue.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> sele = TerminalSelection()\nTerminalSelection (Residue)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.DistanceSelection","page":"Selections","title":"ProtoSyn.DistanceSelection","text":"DistanceSelection(distance::Number, sele::S) where {S <: AbstractSelection}\n\nA DistanceSelection takes an input selection sele and outputs a Mask of Atom instances within the given distance (in Ansgtrom Å) of the selected atoms from sele.\n\nState mode\n\nThe state mode of DistanceSelection M is forced to be Stateful\n\nSelection type\n\nThe selection type of DistanceSelection T is forced to be Atom.\n\nExamples\n\njulia> sele = DistanceSelection(2.0, rn\"ALA\")\nDistanceSelection ❯ Within 2.0 Å (Atom)\n └── FieldSelection › Residue.name = ALA\n\njulia> 2.0:rn\"ALA\"\nDistanceSelection ❯ Within 2.0 Å (Atom)\n └── FieldSelection › Residue.name = ALA\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn selections2)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 2 | An example of the Terminal and Distance selections being employed.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"RandomSelection\nRandomSelectionFromList\nRandomRangeSelection\nTrueSelection\nUnarySelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.RandomSelection","page":"Selections","title":"ProtoSyn.RandomSelection","text":"RandomSelection{T}() where {T <: AbstractContainer}\n\nA RandomSelection outputs a Mask (of type T <: AbstractContainer) containing a random instance of said type in the given container.\n\nState mode\n\nThe state mode of RandomSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of RandomSelection can be any T <: AbstractContainer.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> sele = RandomSelection{Residue}()\nRandomSelection › Residue.id\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.RandomSelectionFromList","page":"Selections","title":"ProtoSyn.RandomSelectionFromList","text":"RandomSelectionFromList(selections::Vector{T}) where {T <: AbstractSelection}\n\nA RandomSelectionFromList outputs a Mask (of type T <: AbstractContainer). This Mask is the result of the application of a randomly selected AbstractSelection from the provided list of AbstractSelection instances selections.\n\nukw: Note:\nAll the given AbstractSelection instances must be of the same type.\n\nState mode\n\nThe state mode of RandomSelectionFromList M is the same as the state mode of the provided list of AbstractSelection instances (which are all of the same type).\n\nSelection type\n\nThe selection type of RandomSelectionFromList M is the same as the selection type of the provided list of AbstractSelection instances (which are all of the same type).\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> s = ProtoSyn.RandomSelectionFromList([rid\"1\", rid\"2\"])\nRandomSelectionFromList ❯ (Residue)\n ├── SerialSelection › Residue.id = 1\n └── SerialSelection › Residue.id = 2\n \njulia> s = ProtoSyn.RandomSelectionFromList([rid\"1\", rn\"CBZ\"])\nERROR: AssertionError: RandomSelectionFromList `selections` elements must be all of the same type.\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.RandomRangeSelection","page":"Selections","title":"ProtoSyn.RandomRangeSelection","text":"RandomRangeSelection{T}() where {T <: AbstractContainer}\n\nA RandomRangeSelection outputs a Mask (of type T <: AbstractContainer) containing a random range of instances of said type in the given container. The considered range is based on the instance's :id.\n\nState mode\n\nThe state mode of RandomRangeSelection M is forced to be Stateless.\n\nSelection type\n\nThe selection type of RandomRangeSelection can be any T <: AbstractContainer.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> sele = RandomRangeSelection{Residue}()\nRandomRangeSelection › Residue.id\n\nukw: Note:\nThis selection assumes that all Abstractcontainer instances are ordered (i.e: a random range between atom 1 and atom 10 will select atoms 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10).\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.TrueSelection","page":"Selections","title":"ProtoSyn.TrueSelection","text":"TrueSelection{T}()\n\nA TrueSelection returns a Mask (of type T <: AbstractContainer) with all entries set to true.\n\nState mode\n\nThe state mode of [TrueSelection] M is forced to be Stateless.\n\nSelection type\n\nThe selection type of RandomRangeSelection can be any T <: AbstractContainer.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nExamples\n\njulia> sele = TrueSelection{Atom}()\nTrueSelection (Atom)\n\njulia> sele = !TrueSelection{Atom}()\nUnarySelection ❯ ! \"not\" (Atom)\n └── TrueSelection (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.UnarySelection","page":"Selections","title":"ProtoSyn.UnarySelection","text":"UnarySelection{M}(op::Function, sele::AbstractSelection)\n\nA UnarySelection applies an operation op to the given AbstractSelection sele. Available operations with short syntax:\n\n! - Logical Not. Negates the values selected by sele.\n\nState mode\n\nThe selection type of UnarySelection can be either Stateless or Stateful. When using the short syntax, it will automatically be set to the StateMode of the provided sele.\n\nSelection type\n\nThe selection type of UnarySelection can be any T <: AbstractContainer. When queried for using the selection_type function, will return the selection type of the given sele.\n\nExamples\n\njulia> sele = !rn\"ALA\"\nUnarySelection ❯ ! \"not\" (Residue)\n └── FieldSelection › Residue.name = ALA\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#Masks","page":"Selections","title":"Masks","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Masks are the primary result of applying a Selection to an AbstractContainer. These are, in essence, arrays of Bool instances, set to true only on the Atom, Residue or Segment instances that satisfy the restrictions imposed by any given selection (or combination of selections). The total size of a Mask is the amount of Atom, Residue or Segment instances in the AbstractContainer the selection is applied to (see Applying selections section).","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Mask","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.Mask","page":"Selections","title":"ProtoSyn.Mask","text":"ProtoSyn.Mask{T}(content::BitVector) where {T <: AbstractContainer}\n\nA Mask is a typed wrapped on a BitArray, and therefore can be N dimensional. Utility functions are provided for Mask instances up to 2D.\n\nProtoSyn.Mask{T}() where {T <: AbstractContainer}\n\nReturn an empty Mask of length 0.\n\nProtoSyn.Mask{T}(n::Int) where {T <: AbstractContainer}\n\nReturn a Mask of length n with all bits set to false.\n\nProtoSyn.Mask{T}(n::Tuple{Int, Int}) where {T <: AbstractContainer}\nProtoSyn.Mask{T}(n1::Int, n2::Int) where {T <: AbstractContainer}\n\nReturn a 2D Mask of size n (or size (n1, n2)) with all bits set to false.\n\nSelection type\n\nThe selection type of a Mask instance can be any T <: AbstractContainer.\n\nukw: Note:\nCombinatory operators (& and |) and unary operators (!) can be employed with Mask instances.\n\nExamples\n\njulia> ProtoSyn.Mask{Atom}()\nProtoSyn.Mask{Atom}(0,)\n0-element BitArray{1}\n\njulia> ProtoSyn.Mask{Residue}((3, 3))\nProtoSyn.Mask{Residue}(3, 3)\n3×3 BitMatrix:\n 0  0  0\n 0  0  0\n 0  0  0\n\njulia> !ProtoSyn.Mask{Atom}(5)\nProtoSyn.Mask{Atom}(5,)\n5-element BitVector:\n 1\n 1\n 1\n 1\n 1\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#Promotion","page":"Selections","title":"Promotion","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Promoting a selection or Mask refers to the act of changing the output selection type. As an example, one could promote the selection rn\"ALA\" (which would output a Mask of Residue instances selected) to output a Mask of Atom instances. Following the notion that core types in ProtoSyn have an established hierarchical relationship (Topology > Segment > Residue > Atom), this type of promotion would be a downwards promotion. The opposite case would be an upwards promotion, such as promoting an\"CB\" to output a Mask of Residue instances instead. In such case, an extra parameter is required: an agregating function. Usually, this is either any (i.e.: select residues that contain at least one CB atom - this is the default) or all (i.e: select residues where all atoms are CB).","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"We have two options for promotion operations:","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"1 | Promote the underlying AbstractSelection, before applying to an AbstractContainer. This is, in essence, an AbstractSelection type by itself;","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"PromoteSelection\nProtoSyn.promote(::AbstractSelection, ::Type{T2}, ::Function) where {T2 <: AbstractContainer}","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.PromoteSelection","page":"Selections","title":"ProtoSyn.PromoteSelection","text":"PromoteSelection(sele::AbstractSelection, ::Type{T}, op::Function) where {T <: AbstractContainer}\n\nA PromoteSelection takes an input selection sele and outputs the same result in a different Mask type, (depending on the operation op requested for upwards promotions). \n\nState mode\n\nThe selection type of PromoteSelection can be either Stateless or Stateful: it will automatically be set to the StateMode of the provided sele on the constructor.\n\nSelection type\n\nThe selection type of PromoteSelection can be any T <: AbstractContainer. When queried for using the selection_type function, will return the selection type of the given sele.\n\nukw: Note:\nThis selection does not have a short syntax version. However, the promote function is used to return PromoteSelection instances with a more user friendly syntax.\n\nExamples\n\njulia> sele = PromoteSelection(rn\"ALA\", Segment, all)\nPromoteSelection ❯ From Residue to Segment\n └── FieldSelection › Residue.name = ALA\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.promote-Union{Tuple{T2}, Tuple{AbstractSelection, Type{T2}, Function}} where T2<:ProtoSyn.AbstractContainer","page":"Selections","title":"ProtoSyn.promote","text":"promote(sele::AbstractSelection, ::Type{T2}, [aggregator::Function = any]) where {T2 <: AbstractContainer}\n\nReturn a PromoteSelection instance for selection sele, promoting to the requested type T2 <: AbstractContainer. If this is an upwards promotion, use the given aggregator function (default: any).\n\nExamples\n\njulia> ProtoSyn.promote(rn\"ALA\", Atom)\nPromoteSelection ❯ From Residue to Atom\n └── FieldSelection › Residue.name = ALA\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"2 | Promote an already calculated Mask instance (by applying the selection - see Applying selections section).","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"ProtoSyn.promote(::Mask{T1}, ::Type{T2}, ::AbstractContainer, ::Function) where {T1 <: AbstractContainer, T2 <: AbstractContainer}\npromote(::Mask{T1}, ::Mask{T2}, ::AbstractContainer) where {T1, T2}","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.promote-Union{Tuple{T2}, Tuple{T1}, Tuple{Mask{T1}, Type{T2}, ProtoSyn.AbstractContainer, Function}} where {T1<:ProtoSyn.AbstractContainer, T2<:ProtoSyn.AbstractContainer}","page":"Selections","title":"ProtoSyn.promote","text":"promote(mask::Mask{T1}, ::Type{T2}, container::AbstractContainer, f::Function = any)::Mask where {T1 <: AbstractContainer, T2 <: AbstractContainer}\n\nCast a Mask of type T1 to be of type T2, in the context of the given container. If casting to a higher ranking type (upwards promotion - Ex. Atom -> Residue), a function f establishes the grouping operation (any occurrence (by default) or all occurrences of lower ranking type must be true to set the higher ranking entry to true.)\n\nExamples\n\njulia> m1 = an\"CB\"(pose);\n\njulia> ProtoSyn.promote(m1, Residue, pose.graph);\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.promote-Union{Tuple{T2}, Tuple{T1}, Tuple{Mask{T1}, Mask{T2}, ProtoSyn.AbstractContainer}} where {T1, T2}","page":"Selections","title":"ProtoSyn.promote","text":"promote(m1::Mask{T1}, m2::Mask{T2}, container::AbstractContainer) where {T1, T2}\n\nPromote one of the 2 given Masks (m1 and m2) to the lowest ranking common type (Ex. promote(m1::Mask{Residue}, m2::Mask{Atom}) => (Mask{Atom}, Mask{Atom)).\n\nExamples\n\njulia> m1 = an\"CB\"(pose);\n\njulia> m2 = rn\"LEU\"(pose);\n\njulia> ProtoSyn.promote(m1, m2, pose.graph);\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/submodules/selections/#Combining-selections","page":"Selections","title":"Combining selections","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Two selections can be combined using logical operators (such as or and and), returning a BinarySelection. The resulting selection's StateMode and selection type depend on the two merged selections.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"BinarySelection","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.BinarySelection","page":"Selections","title":"ProtoSyn.BinarySelection","text":"BinarySelection(op::Function, left::L, right::R) where {L <: AbstractSelection, R <: AbstractSelection}\n\nA BinarySelection merges two selections using different operators op, such as and and or. Return a new BinarySelection that combines both left and right AbstractSelections, using the defined operator op.\n\nState mode\n\nIf the defined selections have the same state mode, the resulting mask will be of that state mode. If the defined selections have different state modes (Ex: Stateless and Stateful) the resulting selection will have a Stateful state mode.\n\nSelection type\n\nIf the defined have the same selection type, the resulting mask will be of that type. If the defined selections have different selection types (Ex: Atom and Residue), the resulting mask will be promoted to the lowest ranking type (Ex: Atom).\n\nSee also\n\nPromotion\n\nShort syntax\n\n... & ...\n... | ...\n\nukw: Note:\nBinarySelection instances are left-dominant, meaning that a grouping of logical operators such as rn\"ALA\" & rn\"LEU\" | an\"CA\" will first resolve the rn\"ALA\" & rn\"LEU\" part (which should return an all-false Mask) and only then combine this Mask with the | an\"CA\" BinarySelection, thus essentially selecting only the CA atoms of the AbstractContainer its applied to.However, selections respect to parenthesis grouping, meaning rn\"ALA\" & (rn\"LEU\" | an\"CA\") will first resolve rn\"LEU\" | an\"CA\" (which should return a Mask selecting all atoms of all LEU residues plus the CA atoms of all other residues) and only then combine this Mask with the rn\"ALA\" & BinarySelection, thus essentially selecting only the CA atoms of any ALA residues of the AbstractContainer its applied to.\n\nExamples\n\njulia> sele = BinarySelection(&, rn\"ALA\", an\"CA\")\nBinarySelection ❯  & \"and\" (Atom)\n ├── FieldSelection › Residue.name = ALA\n └── FieldSelection › Atom.name = CA\n\njulia> rn\"ALA\" & an\"CA\"\nBinarySelection ❯  & \"and\" (Atom)\n ├── FieldSelection › Residue.name = ALA\n └── FieldSelection › Atom.name = CA\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn selections3)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 3 | An example of a possible combination of AbstractSelection types, in ProtoSyn. In this example, two FieldSelection instances (an\"CA\" and rn\"ALA\") are combined using a BinarySelection, with operation op being the & (\"and\"), effectly selecting all Atom instances in a given Pose who are CA atoms belonging to an ALA residue. This AbstractSelection is further used as input for a DistanceSelection, selecting all Atom instances within 10.0 Å of a CA atom in an ALA residue. Since FieldSelection instances act directly on a given Pose instance (and not on other AbstractSelection instances), these are said to be \"leaf selections\", in contrast with \"branch selections\". Branch selections act on other AbstractSelection instances. For example, the BinarySelection combines two AbstractSelection instances with a given operator op. ","category":"page"},{"location":"protosyn-api/core/submodules/selections/#Applying-selections","page":"Selections","title":"Applying selections","text":"","category":"section"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"As stated in the Masks section, selections are applied to AbstractContainer instances, selecting all elements of the desired selection type in that container. This is known as resolving the selection. All AbstractSelection instances are actually functors, meaning that selections are callable objects.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"using ProtoSyn\nusing ProtoSyn.Peptides\nres_lib = Peptides.grammar(Float64)\npose = ProtoSyn.build(res_lib, seq\"GAME\")","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"rn\"ALA\"(pose.graph)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"ukw: Note:\nWhen applying BinarySelection instances, note the need for parenthesis to highlight what is part of the selection, to avoid syntax errors. The same applies to compound selections, such as DistanceSelection instances, for example.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(rn\"ALA\" & an\"CA\")(pose)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"As stated before, Stateful selections require a State to calculate the selection. Given the syntax used, there are two ways of providing the State:","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(10:rn\"ALA\")(pose.graph)(pose.state)\n(10:rn\"ALA\")(pose.graph, pose.state)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"In such cases, the second syntax (sele(pose.graph, pose.state)) is recomended.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Specific methods are available to apply selections to Pose instances, in particular. In this cases, the methods automatically calls sele(pose.graph, pose.state)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"(10:rn\"ALA\")(pose)\nrn\"ALA\"(pose)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"Finally, selections (and Mask) can be gathered. This, in essence, means looping over the resolved Mask and appending the actual selected Atom, Residue or Segment instances. This process can be done in one of two ways:","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"1 | By using the optional flag gather when applying a selection to an AbstractContainer (recommended);","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"an\"^C.*$\"r(pose, gather = true)","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"2 | By directly calling the function gather.","category":"page"},{"location":"protosyn-api/core/submodules/selections/","page":"Selections","title":"Selections","text":"gather","category":"page"},{"location":"protosyn-api/core/submodules/selections/#ProtoSyn.gather","page":"Selections","title":"ProtoSyn.gather","text":"ProtoSyn.gather(mask::Mask{T}, container::AbstractContainer) where {T <: AbstractContainer}\n\nGather all instances of type T from container whose relative position is marked as true in the given mask.\n\nExamples\n\njulia> ProtoSyn.gather(rn\"ALA\"(pose), pose.graph)\n4-element Vector{Residue}:\n Residue{/UNK:1/UNK:1/ALA:5}\n Residue{/UNK:1/UNK:1/ALA:12}\n Residue{/UNK:1/UNK:1/ALA:13}\n Residue{/UNK:1/UNK:1/ALA:20}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/sugars/introduction/#Sugars","page":"Introduction","title":"Sugars","text":"","category":"section"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"Besides the Core module, ProtoSyn comes with several other extra modules that build on top of and expand the base methods, types and submodules. These ProtoSyn modules are specific for a given topic. In the case of the Sugars module, all new or expanded methods and types explore the topic of carbohydrates simulation and ramified sugar structures, including glycoproteins. With this extra constraint, most methods can be especialized.","category":"page"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"In sum, the Sugars module makes available several methods, types and submodules specific for ramified polysaccharide structures.","category":"page"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"ukw: Note:\n🛠 Under construction. This module is not finished: several bugs and incomplete features can be found. The existing code is provided as is, and should be mainly used for further improvement and development.","category":"page"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"In order to use this module, including the following call is often useful:","category":"page"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn","category":"page"},{"location":"protosyn-api/sugars/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn.Sugars","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/#peptides-selection","page":"Selections","title":"Selections","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"The Selections is a submodule of ProtoSyn.Peptides module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"As an expansion of the Core module Selections, this submodule introduces some protein speciic AbstractSelection types:","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"PolarSelection","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/#ProtoSyn.PolarSelection","page":"Selections","title":"ProtoSyn.PolarSelection","text":"PolarSelection()\n\nA PolarSelection outputs a Mask of Residue instances where the polar aminoacids are marked as true (as defined in ProtoSyn.Peptides.polar_residues).\n\nState mode\n\nThe state mode of PolarSelection M is forced to be Stateless\n\nSelection type\n\nThe selection type of PolarSelection T is forced to be Residue.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nukw: Note:\nThis selection is provided by the Peptides module but registered under ProtoSyn Core module, in order to directly accessible and merged with other AbstractSelection instances.\n\nExamples\n\njulia> PolarSelection()\nPolarSelection › (Residue)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn Polar Selection)","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 1 | An example of a PolarSelection application.","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"SidechainSelection","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/#ProtoSyn.SidechainSelection","page":"Selections","title":"ProtoSyn.SidechainSelection","text":"SidechainSelection()\n\nA SidechainSelection outputs a Mask of Atom instances where the sidechain atoms are marked as true (all atoms not named C, H, CA, N or O).\n\nState mode\n\nThe state mode of SidechainSelection M is forced to be Stateless\n\nSelection type\n\nThe selection type of SidechainSelection T is forced to be Atom.\n\nukw: Note:\nThis selection does not have a short syntax version.\n\nukw: Note:\nThis selection is provided by the Peptides module but registered under ProtoSyn Core module, in order to directly accessible and merged with other AbstractSelection instances. \n\nExamples\n\njulia> SidechainSelection()\nSidechainSelection › (Atom)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn Sidechain Selection)","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 2 | An example of a SidechainSelection application.","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"SecondaryStructureSelection","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/#ProtoSyn.SecondaryStructureSelection","page":"Selections","title":"ProtoSyn.SecondaryStructureSelection","text":"SecondaryStructureSelection(ss::Symbol, [threshold::Float64 = 0.87])\n\nA SecondaryStructureSelection outputs a Mask of Residue instances where the residues are marked as true if the current phi and psi dihedrals are within the threshold angular distance (in radians, 50° by default) of the reference values for the requested ss SecondaryStructure type.\n\nState mode\n\nThe state mode of SidechainSelection M is forced to be Stateful\n\nSelection type\n\nThe selection type of SidechainSelection T is forced to be Residue.\n\nShort syntax\n\nss\"helix\" = Helix secondary structure\nss\"parallel_sheet\" = Parallel beta sheet secondary structure\nss\"antiparallel_sheet\" = Antiparallel beta sheet secondary structure\nss\"linear\" = Linear secondary structure\n\nukw: Note:\nThis selection is provided by the Peptides module but registered under ProtoSyn Core module, in order to directly accessible and merged with other AbstractSelection instances. \n\nExamples\n\njulia> SecondaryStructureSelection(:parallel_sheet, deg2rad(20))\nSecondaryStructureSelection › parallel_sheet (± 20.0°)\n\njulia> ss\"helix\"\nSecondaryStructureSelection › helix (± 50.0°)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"(Image: ProtoSyn SS Selection)","category":"page"},{"location":"protosyn-api/peptides/submodules/selections/","page":"Selections","title":"Selections","text":"Figure 3 | An example of a SecondaryStructureSelection application.","category":"page"},{"location":"protosyn-api/peptides/introduction/#Peptides","page":"Introduction","title":"Peptides","text":"","category":"section"},{"location":"protosyn-api/peptides/introduction/","page":"Introduction","title":"Introduction","text":"Besides the Core module, ProtoSyn comes with several other extra modules that build on top of and expand the base methods, types and submodules. These ProtoSyn modules are specific for a given topic. In the case of the Peptides module, all new or expanded methods and types are referring to the peptide and protein structures. With this extra constraint, most methods can be especialized: the ProtoSyn.unbond!, for example, is specialized in ProtoSyn.Peptides.unbond!, automatically unbonding the C atom to the next aminoacid's N atom - the peptidic bond.","category":"page"},{"location":"protosyn-api/peptides/introduction/","page":"Introduction","title":"Introduction","text":"In sum, the Peptides module makes available several methods, types and submodules specific for proteins and peptide structures.","category":"page"},{"location":"protosyn-api/peptides/introduction/","page":"Introduction","title":"Introduction","text":"In order to use this module, including the following call is often useful:","category":"page"},{"location":"protosyn-api/peptides/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn","category":"page"},{"location":"protosyn-api/peptides/introduction/","page":"Introduction","title":"Introduction","text":"using ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpillar Solvation","title":"Caterpillar Solvation","text":"CurrentModule = ProtoSyn.Peptides.Calculators.Caterpillar","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#Caterpillar-Solvation","page":"Caterpillar Solvation","title":"Caterpillar Solvation","text":"","category":"section"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpillar Solvation","title":"Caterpillar Solvation","text":"The Caterpillar Solvation energy is a coarse-grained approximation to a solvation energy energetic contribution, introducing both a penalty for the exposure of hydrophobic Residue instances and a penalty for the burial of hydrophylic aminoacids. ","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpillar Solvation","title":"Caterpillar Solvation","text":"calc_solvation_energy\nget_default_solvation_energy","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#ProtoSyn.Peptides.Calculators.Caterpillar.calc_solvation_energy","page":"Caterpillar Solvation","title":"ProtoSyn.Peptides.Calculators.Caterpillar.calc_solvation_energy","text":"Calculators.calc_solvation_energy([::A], pose::Pose, update_forces::Bool = false; Ω::Int = 24, rmax::T = 12.0, sc::T = 5.0) where {A, T <: AbstractFloat}\n\nCalculate the given Pose pose solvation energy according to the Caterpillar model. In this model, a Residue is considered buried if more than N other Residue instances (their Cα Atom instances) are within a defined cut-off value. Buried hydrophobic aminoacids receive an energetic reward, while exposed hydrophobic Residue instances receive a penalty (and vice-versa for hydrophylic aminoacids).  The model can be fine-tuned: Ω defines the minimum number of Cɑ-Cɑ contacts to consider a residue 'burried'; rmax defines the minimum distance between Cɑ's for a contact to be considered (in Angstrom Å); sc defines the 'slope control' (a higher value defines more sharply when to consider a contact). Finally, an hydrophobic map can be provided (hydrophob_map), with the penalty/reward for correct burial/exposal of hydrophobic/hydrophilic residues, respectively. Other map examples can be found in Peptides.constants.jl. The optional A parameter defines the acceleration mode used (SISD0, SIMD1 or CUDA2). If left undefined the default ProtoSyn.acceleration.active mode will be used. This function does not calculate forces (not applicable), and therefore the `updateforces` flag serves solely for uniformization with other energy-calculating functions.\n\nSee also\n\nget_default_solvation_energy\n\nExamples\n\njulia> ProtoSyn.Peptides.Calculators.Caterpillar.calc_solvation_energy(pose)\n(925.5142248612556, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/#ProtoSyn.Peptides.Calculators.Caterpillar.get_default_solvation_energy","page":"Caterpillar Solvation","title":"ProtoSyn.Peptides.Calculators.Caterpillar.get_default_solvation_energy","text":"get_default_solvation_energy(;α::T = 1.0) where {T <: AbstractFloat}\n\nReturn the default Caterpillar solvation EnergyFunctionComponent. α sets the component weight (on an EnergyFunction).\n\nSolvation energy settings\n\n:Ω -> defines the minimum number of Cα-Cα contacts to consider a Residue 'burried';\n:sc -> defines the 'slope control' (a higher value defines more sharply when to consider a contact);\n:hydrophob_map -> Dict{Symbol, Any} with the reward/penalty for correct burial/exposal of hydrophobic/hydrophilic Residue instances;\n:rmax -> defines the minimum distance between Cα's for a contact to be considered (in Angstrom Å).\n\nSee also\n\ncalc_solvation_energy\n\nExamples\n\njulia> ProtoSyn.Peptides.Peptides.Calculators.Caterpillar.get_default_solvation_energy()\n         Name : Caterpillar_Solvation\n   Weight (α) : 1.0\nUpdate forces : false\n      Setings :\n            :Ω => 24\n           :sc => 5.0\n:hydrophob_map => Dict(\"PHE\" => 9.8, \"GLN\" => -3.5, \"ASP\" => -3.5, \"LYS\" => -3.9, \"ILE\" => 11.5, \"TYR\" => -1.3, \"GLY\" => -0.4, \"HIE\" => -3.2, \"ASN\" => -3.5, \"ARG\" => -4.5, \"LEU\" => 10.8, \"TRP\" => -0.9, \"ALA\" => 8.8, \"THR\" => -0.7, \"VAL\" => 11.2, \"MET\" => 8.9, \"CYS\" => 9.5, \"SER\" => -0.8, \"PRO\" => -1.6, \"HIS\" => -3.2, \"GLU\" => -3.5)\n        :rmax => 12.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpillar Solvation","title":"Caterpillar Solvation","text":"(Image: ProtoSyn Caterpillar Solvation)","category":"page"},{"location":"protosyn-api/peptides/calculators/caterpillar-solvation/","page":"Caterpillar Solvation","title":"Caterpillar Solvation","text":"Figure 1 | A diagram representation of the Caterpillar Solvation EnergyFunctionComponent. The energy penalty is proportional to the hydrophobicity value (in the hydrophobicity map) multiplied by the excess number of Cα contacts (above Ω).","category":"page"},{"location":"protosyn-api/core/mutators/mutators-dihedral/","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"CurrentModule = ProtoSyn.Mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-dihedral/#Dihedral-Mutator","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-dihedral/","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"A DihedralMutator instance changes a Pose State by introducing one or more dihedral rotations.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-dihedral/","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"DihedralMutator","category":"page"},{"location":"protosyn-api/core/mutators/mutators-dihedral/#ProtoSyn.Mutators.DihedralMutator","page":"Dihedral Mutator","title":"ProtoSyn.Mutators.DihedralMutator","text":"DihedralMutator(angle_sampler::Function, p_mut::AbstractFloat, step_size::AbstractFloat, selection::Opt{AbstractSelection})\n\nReturn a new DihedralMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(dihedral_mutator::DihedralMutator)(pose::Pose)\n\nThe DihedralMutator AbstractMutator loops through all the Atom instances in a given Pose and applies a new dihedral angle if a random number (rand()) is bellow a given probability of mutation p_mut (therefore a higher p_mut value applies a larger number of dihedral rotations per call). The applied rotation is an angle value (in radians), sampled by calling angle_sampler and multiplied by the step_size value. The resulting value is then added to the selected Atom.Δϕ. Note that a new dihedral rotation is sampled for each selected Atom instance. If an AbstractSelection selection is provided, only the selected Atom instances are looped over. If the given AbstractSelection selection is not of selection type Atom, it will be promoted to this type (using promote with default aggregator any). Note that the DihedralMutator syncs any pending cartesian to internal coordinate conversion (using the c2i! method). Requests internal to cartesian coordinates conversion (using request_i2c! method). Does not sync! the given Pose afterwards.\n\nThe DihedralMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(dihedral_mutator::DihedralMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\nangle_sampler::Function - Should return a Float angle value (in radians). Is called with no input arguments;\np_mut::AbtractFloat - Compared against a rand() call, applies this Mutator to Atom instances where rand() < p_mut;\nstep_size::AbstractFloat - Multiplies the sampled angle by this value;\nselection::Opt{AbstractSelection} - If given, this Mutator will only loop over the selected Atom instances.\n\nSee also\n\nCrankshaftMutator\n\nExamples\n\njulia> ProtoSyn.Mutators.DihedralMutator(randn, 1.0, 1.0, nothing)\n⚯  Dihedral Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | angle_sampler               | Function randn                 |\n| 2     | p_mut                       | 1.0000                         |\n| 3     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ○  Selection: Not Set\n\njulia> ProtoSyn.Mutators.DihedralMutator(randn, 0.05, 1.0, an\"CA$|C$\"r)\n⚯  Dihedral Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | angle_sampler               | Function randn                 |\n| 2     | p_mut                       | 0.0500                         |\n| 3     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ● Selection: Set\n └── FieldSelection › Atom.name = r\"CA$|C$\"\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/mutators/mutators-dihedral/","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"(Image: ProtoSyn Dihedral Mutator)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-dihedral/","page":"Dihedral Mutator","title":"Dihedral Mutator","text":"Figure 1 | A schematic representation of a DihedralMutator instance. In this example, the selection an\"C$\"r selects only the carbon atoms of the backbone of the peptide, excluding the alpha carbons. The :Δϕ field in this AtomState instance applies a given dihedral rotation to all children Atom instances, therefore setting, in this case, the psi dihedral angle of the backbone of this Residue. As such, by providing the DihedralMutator with this selection, only the psi dihedral angles are being sampled for rotation. Each of the selected Atom instances is looped over and one or more instances can be designated for dihedral angle sampling. This is performed by comparing a random number (by calling rand()) against the DihedralMutator.p_mut field, for each of the looped Atom instances. If the random number is lower, the current Atom instance is selected. A high value for p_mut therefore translates into a higher number of dihedral rotations in a single call to the DihedralMutator. As a general rule, using a p_mut value of 1/N will result in 1 rotation per call of the DihedralMutator, on average (where N is the number of atoms in the Pose or number of selected atoms by selection). To sample a new dihedral angle, the DihedralMutatorangle_sampler is called (with no input arguments) and multiplied by the DihedralMutator.step_size field. This value is added to the selected AtomState.Δϕ.","category":"page"},{"location":"getting-started/first-steps/#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"getting-started/first-steps/#Introduction","page":"First steps","title":"Introduction","text":"","category":"section"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"The rational placement of amino acids in a sequence directly correlates to the 3D structure of the peptide once folded. This folded structure, in turn, dictates the interactions with the environment and therefore the function of the peptide. Being able to design new peptides for specific functions would unlock the potential of unknown conformations not yet explored by nature, with applications in medical fields, agriculture, biological remediation, enzymatic synthesis, among others. ","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"This was traditionally explored by random blind mutagenesis which is an expensive and time intensive experimental practice. With the evolution of computational power over the last couple of decades, computational design of small proteins has become the focus of scientific breakthroughs. Using computer simulations saves precious time and monetary costs of experiments, focusing efforts on simulated prototypes that have shown promising results. As such, multiple software solutions have been proposed over the years. An example would be Rosetta (and its Python wrapper, PyRosetta), which has been indisputably invaluable as a platform for molecular manipulation and peptide design.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"However, as it happens with so many scientific-purposed software packages, Rosetta has fallen into the two-language problem. The core of the simulation code is written in C with a more user-friendly wrap in Python that exposes some of the functionality. This has gravelly impaired the community's ability to upgrade and modify this package, as well as imposing a steep learning curve to non-specialized would-be-users.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"ProtoSyn.jl, empowered by the Julia language ecosystem, aims to put forward a simple and easy to use platform for molecular manipulation and peptide design. A Julia-based solution to this challenge would naturally benefit from the native features of the language, such as easy parallelization and distributed computing, GPU acceleration and machine learning tools, among others.","category":"page"},{"location":"getting-started/first-steps/#How-is-ProtoSyn-organized?","page":"First steps","title":"How is ProtoSyn organized?","text":"","category":"section"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"(Image: organization)","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"ProtoSyn.jl's main struct is the Pose, which holds all the required information regarding a molecular system. This information is divided into a Directional graph and a State.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"A directional graph is simply an hierarchical structuration of the molecular system: At the top level, a Topology can hold multiple Segment instances (which are contiguous chains of a molecule), which in turn can hold multiple Residue instances (such as amino acids, in the case of proteins and peptides), which, finally, hold one or multiple Atom instances.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"Each of these levels are called AbstractContainers and can have defining parameters. In the case of atoms, for example, an Atom instance is described by an :id, :symbol, :name, etc.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"This graph is called directional because each of these components has a parent and can have one or more children containers. In the case of Residue instances, for example, consider the sequence ALA-GLC-PRO. In such a molecule, ALA would be the parent of GLC which, in turn, would be the parent of PRO. The same logic applies to relationships between atoms. This structural organization allows ProtoSyn to then infer parenthood up to N levels. When conjugated with the internal coordinates system, this allows for easy and fast manipulation of dihedral angles, for example.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"The information regarding these internal coordinates (and cartesian coordinates) is organized in the pose's State. This is subdivided into a list of AtomState instances and a StateMatrix. Both of these structures are interchangable, meaning that altering a value in StateMatrix updates the corresponding value in the correct AtomState and vice-versa. The rational behind having both structures lies in having the ease/speed of changing a large volume of coordinates in the StateMatrix at once, while still being able to control internal coordinates in single atoms using the AtomState.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"In order to initialize the internal coordinate system, each Topology has an extra set of 3 pseudo atoms, called a Root, that sets-up the ascendents for the first few atoms of the molecule.","category":"page"},{"location":"getting-started/first-steps/#Mutators,-Energy-Functions-and-Drivers","page":"First steps","title":"Mutators, Energy Functions & Drivers","text":"","category":"section"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"(Image: organization)","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"ProtoSyn.jl offers some quick simulation functionalities, such as MonteCarlo, ILS and SteepestDescent simulations, using Driver instances (see Drivers section). A Driver is a function which drives the pose from one state to the next. As a general rule, these Drivers are usually comprised of two important components: one of more Mutator instancea (see Mutators section) and an Energy Function (see Calculators section).","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"A Mutator is a function that performs a single change in the system. For example, a DihedralMutator will rotate a random dihedral by a random amount. These can be parametrized for more specific needs.","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"An EnergyFunction evaluates the fitness of a given Pose based on a set of EnergyFunctionComponent instances. These can be distance-based restrictions, positional agreement with machine learning models (such as TorchANI), etc. ","category":"page"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"ukw: Note:\nSome commonly used EnergyFunction instances can be found in the Common module.","category":"page"},{"location":"getting-started/first-steps/#Modular-system","page":"First steps","title":"Modular system","text":"","category":"section"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"ProtoSyn.jl package is organized in a modular fashion, with each new module adding specific methods and features relative to a given scientific area of expertise. All these modules build on top of the base Core module. For example, in the Core module, ProtoSyn.load is able to read a PDB file into a Pose struct, but calling ProtoSyn.Peptides.load (from the Peptides module) will also infer peptidic connections between amino acids, setting the correct parenthood relationships between residues in the pose's graph and returning a much more information complete Pose.","category":"page"},{"location":"getting-started/first-steps/#Next-steps","page":"First steps","title":"Next steps","text":"","category":"section"},{"location":"getting-started/first-steps/","page":"First steps","title":"First steps","text":"Check the Examples page for some initial tutorials on how to use some of ProtoSyn.jl's functionalities.\nIf you want a deeper dive into the inner workings of this package, check the ProtoSyn.jl API section.\nCreate a new issue at the ProtoSyn.jl GitHub if you have any question.\nFeel free to collaborate and commit new changes to ProtoSyn.jl. If you require any assistance, please contact jose.manuel.pereira@ua.pt.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/methods/graph/#core-graph-methods","page":"Graph","title":"Graph","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"This section lists functions that work on the system Graph, such as functions that deal with parent/child relations, indexes and bonds, among others. These are subdivided by topics, for organization purposes:","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Root vs Origin\nParenthood relationships\nContainer manipulation\nIndexation\nCounters and Iterators\nBonds","category":"page"},{"location":"protosyn-api/core/methods/graph/#Root-vs-Origin","page":"Graph","title":"Root vs Origin","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"The root of a Graph is a set of 3 pseudoatoms belonging to a Topology, acting as the anchor for internal coordinate calculations, while an origin is any Atom instance with no parent in any given container (for example, due to a cut). While a Pose can only have 1 root, it can have multiple origins (which usually need to be reconnected for most of the simulations of ProtoSyn).","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"origin\nroot","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.origin","page":"Graph","title":"ProtoSyn.origin","text":"origin(container::AbstractContainer)\n\nReturn the first Atom in AbstractContainer container that has no parent. The iteration follows the Atom instance :id field, if correctly indexed. If no Atom instance without parent is found (i.e.: circular structures), return nothing. Note that the root atoms are not considered. \n\nSee also\n\nroot reindex\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.root","page":"Graph","title":"ProtoSyn.root","text":"root(container::AbstractContainer)\n\nReturn the first Atom of the Root of the Graph that given AbstractContainer container belongs to. If the given AbstractContainer container is not a Topology instance and has :container field set to nothing, return nothing.\n\nroot(topology::Topology)\n\nReturn the first Atom of the Root of the given Topology topology instance.\n\nSee also\n\norigin\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#Parenthood-relationships","page":"Graph","title":"Parenthood relationships","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Atom and Residue instances have parenthood relationships, in a directional Graph. Several methods allow the manipulation of such relationships, and are of additional importance when using internal coordinates to facilitate and speed up some calculations.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"hasparent\nisparent\nsetparent!\npopparent!\nascendents\nBase.detach\ntravel_graph\nis_contiguous","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.hasparent","page":"Graph","title":"ProtoSyn.hasparent","text":"hasparent(c::AbstractContainer) -> Bool\n\nTest whether the given AbstractContainer c has a parent.\n\nSee Also\n\nisparent\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.isparent","page":"Graph","title":"ProtoSyn.isparent","text":"isparent(parent::AbstractContainer, child::AbstractContainer)\n\nTest whether parent is the parent of child.\n\nSee Also\n\nhasparent\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.setparent!","page":"Graph","title":"ProtoSyn.setparent!","text":"setparent!(child::T, parent::T) where {T <: AbstractContainer}\n\nSet parent as the parent of child, while adding child to parent.children.\n\nSee also\n\npopparent!\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.popparent!","page":"Graph","title":"ProtoSyn.popparent!","text":"popparent!(child::AbstractContainer}\n\nRemove the parent from child (sets it to nothing) while removing child from parent.children (only if child is a child of parent).\n\nSee also\n\nsetparent!\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.ascendents","page":"Graph","title":"ProtoSyn.ascendents","text":"ascedents(container::AbstractContainer, level::Int)\n\nReturn a Tuple containing the N (level) previous :id fields of the :parent AbstractContainer instances of the given container (recursivelly).\n\nExamples\n\njulia> ascendents(pose.graph[1][1][4], 4)\n(4, 3, 1, 0)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#Base.detach","page":"Graph","title":"Base.detach","text":"detach(segment::Segment)\n\nDetach and return the given Segment from it's container Graph, by:\n\nDetaching any Atom and Residue instance from the Graph's Root (by popping parenthood relationships), if said instances belong to the given Segment instance.\nDeleting this Segment from its container Topology. \n\nThis function is a Base module overload.\n\nukw: Note:\nThis function does not alter the State of the Pose containing the provided Segment. \n\nExamples\n\njulia> detach(pose.graph[1])\nSegment{/UNK:1}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.travel_graph","page":"Graph","title":"ProtoSyn.travel_graph","text":"travel_graph(start::Atom; [stop::Opt{Atom} = nothing])\n\nReturn a Vector{Atom} with all atom instances between Atom start and stop, while following the structure's Graph. If no stop Atom instance is provided or if it isn't found as a downstream parent of the start Atom, all instances until no children Atom instances are found are returned (for example, until the end of the current Pose of Segment). Note that the order of the returned Atom instances reflects the organization of the graph followed, and not the distance/parenthood to the start Atom, and should therefore be ignored in most cases.\n\nSee also\n\nis_contiguous hasparent setparent!\n\nExamples\n\njulia> ProtoSyn.travel_graph(pose.graph[1][end][10])\n4-element Vector{Atom}:\n Atom{/UNK:1/UNK:1/LEU:21/CD1:334}\n Atom{/UNK:1/UNK:1/LEU:21/HD13:337}\n Atom{/UNK:1/UNK:1/LEU:21/HD12:336}\n Atom{/UNK:1/UNK:1/LEU:21/HD11:335}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.is_contiguous","page":"Graph","title":"ProtoSyn.is_contiguous","text":"is_contiguous(pose::Pose, selection::AbstractSelection)\n\nReturns true if all the Residue instances gathered from the selection applied to the given pose are contiguous (have a parenthood relationship connecting them all). Note that the given selection is always promoted to Residue level.\n\nSee also\n\nProtoSyn.promote\n\nExamples\n\njulia> ProtoSyn.is_contiguous(pose, rid\"1\" | rid\"3\")\nfalse\n\njulia> ProtoSyn.is_contiguous(pose, rid\"1:10\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"(Image: ProtoSyn graph)","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Figure 1 | A diagram of a directional Graph in ProtoSyn.","category":"page"},{"location":"protosyn-api/core/methods/graph/#Container-manipulation","page":"Graph","title":"Container manipulation","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Atom instances have a :container field, setting the container AbstractContainer (usually a Residue instance). The same logic applies to Residue instances, inside Segment structs, and Segment instances inside Topology structs (according to the established hierarchy of AbstractContainer instances). The following methods allow for the correct manipulation of this relations, allowing to add and remove AbstractContainer instances from the respective :container field, as well as creating copies of them.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"hascontainer\nBase.push!(::AbstractContainer{T}, ::T) where {T<:AbstractContainer}\nBase.insert!(::AbstractContainer{T}, ::Integer, ::T) where {T <: AbstractContainer}\nBase.delete!(::AbstractContainer{T}, ::T) where {T<:AbstractContainer}\nBase.copy(::Atom)","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.hascontainer","page":"Graph","title":"ProtoSyn.hascontainer","text":"hascontainer(c::AbstractContainer)\n\nReturn true if the given AbstractContainer.container is not nothing.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#Base.push!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T<:ProtoSyn.AbstractContainer","page":"Graph","title":"Base.push!","text":"push!(container::AbstractContainer{T}, item::T) where {T <: AbstractContainer}\n\nAdd an AbstractContainer item to the AbstractContainer container, updating the container size and setting the correct item.container. Return the altered container.\n\npush!(residue::Residue, atom::Atom)\n\nIn the specific case of adding an Atom atom to a Residue residue, also add the atom.name to the residue.itemsbyname dictionary for correct indexation by name. Return the altered Residue residue.\n\npush!(container::AbstractContainer{T}, items::Vector{T}) where {T <: AbstractContainer}\n\nAdd a vector of AbstractContainer items in the AbstractContainer container, updating the container size and setting the correct item.container for each item in the items. Note that this method keeps the order of items. Return the altered container.\n\nThis function is a Base module overload.\n\nukw: Note:\nThis function does not set any Bonds or Parenthood relationships to other items in the same container. This function does not set a complementary State.\n\nSee also\n\ninsert! delete!\n\nExamples\n\njulia> push!(pose.graph[1][1], Atom(\"CA\", -1, -1, \"C\"))\nResidue{/UNK:1/UNK:1/SER:1}\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/graph/#Base.insert!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, Integer, T}} where T<:ProtoSyn.AbstractContainer","page":"Graph","title":"Base.insert!","text":"insert!(container::AbstractContainer{T}, index::Integer, item::T) where {T <: AbstractContainer}\n\nInsert an AbstractContainer item in the AbstractContainer container at the given index, updating the container size and setting the correct item.container. Return the altered container.\n\ninsert!(container::Residue, index::Integer, item::Atom)\n\nIn the specific case of inserting an Atom atom in a Residue residue, also add the atom.name to the residue.itemsbyname dictionary for correct indexation by name. Return the altered Residue residue.\n\ninsert!(container::AbstractContainer{T}, index::Integer, items::Vector{T}) where {T <: AbstractContainer}\n\nInsert a vector of AbstractContainer items in the AbstractContainer container at the given index, updating the container size and setting the correct item.container for each item in the items. Note that this method keeps the order of items. Return the altered container.\n\nThis function is a Base module overload.\n\nukw: Note:\nThis function does not set any Bonds or Parenthood relationships to other items in the same container. This function does not set a complementary State.\n\nSee also\n\npush! delete!\n\nExamples\n\njulia> insert!(pose.graph[1][1], 3, Atom(\"CA\", -1, -1, \"C\"))\nResidue{/UNK:1/UNK:1/SER:1}\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/graph/#Base.delete!-Union{Tuple{T}, Tuple{ProtoSyn.AbstractContainer{T}, T}} where T<:ProtoSyn.AbstractContainer","page":"Graph","title":"Base.delete!","text":"delete!(container::AbstractContainer{T}, item::T) where {T <: AbstractContainer}\n\nDelete the given AbstractContainer item from the AbstractContainer container, if found, while updating the container.size and item.container fields. In the specific case of deleting an Atom instance from a Residue, update container.itemsbyname as well. Return the altered container. If the given AbstractContainer item is not found in the AbstractContainer container, return nothing.\n\nSee also\n\npush! insert!\n\nExamples\n\njulia> delete!(pose.graph[1][1], pose.graph[1][1][\"CA\"])\nResidue{/UNK:1/UNK:1/SER:1}\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/graph/#Base.copy-Tuple{Atom}","page":"Graph","title":"Base.copy","text":"copy(container::AbstractContainer)\n\nReturn a copy of the given AbstractContainer container. Note that for Residue instances only the intra-residue Bonds and Parenthood relationships can be copied. The same logic applies to the intra-segment Graph.\n\nExample\n\njulia> copy(pose.graph[1, 1, 1])\nAtom{/N:1}\n\njulia> copy(pose.graph[1, 1])\nResidue{/SER:1}\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/graph/#core-graph-methods-indexation","page":"Graph","title":"Indexation","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"An important initial detail when describing the Graph methods is describing the family of getindex methods overloaded by ProtoSyn when dealing with Graph structures. There is, in essence, 4 ways to access a specific instance in the Graph:","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Using the regular syntax;","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"using ProtoSyn\nusing ProtoSyn.Peptides\nres_lib = Peptides.grammar(Float64)\npose = ProtoSyn.build(res_lib, seq\"GME\")","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"pose.graph.items[1].items[1].items[1]\npose.graph.items[1].items[1]","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Using the short syntax with index;","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"pose.graph[1][1][1]\npose.graph[1][1]","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Using the condensed syntax with index;","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"pose.graph[1, 1, 1]\npose.graph[1, 1]","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Using the short or condensed syntax with atom name (for Atom instances only).","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"pose.graph[1][1][\"N\"]\npose.graph[1, 1, \"N\"]","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"Note that queries by Atom.name are case sensitive. Besides using it to get Graph structures, Atom.name fields can also be used to query for existence:","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"\"N\" in pose.graph[1][1]","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"The following methods deal with the correct indexation of the Graph. Note that, altough not necessary, some simulation functions assume that both the Graph and State indexation of a Pose are synched and are equal.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"genid\nreindex(::Topology; ::Bool)\nids","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.genid","page":"Graph","title":"ProtoSyn.genid","text":"genid()\n\nReturn a random UInt16 number.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.reindex-Tuple{Topology}","page":"Graph","title":"ProtoSyn.reindex","text":"reindex(topology::Topology; set_ascendents = true)\n\nRe-indexes the whole Topology topology, setting both the :id and :index of instances inside the topology to the corresponding relative index in the container.items which they belong to. If set_ascendents is set to true (is, by default), each Atom instance :ascendents field will be updated to reflect the new indices.\n\nreindex(segment::Segment)\n\nRe-indexes a Segment segment, setting both the :id and :index of instances inside the topology to the corresponding relative index in the container.items which they belong to.\n\nSee also\n\nascendents reindex(::State)\n\nExamples\n\njulia> reindex(pose.graph)\nTopology{/UNK:1}\n\njulia> reindex(pose.graph[1])\nSegment{/UNK:1/UNK:1}\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.ids","page":"Graph","title":"ProtoSyn.ids","text":"ids(atoms::Vector{Atom})\n\nReturn a vector with the :id Int field for every Atom in the given atoms vector.\n\nSee also\n\ntravel_graph\n\nExamples\n\njulia> ProtoSyn.ids(an\"CA\"(pose, gather = true))\n21-element Vector{Int64}:\n   3\n  14\n  29\n  40\n  55\n  65\n   ⋮\n 243\n 257\n 281\n 300\n 317\n 327\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#Counters-and-Iterators","page":"Graph","title":"Counters and Iterators","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"ProtoSyn includes custom Counters and Iterators to analyze and loop over Graph structures. In one hand, by using Counters the user can count the number of sub AbstractContainer instances in a Graph component (for example, the number of Atom instances in a Segment or a Residue). This can be achieved by using the count_atoms, count_residues and count_segments methods.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"ProtoSyn.count_atoms(pose.graph)\nProtoSyn.count_atoms(pose.graph[1][1])\nProtoSyn.count_residues(pose.graph)","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"On the other hand, Iterators allow the user to iterate over all sub AbstractContainer instances in a Graph component, by using the eachatom, eachresidue and eachsegment methods.","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"eachatom(pose.graph)\nfor residue in eachresidue(pose.graph[1])\n    println(residue);\nend","category":"page"},{"location":"protosyn-api/core/methods/graph/#Bonds","page":"Graph","title":"Bonds","text":"","category":"section"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"The following methods deal with the bonding/unbonding of atoms (and respective Parenthood relationships when using the join function).","category":"page"},{"location":"protosyn-api/core/methods/graph/","page":"Graph","title":"Graph","text":"bond\nunbond!\njoin","category":"page"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.bond","page":"Graph","title":"ProtoSyn.bond","text":"bond(at1::Atom, at2::Atom)\n\nBond both given Atom instances (adds at2 to at1.bonds and vice-versa). Both Atom instances need to be in the same Segment.\n\nSee also\n\njoin unbond!\n\nExamples\n\njulia> ProtoSyn.bond(pose.graph[1][1][\"C\"], pose.graph[1][2][\"CA\"])\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.unbond!","page":"Graph","title":"ProtoSyn.unbond!","text":"unbond!(pose::Pose, at1::Atom, at2::Atom; [keep_downstream_position::Bool = true])::Pose\n\nReturn a Pose instance with both given Atom instances unbonded (removed from eachother bonds list, pops parenthood and sets the downstream Residue.parent field to be the Root of the upstream Topology). If keep_downstream_position is set to true (is, by default), the downstream Residue position is maintained (by calling request_c2i! and sync! methods). \n\nukw: Note:\nUnbonding two atoms also removes any parenthood relationship, therefore making the returned Pose from this function un-usable without further changes (the internal coordinates graph is severed on the unbonding site).\n\nExamples\n\njulia> unbond!(pose, pose.graph[1][2][\"C\"], pose.graph[1][3][\"N\"])\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/graph/#ProtoSyn.join","page":"Graph","title":"ProtoSyn.join","text":"join(at1::Atom, at2::Atom)\n\nJoin Atom at1 with Atom at2.\n\njoin(r1::Residue, s1::String, r2::Residue, s2::String)\n\nJoin Atom named s1 from Residue r1 with Atom named s2 from Residue r2.\n\nBond (add eachother to other.bonds field) and set parent/children relationship of both the Atom instances and respective atom.container (Residue). Note that at2 Atom will become parent at at1 (and at2.container Residue will become parent of at1.container).\n\nSee also\n\nbond unbond!\n\nExamples\n\njulia> Residue!(pose.graph[1], ProtoSyn.ResidueName(\"ALA\"), 1);\n\njulia> Atom!(pose.graph[1][end], \"N\", 1, 1, \"N\");\n\njulia> ProtoSyn.join(pose.graph[1][1], \"C\", pose.graph[1][end], \"N\")\nResidue{/UNK:1/UNK:1/ALA:1}\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"CurrentModule = ProtoSyn.Calculators","category":"page"},{"location":"protosyn-api/core/calculators/torchani/#TorchANI","page":"TorchANI","title":"TorchANI","text":"","category":"section"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"TorchANI is a Python implementation of ANI machine learning model for energy calculation. Trained on a large dataset of DFT calculation results, TorchANI is able to obtain DFT-level accuracy in energy calculation in a fraction of the time. For more details, read the original paper. Making use of the PyCall package and Julia's native methods for code integration, ProtoSyn incorporates TorchANI as an EnergyFunctionComponent.","category":"page"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"Calculators.TorchANI.get_ani_species\nCalculators.TorchANI.calc_torchani_ensemble\nCalculators.TorchANI.calc_torchani_model\nCalculators.TorchANI.get_default_torchani_ensemble\nCalculators.TorchANI.get_default_torchani_model","category":"page"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.get_ani_species","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.get_ani_species","text":"get_ani_species(container::ProtoSyn.AbstractContainer)\n\nReturn a Vector{Int} with the atomic number of each Atom instance in the given AbstractContainer container, according to a periodic table.\n\nSee also\n\ncalc_torchani_model calc_torchani_ensemble\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.get_ani_species(pose.graph[1][1])\n11-element Vector{Int64}:\n 7\n 1\n 6\n 1\n 6\n 1\n 1\n 8\n 1\n 6\n 8\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.calc_torchani_ensemble","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.calc_torchani_ensemble","text":"Calculators.calc_torchani_ensemble([::A], pose::Pose, update_forces::Bool = false) where {A <: ProtoSyn.AbstractAccelerationType}\n\nCalculate and return the Pose pose energy according to the whole TorchANI neural network ensemble. The optional A parameter defines the acceleration type used (note that only CUDA_2 is available, any other acceleration type will result in an error). If left undefined the default ProtoSyn.acceleration.active mode will be used. By setting the update_forces flag to true (false by default), this function will also calculate and return the forces acting on each atom based on the whole TorchANI neural network ensemble.\n\nSee also:\n\ncalc_torchani_model\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_ensemble(pose)\n(-0.12801790237426758, nothing)\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_ensemble(pose, true)\n(-0.12801788747310638, [ ... ])\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.calc_torchani_model","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.calc_torchani_model","text":"Calculators.calc_torchani_model([::A], pose::Pose; update_forces::Bool = false, model::Int = 3) where {A}\n\nCalculate and return the Pose pose energy according to a single TorchANI model neural network. The model can be defined using model_index (from model 1 to 8, default is 3).The optional A parameter defines the acceleration type used (note that only CUDA_2 is available, any other acceleration type will result in an error). If left undefined the default ProtoSyn.acceleration.active mode will be used. By setting the update_forces flag to true (false by default), this function will also calculate and return the forces acting on each atom based on a single TorchANI model neural network.\n\nukw: Note:\nEach model will return a slightly different value for the energy of the molecular system. Use calc_torchani_ensemble for a more accurate (and slow) energy prediction. However, as in most cases the energy value is used in comparison with multiple states/frames, calc_torchani_ensemble prediction may be suficient.\n\nSee also:\n\ncalc_torchani_ensemble calc_torchani_model_xmlrpc\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_model(pose)\n(-0.12573561072349548, nothing)\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_model(pose, true)\n(-0.12573561072349548, [ ... ])\n\nukw: Note:\nIn ProtoSyn >= 1.0, this function has a memory leak on the Python call. Multiple calls to calc_torchani_model require often GC.gc(false) calls to impede the 'CUDA out of memory' error. In order to prevent/automate this process, consider the following options:(1) - Use an EnergyFunction struct (with automatic calls to GC.gc(false), as in:EnergyFunction([ProtoSyn.Calculators.TorchANI.get_default_torchani_model()])(2) - Use calc_torchani_model_xmlrpc instead.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.get_default_torchani_ensemble","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.get_default_torchani_ensemble","text":"   get_default_torchani_ensemble(;α::T = 1.0) where {T <: AbstractFloat}\n\nReturn the default TorchANI ensemble EnergyFunctionComponent. α    sets the component weight (on an    EnergyFunction instance). This    component employs the calc_torchani_ensemble method, therefore    predicting a structure's TorchANI energy based on the whole TorchANI    ensemble (Note: This can be very slow).\n\nSee also\n\ncalc_torchani_ensemble get_default_torchani_model\n\nExamples\n\njldoctest    julia> ProtoSyn.Calculators.TorchANI.get_default_torchani_ensemble()    Name : TorchANI_ML_Ensemble    Weight (α) : 1.0 Update forces : true       Setings : -\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.get_default_torchani_model","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.get_default_torchani_model","text":"   get_default_torchani_model(;α::T = 1.0) where {T <: AbstractFloat}\n\nReturn the default TorchANI model EnergyFunctionComponent. α    sets the component weight (on an    EnergyFunction instance). This    component employs the calc_torchani_model method, therefore    predicting a structure's TorchANI energy based on a single model.\n\nSettings\n\nmodel::Int - Defines which model of the TorchANI ensemble to use.\n\nSee also\n\ncalc_torchani_model get_default_torchani_ensemble\n\nExamples\n\njldoctest    julia> ProtoSyn.Calculators.TorchANI.get_default_torchani_model()    Name : TorchANI_ML_Model    Weight (α) : 1.0 Update forces : true       Setings :         :model => 3\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"(Image: ProtoSyn TorchANI Components)","category":"page"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"Figure 1 | A diagram representation of the default TorchANI ML Ensemble and TorchANI ML Model EnergyFunctionComponent instances, obtained by usign the get_default_torchani_ensemble and get_default_torchani_model methods, respectively. While the TorchANI ML Ensemble is more accurate, it's also significantly slower. Depending on the application, employing a single model of the ensemble (of 8 models) might be sufficient.","category":"page"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"ProtoSyn also makes available the TorchANI ML Model EnergyFunctionComponent instance as a call to an XML-RPC server. This protocol spawns a Python server in parallel, running TorchANI, who receives XML requests from Julia and returns the calculated energy and forces. This functionality might be useful in certain systems and machines.","category":"page"},{"location":"protosyn-api/core/calculators/torchani/","page":"TorchANI","title":"TorchANI","text":"Calculators.TorchANI.start_torchANI_server\nCalculators.TorchANI.stop_torchANI_server\nCalculators.TorchANI.calc_torchani_model_xmlrpc\nCalculators.TorchANI.get_default_torchani_model_xmlrpc","category":"page"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.start_torchANI_server","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.start_torchANI_server","text":"start_torchANI_server()\n\nIf TorchANI.server is set to nothing, start a new TorchANI XML-RPC server. Return a XMLRPC.ClientProxy (used to send XML requests to the created server).\n\nSee also:\n\nstop_torchANI_server\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.start_torchANI_server()\nStarting TorchANI XML-RPC server ...\nTorchANI XML-RPC server is online!\nProtoSyn.XMLRPC.ClientProxy(\"http://localhost\", 50000, \"http://localhost:50000\")\n\njulia> ProtoSyn.Calculators.TorchANI.start_torchANI_server()\n┌ Warning: TorchANI XML-RPC server is already online!\n└ @ ProtoSyn.Calculators.TorchANI ~/project_c/ProtoSyn.jl/src/Core/Calculators/torchani_xmlrpc.jl:25\nProtoSyn.XMLRPC.ClientProxy(\"http://localhost\", 50000, \"http://localhost:50000\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.stop_torchANI_server","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.stop_torchANI_server","text":"stop_torchANI_server()\n\nIf TorchANI.server is not set to nothing, kill the current TorchANI XML-RPC server.\n\nSee also:\n\nstart_torchANI_server\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.stop_torchANI_server()\n\njulia> ProtoSyn.Calculators.TorchANI.stop_torchANI_server()\n┌ Warning: No online TorchANI XML-RPC server was found.\n└ @ ...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.calc_torchani_model_xmlrpc","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.calc_torchani_model_xmlrpc","text":"Calculators.calc_torchani_model_xmlrpc([::A], pose::Pose, update_forces::Bool = false; model::Int = 3) where {A}\n\nCalculate the pose energy according to a single TorchANI model neural network, using the XML-RPC protocol. If no TorchANI XML-RPC server is found, a new one is spawned (in parallel) from file torchani_server.py. The model can be defined using model (from model 1 to 8, default is 3). The optional A parameter defines the acceleration mode used (only CUDA_2 is available, any other acceleration type will result in an error). If left undefined the default ProtoSyn.acceleration.active type will be used. If update_forces is set to true (false, by default), return the calculated forces on each atom as well.\n\nSee also\n\ncalc_torchani_ensemble calc_torchani_model\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_model_xmlrpc(pose)\n(4.698066234588623, nothing)\n\njulia> ProtoSyn.Calculators.TorchANI.calc_torchani_model_xmlrpc(pose, true)\n(4.698066234588623, [ ... ])\n\nukw: Note:\nIf you use this function in a script, it is recommended to add ProtoSyn.Calculators.TorchANI.stop_torchANI_server() at the end of the script, as the automatic stopping of TorchANI XML-RPC server is not yet implemented, as of ProtoSyn >= 1.0.\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/torchani/#ProtoSyn.Calculators.TorchANI.get_default_torchani_model_xmlrpc","page":"TorchANI","title":"ProtoSyn.Calculators.TorchANI.get_default_torchani_model_xmlrpc","text":"get_default_torchani_model_xmlrpc(;α::T = 1.0) where {T <: AbstractFloat}\n\nReturn the default TorchANI model EnergyFunctionComponent. α sets the component weight (on an EnergyFunction instance). This component employs the calc_torchani_model_xmlrpc method, therefore predicting a structure's TorchANI energy based on a single model and starting a new XMLRPC server (in parallel) if necessary.\n\nSettings\n\nmodel::Int - Defines which model of the TorchANI ensemble to use.\n\nSee also\n\ncalc_torchani_model_xmlrpc\n\nExamples\n\njulia> ProtoSyn.Calculators.TorchANI.get_default_torchani_model_xmlrpc()\n         Name : TorchANI_ML_Model_XMLRPC\n   Weight (α) : 1.0\nUpdate forces : true\n      Setings :\n         :model => 3\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"CurrentModule = ProtoSyn.Materials","category":"page"},{"location":"protosyn-api/materials/methods/lattices/#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"In the next section, a brief description of the available methods to generate new atomic lattices is provided. These lattices can be useful, among other things, to benchmark and test new EnergyFunction and EnergyFunctionComponent instances, for example. ","category":"page"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"primitive","category":"page"},{"location":"protosyn-api/materials/methods/lattices/#ProtoSyn.Materials.primitive","page":"Lattices","title":"ProtoSyn.Materials.primitive","text":"primitive([unit_cell_dims::Vector{T} = [1.0, 1.0, 1.0]]) where {T <: AbstractFloat}\n\nCreates a primitive lattice Pose. If given, the unit_cell_dims vector determines the size of the unit cell. This must be a 1x3 Vector{T} of X, Y and Z lengths of the cubic unit cell (in Angstrom, [1.0, 1.0, 1.0] by default, using the ProtoSyn.Units.defaultFloat as type T).\n\nSee also:\n\nmerge! symexp!\n\nExamples\n\njulia> pose = ProtoSyn.Materials.primitive()\nPose{Topology}(Topology{/primitive:12909}, State{Float64}:\n Size: 1\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"(Image: ProtoSyn Primitive Lattice)","category":"page"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"Figure 1 | An example of the primitive lattice.","category":"page"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"body_centered","category":"page"},{"location":"protosyn-api/materials/methods/lattices/#ProtoSyn.Materials.body_centered","page":"Lattices","title":"ProtoSyn.Materials.body_centered","text":"body_centered([unit_cell_dims::Vector{T} = [1.0, 1.0, 1.0]]) where {T <: AbstractFloat}\n\nCreates a body-centered lattice Pose. If given, the unit_cell_dims determine the position of the body-centered Atom (half of it in all dimensions). This must be a 1x3 Vector{T} of X, Y and Z lengths of the cubic unit cell (in Angstrom, [1.0, 1.0, 1.0] by default, using the ProtoSyn.Units.defaultFloat as type T).\n\nSee also:\n\nmerge! symexp!\n\nExamples\n\njulia> ProtoSyn.Materials.body_centered()\nPose{Topology}(Topology{/primitive:51728}, State{Float64}:\n    Size: 2\n    i2c: false | c2i: false\n    Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"(Image: ProtoSyn Body Centered Lattice)","category":"page"},{"location":"protosyn-api/materials/methods/lattices/","page":"Lattices","title":"Lattices","text":"Figure 2 | An example of the body_centered lattice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: logo)","category":"page"},{"location":"#Welcome-to-the-ProtoSyn.jl-documentation!","page":"Home","title":"Welcome to the ProtoSyn.jl documentation!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ProtoSyn.jl is a platform for molecular manipulation and simulation, with an emphasis on peptide design.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main goal of ProtoSyn is to be a basis on top of which new tools and protocols can be experimented and prototyped. Taking advantage of Julia’s environment, ProtoSyn has been built with emergent technologies in mind, such as distributed computing, GPU and SIMD acceleration and machine learning models usage.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Edit a peptide structure by removing, adding and mutating any number of residues\nCreate peptides from scratch by providing the desired sequence\nCopy parts of other molecules and graft them together to create something new\nRun Monte Carlo simulations to optimize a structure or a sequence\nCalculate energies and forces using TorchANI code, integrated in Julia.\nPerform Steepest Descent optimizations\nExplore rotamer libraries to optimize sidechain packaging\nSelect residues based on name, index, distance and other parameters, with a rich combinatory selection syntax\nPerform rigid body docking of ligands\nInclude ramified carbohydrates and glycoproteins in your simulations, with support for sugar residues ","category":"page"},{"location":"","page":"Home","title":"Home","text":"ukw: Note:\nVersion 1.0 is scheduled to be released at the end of August 2021.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Installation\nFirst steps\nExamples","category":"page"},{"location":"#Publications","page":"Home","title":"Publications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A scientific paper about ProtoSyn.jl package is being written and should be available soon.","category":"page"},{"location":"#Contacts","page":"Home","title":"Contacts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: jose.manuel.pereira@ua.pt)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: ProtoSyn YouTube Channel)","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Acknowledgments)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This work was developed within the scope of the project CICECO-Aveiro Institute of Materials, UIDB/50011/2020 & UIDP/50011/2020, financed by national funds through the Portuguese Foundation for Science and Technology/MCTES. José Pereira further acknowledges FCT financial support on the scope of the PhD scholarship SFRH/BD/138820/2018.","category":"page"},{"location":"protosyn-api/common/introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = ProtoSyn.Common","category":"page"},{"location":"protosyn-api/common/introduction/#Common","page":"Introduction","title":"Common","text":"","category":"section"},{"location":"protosyn-api/common/introduction/","page":"Introduction","title":"Introduction","text":"The Common module is a pecial type of module, in ProtoSyn. Its function is to group commonly performed tasks, such as defining a default EnergyFunction instances or defining commonly used Callback instances.","category":"page"},{"location":"protosyn-api/common/introduction/#Default-Energy-Function","page":"Introduction","title":"Default Energy Function","text":"","category":"section"},{"location":"protosyn-api/common/introduction/","page":"Introduction","title":"Introduction","text":"default_energy_function\ndefault_xmlrpc_energy_function","category":"page"},{"location":"protosyn-api/common/introduction/#ProtoSyn.Common.default_energy_function","page":"Introduction","title":"ProtoSyn.Common.default_energy_function","text":"default_energy_function(::Type{T}) where {T <: AbstractFloat}\ndefault_energy_function()\n\nReturns a default energy function for ProtoSyn.\n\nukw: Note:\nIf no Type{T} is provided, will use ProtoSyn.Units.defaultFloat;\n\nExamples\n\njulia> ProtoSyn.Common.default_energy_function()\n🗲  Energy Function (4 components):\n+----------------------------------------------------------------------+\n| Index | Component name                                | Weight (α)   |\n+----------------------------------------------------------------------+\n| 1     | TorchANI_ML_Model                             |      1.000   |\n| 2     | Caterpillar_Solvation                         |      0.010   |\n| 3     | Bond_Distance_Restraint                       |      1.000   |\n| 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n+----------------------------------------------------------------------+\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/common/introduction/#ProtoSyn.Common.default_xmlrpc_energy_function","page":"Introduction","title":"ProtoSyn.Common.default_xmlrpc_energy_function","text":"default_xmlrpc_energy_function(::Type{T}) where {T <: AbstractFloat}\ndefault_xmlrpc_energy_function()\n\nReturns a default energy function for ProtoSyn, where a XML-RPC version of each component is employed (when available).\n\nukw: Note:\nIf no Type{T} is provided, will use ProtoSyn.Units.defaultFloat;\n\nukw: Note:\nSince this energy function employs the XML-RPC protocol whenever possible, it is slower, but safe in term of CUDA running out of memory.\n\nSee also\n\ndefault_energy_function\n\nExamples\n\njulia> ProtoSyn.Common.default_xmlrpc_energy_function()\n🗲  Energy Function (4 components):\n+----------------------------------------------------------------------+\n| Index | Component name                                | Weight (α)   |\n+----------------------------------------------------------------------+\n| 1     | TorchANI_ML_Model_XMLRPC                      |      1.000   |\n| 2     | Caterpillar_Solvation                         |      0.010   |\n| 3     | Bond_Distance_Restraint                       |      1.000   |\n| 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n+----------------------------------------------------------------------+\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/common/introduction/#Default-Callbacks","page":"Introduction","title":"Default Callbacks","text":"","category":"section"},{"location":"protosyn-api/common/introduction/","page":"Introduction","title":"Introduction","text":"default_energy_step_callback\ndefault_energy_step_frame_callback","category":"page"},{"location":"protosyn-api/common/introduction/#ProtoSyn.Common.default_energy_step_callback","page":"Introduction","title":"ProtoSyn.Common.default_energy_step_callback","text":"default_energy_step_callback(n::Int)::Callback\n\nReturns a simple Callback that prints the current step and total energy value of the Pose every n steps.\n\nExamples\n\njulia> ProtoSyn.Common.default_energy_step_callback(100)\n✉  Callback:\n+----------------------------------------------------------------------+\n| Index | Field                     | Value                            |\n+----------------------------------------------------------------------+\n| 1     | Event                     | energy_step                      |\n| 2     | Frequency                 | 100                              |\n+----------------------------------------------------------------------+\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/common/introduction/#ProtoSyn.Common.default_energy_step_frame_callback","page":"Introduction","title":"ProtoSyn.Common.default_energy_step_frame_callback","text":"default_energy_step_frame_callback(n::Int, filename::String)::Callback\n\nReturns a simple Callback that prints the current step and total energy value of the Pose every n steps, while printing the current structure to the given filename (in PDB format).\n\nExamples\n\njulia> ProtoSyn.Common.default_energy_step_frame_callback(100, \"test.pdb\")\n✉  Callback:\n+----------------------------------------------------------------------+\n| Index | Field                     | Value                            |\n+----------------------------------------------------------------------+\n| 1     | Event                     | energy_step_frame                |\n| 2     | Frequency                 | 100                              |\n+----------------------------------------------------------------------+\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"CurrentModule = ProtoSyn.Mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/#Rigid-Body-Mutators","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"ProtoSyn Core module makes available two Rigid Body Mutators: the RotationRigidBodyMutator, which changes a Pose State by introducing a rigid body rotation; and the TranslationRigidBodyMutator, which changes a Pose State by introducing a rigid body translation.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"RotationRigidBodyMutator","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/#ProtoSyn.Mutators.RotationRigidBodyMutator","page":"Rigid Body Mutators","title":"ProtoSyn.Mutators.RotationRigidBodyMutator","text":"RotationRigidBodyMutator(axis_sampler::Function, angle_sampler::Function, pivot_sampler::Function, step_size::AbstractFloat, selection::Opt{AbstractSelection})\n\nReturn a new RotationRigidBodyMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(rigid_body_mutator::RotationRigidBodyMutator)(pose::Pose)\n\nThe RotationRigidBodyMutator AbstractMutator applies a rotation to all Atom instances in a given Pose based on a given angle and axis, and centered around a pivot position (See rotation_matrix_from_axis_angle). The applied rotation's angle is sampled by calling angle_sampler (receives no input arguments and should return a Float angle value in radians) and multiplied by the step_size value. The rotation's axis is sampled from the axis_sampler (receives no input arguments and should return a Vector{Float} with size 3, the X, Y and Z dimensions). Finally, this rotation is centered in a pivot position, sampled from pivot_sampler (receives the Pose and a list of selected Atom indexes as the input arguments and should return a Vector{Float} with size 3, the X, Y and Z dimensions). If an AbstractSelection selection is provided, only the selected Atom instances are rotated and used as input for pivot_sampler. Note that the RotationRigidBodyMutator syncs any pending internal to cartesian coordinate conversion (using the i2c! method). Requests cartesian to internal coordinates conversion (using request_c2i! method). Does not sync! the given Pose afterwards.\n\nThe RotationRigidBodyMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(rigid_body_mutator::RotationRigidBodyMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\naxis_sampler::Function - Should return a Vector{Float} axis (X, Y and Z dimensions). Is called with no input arguments;\nangle_sampler::Function - Should return a Float angle value (in radians). Is called with no input arguments;\npivot_sampler::Function - Should return a Vector{Float} position (X, Y and Z dimensions). Is called with 2 input arguments: a Pose instance and a Vector{Int} with the indexes of the selected Atom instances;\nstep_size::AbstractFloat - Multiplies the sampled angle by this value;\nselection::Opt{AbstractSelection} - If given, this Mutator will only be applied to the selected Atom instances.\n\nSee also\n\nTranslationRigidBodyMutator\n\nExamples\n\njulia> m = ProtoSyn.Mutators.RotationRigidBodyMutator(ProtoSyn.rand_vector_in_sphere, randn, ProtoSyn.center_of_mass, 1.0, rn\"CBZ\")\n⚯  Rotation Rigid Body Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | axis_sampler                | Function rand_vector_in_sphere |\n| 2     | angle_sampler               | Function randn                 |\n| 3     | pivot_sampler               | Function center_of_mass        |\n| 4     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ● Selection: Set\n └── FieldSelection › Residue.name = CBZ\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"(Image: ProtoSyn Rotation Rigid Body Mutator)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"Figure 1 | A schematic representation of a RotationRigidBodyMutator instance. In this example, showcasing a 2 molecule simulation, a RotationRigidBodyMutator is applied to a carbamazepine (CBZ) ligand, by selecting it based on the Residue.name (rn\"CBZ\"). The axis for the rotation is sampled from rand_vector_in_sphere, the angle is sampled from randn and the pivot position if the Pose center_of_mass.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"TranslationRigidBodyMutator","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/#ProtoSyn.Mutators.TranslationRigidBodyMutator","page":"Rigid Body Mutators","title":"ProtoSyn.Mutators.TranslationRigidBodyMutator","text":"TranslationRigidBodyMutator(translation_vector_sampler::Function, step_size::AbstractFloat, selection::Opt{AbstractSelection})\n\nReturn a new TranslationRigidBodyMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(rigid_body_mutator::TranslationRigidBodyMutator)(pose::Pose)\n\nThe TranslationRigidBodyMutator AbstractMutator applies a translation to all Atom instances in a given Pose based on a given axis. This axis is sampled from translation_vector_sampler (who receives no input arguments and should return a Vector{Float} with size 3, the X, Y and Z dimensions). Although not necessary, this Vector{Float} should have norm 1.0. The translation vector is then multiplied by step_size. If an AbstractSelection selection is provided, only the selected Atom instances are translated. Note that the TranslationRigidBodyMutator syncs any pending internal to cartesian coordinate conversion (using the i2c! method). Requests cartesian to internal coordinates conversion (using request_c2i! method). Does not sync! the given Pose afterwards.\n\nThe TranslationRigidBodyMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(rigid_body_mutator::TranslationRigidBodyMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\ntranslation_vector_sampler::Function - Should return a Vector{Float} axis (X, Y and Z dimensions). Is called with no input arguments;\nstep_size::AbstractFloat - Multiplies the sampled axis by this value;\nselection::Opt{AbstractSelection} - If given, this Mutator will only translate the selected Atom instances;\n\nSee also\n\nTranslationRigidBodyMutator\n\nExamples\n\njulia> m = ProtoSyn.Mutators.TranslationRigidBodyMutator(ProtoSyn.rand_vector_in_sphere, 1.0, rn\"CBZ\")\n⚯  Translation Rigid Body Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | translation_vector_sampler  | Function rand_vector_in_sphere |\n| 2     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ● Selection: Set\n └── FieldSelection › Residue.name = CBZ\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"(Image: ProtoSyn Translation Rigid Body Mutator)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-rigid-body/","page":"Rigid Body Mutators","title":"Rigid Body Mutators","text":"Figure 2 | A schematic representation of a TranslationRigidBodyMutator instance. In this example, the Mutator is applied to a carbamazepine (CBZ) ligand, by selecting it based on the Residue.name (rn\"CBZ\"). The translation vector is sampled from rand_vector_in_sphere. All the selected atoms will suffer this translation.","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/#peptides-builder","page":"Builder","title":"Builder","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"The Builder is a submodule of ProtoSyn.Peptides module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"As an expansion of the Core module Builder, this submodule introduces the peptidic LGrammar type, as well as the necessary methods to append and insert Fragment instances from a derivation, organized in the following topics:","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"Loading the default Peptides Stochastic L-Grammar\nBuilding a molecular structure\nManipulating a molecular structure by adding new residues from templates","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/#peptides-builder-1","page":"Builder","title":"Loading the default Peptides Stochastic L-Grammar","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"grammar(::Type{T}; ::Bool) where {T <: AbstractFloat}","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.grammar-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Builder","title":"ProtoSyn.Peptides.grammar","text":"grammar([::Type{T}];[verbose::Bool = true]) where {T <: AbstractFloat}\n\nBuild a LGrammar for peptides, taking as variables the Fragment instances in the default resource directory. If the optional type T is not provided, the ProtoSyn.defaultFloat value will be used. The returned LGrammar is required for building peptides from Fragment instances, for example. If verbose is set to true (is, by default), print the loading status.\n\nExamples\n\njulia> res_lib = ProtoSyn.Peptides.grammar()\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/peptides/submodules/builder/#peptides-builder-2","page":"Builder","title":"Building a molecular structure","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"build(::LGrammar{T}, ::Any, ::SecondaryStructureTemplate) where {T <: AbstractFloat}","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.build-Union{Tuple{T}, Tuple{LGrammar{T, K, V} where {K, V}, Any, SecondaryStructureTemplate}} where T<:AbstractFloat","page":"Builder","title":"ProtoSyn.Peptides.build","text":"build(grammar::LGrammar{T}, derivation, ss::NTuple{3,Number} = SecondaryStructure[:linear]) where {T <: AbstractFloat}\n\nBuild a Pose using the given derivation sequence on the provided grammar instructions. If an ss is provided, automatically apply it to the built pose (linear secondary structure, by default).\n\nukw: Note:\nThis function is an extension of ProtoSyn.build.\n\nSee also\n\nsetss!\n\nExamples\n\njulia> pose = ProtoSyn.Peptides.build(res_lib, seq\"QQQ\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 51\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/peptides/submodules/builder/#peptides-builder-3","page":"Builder","title":"Manipulating a molecular structure by adding new residues from templates","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/builder/","page":"Builder","title":"Builder","text":"append_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Any; ::Opt{SecondaryStructureTemplate}, ::Any)\ninsert_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Any; ::Opt{SecondaryStructureTemplate}, ::Any)","category":"page"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.append_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Any}","page":"Builder","title":"ProtoSyn.Peptides.append_fragment!","text":"append_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation; [ss::Opt{SecondaryStructureTemplate} = nothing], [op = \"α\"])\n\nAdd the a Fragment built from the given derivation to the provided Pose pose, appending it after the given Residue residue. This residue and the new Fragment frag will be connected using operation op (\"α\" by default) of the given LGrammar grammar. If given, a SecondaryStructureTemplate ss can be applied to the new appendage (using the setss! method). In either case, the C=O bond position is re-calculated and set (in the anchor for the first residue of the appendage). Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nukw: Note:\nThis function is an extension of ProtoSyn.append_fragment!.\n\nSee also\n\ninsert_fragment!\n\nExamples\n\njulia> ProtoSyn.Peptides.append_fragment!(pose, pose.graph[1][end], res_lib, seq\"AAA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/peptides/submodules/builder/#ProtoSyn.Peptides.insert_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Any}","page":"Builder","title":"ProtoSyn.Peptides.insert_fragment!","text":"insert_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation; ss::Opt{SecondaryStructureTemplate} = nothing, op = \"α\")\n\nInsert the Fragment built from the given derivation in the provided pose, on the position of the provided Residue instance residue (the residue gets shifted downstream). This first downstream Residue and the new Fragment will be connected using operation op (\"α\" by default) from [LGrammar] grammar. Also connects to the upstream Residue instance, using the same operation. If given, a SecondaryStructureTemplate ss can be applied to the new appendage (using the setss! method). If the appendage is not being inserted at the root, the C=O bond position is re-calculated and set (in the anchor for the first residue of the appendage). If the appendage is being inserted at the root, perform a soft uncap of the terminal hydrogen atoms (removes \"H2\" and \"H3\", leaves \"H1\", renames it to \"H\") and recalculate the N-H bond position (at the first downstream Residue). Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nukw: Note:\nThis function is an extension of ProtoSyn.insert_fragment!.\n\nSee also\n\nappend_fragment!\n\nExamples\n\njulia> ProtoSyn.Peptides.insert_fragment!(pose, pose.graph[1][1], res_lib, seq\"AAA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"CurrentModule = ProtoSyn.Sugars","category":"page"},{"location":"protosyn-api/sugars/submodules/builder/#sugars-builder","page":"Builder","title":"Builder","text":"","category":"section"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"The Builder is a submodule of ProtoSyn.Sugars module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"As an expansion of the Core module Builder, this submodule introduces the carbohydrates LGrammar type, as well as the necessary methods to append and insert Fragment instances from a derivation.","category":"page"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"grammar","category":"page"},{"location":"protosyn-api/sugars/submodules/builder/#ProtoSyn.Sugars.grammar","page":"Builder","title":"ProtoSyn.Sugars.grammar","text":"grammar([::Type{T}, polyname::String]) where {T <: AbstractFloat}\n\nBuild a LGrammar for polysaccharide polyname from the grammars.yml file available in the Sugars resource directory (\"amylose\", by default). The returned LGrammar can then be used by the ProtoSyn.build function to build the polymer.\n\nExamples\n\njulia> g = Sugars.grammar();\n\njulia> pose = ProtoSyn.build(g, seq\"AAAβB[ɣCɣCɣC]AAA\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"(Image: ProtoSyn Ramified Sugar)","category":"page"},{"location":"protosyn-api/sugars/submodules/builder/","page":"Builder","title":"Builder","text":"Figure 1 | Small example of a ramified sugar (such as amylopectin), built in ProtoSyn.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"CurrentModule = ProtoSyn.Drivers","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Drivers-section","page":"Drivers Section","title":"Drivers section","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"A Driver is a piece of code that drives the simulation forward. Usually, it includes a set of AbstractMutator instances and one or more EnergyFunction. As such, a Driver (in contrast with a simple AbstractMutator) is able to make decisions or change the course of the simulation based on the evaluation of the current State. For example, a MonteCarlo simulation may accept or reject a given conformational change (produced by one of more AbstractMutator instances) based on the evaluation of the system State by a given EnergyFunction. The current status of a simulation is stored in a DriverState instance (each Driver type has a corresponding DriverState type). For example, this can hold the current step or temperature of the simulation. Each module in ProtoSyn may include a Drivers section, adding new Driver types and methods. In the next sections, a deeper look into the inner workings of the available Driver instances is provided, organized in the following sections:","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Callbacks\nCreating custom callbacks\nCreating custom drivers\nAvailable drivers\nCreating custom thermostats\nAvailable thermostats","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"(Image: ProtoSyn driver)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Figure 1 | A diagram of a MonteCarlo Driver. This Driver type requests an eval! component (in this case, an EnergyFunction, with a TorchANI Ensmeble as the single component - see get_default_torchani_ensemble) and a sample! component (in this example, a single DihedralMutator). As the naming implies, an eval! component evaluates the system's energy at any given moment in the simulation, while the sample! component drives the system from a State to the next. Optionally, a Callback callback can be provided, whose purpose is to periodically return information to the user about the current state of the simulation (i.e.: current step, temperature, energy, etc). In this example, as defined in the MonteCarlo Driver settings, the simulation will run for 5000 steps, with a constant temperature (see Available thermostats and Creating custom thermostats on how to control the temperature of a simulation).","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Callbacks","page":"Drivers Section","title":"Callbacks","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Callback instances are responsible for returning information from a simulation during its runtime. This object type is usually used in Driver instances in order to print information to the user relative to the inner workings of a simulation: the current step, temperature, energy, etc.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Callback","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#ProtoSyn.Drivers.Callback","page":"Drivers Section","title":"ProtoSyn.Drivers.Callback","text":"Callback(event::Function, frequency::Int)\n\nA Callback instance is a functor, called with the following signature:\n\n(callback::Callback)(pose::Pose, driver_state::ProtoSyn.Drivers.DriverState)\n\nA Callback expects the given DriverState driver_state to have a :step field. The input Pose pose and DriverState driver_state are passed as arguments to the event method every callback.frequency steps.\n\nFields\n\nevent::Function - Receives a Pose pose and DriverState driver_state as input arguments, should print some useful information to the user;\nfrequency::Int - the :event method is called every :frequency steps (when comapred to the given DriverState driver_state.step).\n\nExamples\n\njulia> cb = ProtoSyn.Drivers.Callback((pose::Pose, driver_state::ProtoSyn.Drivers.DriverState) -> println(\"Status OK\"), 1)\n✉  Callback:\n+----------------------------------------------------------------------+\n| Index | Field                     | Value                            |\n+----------------------------------------------------------------------+\n| 1     | Event                     | #1                               |\n| 2     | Frequency                 | 1                                |\n+----------------------------------------------------------------------+\n\njulia> cb(pose, driver_state)\nStatus OK\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-section/#Creating-custom-callbacks","page":"Drivers Section","title":"Creating custom callbacks","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"As stated above, Callback instances are functors, usually called from within the body of a Driver instance. As such, a specific signature is expected for the :event function:","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"callback.event(pose::Pose, driver_state::DriverState)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"As an example:","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"using ProtoSyn","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"function event_example(pose::Pose, driver_state::ProtoSyn.Drivers.DriverState)\n    println(\"Step: $(driver_state.step) | Energy: $(pose.state.e[:Total])\")\nend\n\ncallback = ProtoSyn.Drivers.Callback(event_example, 1)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"ukw: Note:\nAlthough possible, changing the input Pose pose or DriverState driver_state during the Callback call can have unexpected results, and should be used carefully.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Creating-custom-drivers","page":"Drivers Section","title":"Creating custom drivers","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Since certain Driver instances may call other Driver instances, Protosyn expects a certain signature for custom drivers and the accompanying DriverState. A Driver is a functor, meaning it is a callable object, with the following signature:","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Base.@kwdef mutable struct ExampleDriverState{T <: AbstractFloat} <: DriverState\n    step::Int = 0\n    # content\nend\n\nmutable struct ExampleDriver <: Driver\n    callback::Opt{Callback}\n    # content\nend\n\nfunction (driver::MonteCarlo)(pose::Pose)\n    T = eltype(pose.state)\n    driver_state = ExampleDriverState{T}()\n    driver.callback !== nothing && driver.callback(pose, driver_state)\n\n    # content\n    return pose\nend","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"From the previous snippet of code, three important bits can be highlighted: first, the usage of Base.kwdef to define default values for the DriverState object. Altough not necessary, this eases the creation of starting DriverState instances. Second, the initial call to the :callback field in the Driver, giving as input arguments a Pose pose and DriverState driver_state, as expected. Note that this is an optional component of a standard Driver in ProtoSyn. Finally, although not necessary, some other Driver instances might expect a custom Driver to return the modified Pose pose.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Available-drivers","page":"Drivers Section","title":"Available drivers","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"In this seb-section, the default Driver instances made available by the Core module of ProtoSyn are further explored. Note that additional Driver types might be made available in other modules (such as Peptides).","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"MonteCarlo\nSteepestDescent\nILS\nCompoundDriver","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Creating-custom-thermostats","page":"Drivers Section","title":"Creating custom thermostats","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"Some Driver instances have a :temperature::Function field, where the temperature function takes the current :step of the simulation. This function is often referred to as a thermostat, since it regulates the temperature of the simulation, thus controlling the likelihood of acceptance of higher energy states, etc. As such, in order to create a custom thermostat, the following signature should be followed (taking a step`Int as the single input argument and returning a temperature value, usually as a Float):","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"return function custom_thermostat(step::Int)\n\n    # content\n\n    return temperature_value\nend","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#Available-thermostats","page":"Drivers Section","title":"Available thermostats","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"get_constant_temperature\nget_linear_quench\nget_quadratic_quench","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/","page":"Drivers Section","title":"Drivers Section","text":"get_constant_temperature\nget_linear_quench\nget_quadratic_quench","category":"page"},{"location":"protosyn-api/core/drivers/drivers-section/#ProtoSyn.Drivers.get_constant_temperature","page":"Drivers Section","title":"ProtoSyn.Drivers.get_constant_temperature","text":"get_constant_temperature(init_temp::T) where {T <: AbstractFloat}\n\nReturn a constant temperature thermostat function, set at temperature init_temp.\n\nSee also\n\nget_linear_quench get_quadratic_quench\n\nExamples\n\njulia> thermostat = ProtoSyn.Drivers.get_constant_temperature(1.0)\n(::ProtoSyn.Drivers.var\"#constant_temperature#9\"{Float64}) (generic function with 1 method)\n\njulia> thermostat(100)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/drivers/drivers-section/#ProtoSyn.Drivers.get_linear_quench","page":"Drivers Section","title":"ProtoSyn.Drivers.get_linear_quench","text":"get_linear_quench(init_temp::T, n_steps::Int) where {T <: AbstractFloat}\n\nReturn a linear temperature quench thermostat function, beggining at temperature init_temp and reducing linearly to 0.0 during n_steps.\n\nSee also\n\nget_constant_temperature get_quadratic_quench\n\nExamples\n\njulia> thermostat = ProtoSyn.Drivers.get_linear_quench(1.0, 100)\n(::ProtoSyn.Drivers.var\"#linear_quench#10\"{Float64, Int64}) (generic function with 1 method)\n\njulia> thermostat(0)\n1.0\n\njulia> thermostat(50)\n0.5\n\njulia> thermostat(100)\n0.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/drivers/drivers-section/#ProtoSyn.Drivers.get_quadratic_quench","page":"Drivers Section","title":"ProtoSyn.Drivers.get_quadratic_quench","text":"get_quadratic_quench(init_temp::T, n_steps::Int, min_temp::T) where {T <: AbstractFloat}\n\nReturn a quadratic temperature quench thermostat function, beginning at temperature init_temp and reducing to min_temp during n_steps following a quadratic curve.\n\nSee also\n\nget_constant_temperature get_linear_quench\n\nExamples\n\njulia> thermostat = ProtoSyn.Drivers.get_quadratic_quench(1.0, 100, 0.0)\n(::ProtoSyn.Drivers.var\"#quadratic_quench#11\"{Float64, Int64, Float64}) (generic function with 1 method)\n\njulia> thermostat(0)\n1.0\n\njulia> thermostat(50)\n0.25\n\njulia> thermostat(100)\n0.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"CurrentModule = ProtoSyn.Mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/#Mutators-section","page":"Mutators Section","title":"Mutators section","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Each module in ProtoSyn may include a Mutators section, containing types and methods allowing ProtoSyn to change a Pose instance's from one State to another. In other words, a Mutator (of type AbstractMutator) is responsible for implementing a given conformational change in a Pose (for example, implementing Dihedral rotations, among others). In the context of a simulation, this is usually refered as \"sampling\". In the next section, a further exploration of the available AbstractMutator instances is provided, organized in the following sections:","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Creating custom mutators\nAvailable mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"(Image: ProtoSyn Mutators)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Figure 1 | A diagram of an example CompoundMutator, bringing together multiple AbstractMutator instances. In this example, both the DihedralMutator and the CrankshaftMutator are represented. Each AbstractMutator can be parametrized by a collection of settings, explained in each Mutator's page in this manual. In the case of the exemplified AbstractMutator instances, these can receive an optional selection (in the example the FieldSelection and UnarySelection are shown).","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/#Creating-custom-mutators","page":"Mutators Section","title":"Creating custom mutators","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Mutators are most useful when employed in a Driver instance (see Drivers section), who expects the following signature. Note that the Mutator instances are struct instances (of type <: AbstractMutator), but are also functors, meaning that are callable by the encompassing Driver. For this call, only a Pose pose instance is given as input, and all conformational changes should be in-place (no output is expected and any internal to cartesian coordinate conversion, or vice-versa, should be requested at the end of the function call). Note that, as a general rule, AbstractMutator instances should sync! any required internal to cartesian coordinate conversion (or vice-versa) at the start of the function call (using i2c! or c2i! methods). As an example, DihedralMutator syncs any pending cartesian to internal coordinate conversion before applying itself. In the same fashion, at the end of the function call, AbstractMutators should request any internal to cartesian coordinate conversion (or vice-versa), depending on the change performed, therefore requesting a pending sync!. However, AbstractMutators should not sync!, in most cases. As an example, ten sequential DihedralMutator calls do not require a sync! between each of them.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"struct NewMutator <: AbstractMutator\n    # content\nend\n\nfunction (mutator::NewMutator)(pose::Pose)\n    # content\nend","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"In order to be able to incorporate any new custom mutator in a CompoundMutator, an extra signature needs to be present, receiving a subset list of Atom instances. In this case, the mutator should only be applied to the Atom instances in this subset.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"function (mutator::NewMutator)(pose::Pose, atoms::Vector{Atom})\n    # content\nend","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/#Available-mutators","page":"Mutators Section","title":"Available mutators","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Besides all the machinery to create custom mutators, ProtoSyn's Core module makes available some simple AbstractMutator instances. Since this is not a specialized module, available mutators should be indiferent to the type of molecular structure being sampled. As of ProtoSyn 1.0, the following AbstractMutator instances are made available from the Core module, and can be further explored in the respectivelly dedicated pages of this manual:","category":"page"},{"location":"protosyn-api/core/mutators/mutators-section/","page":"Mutators Section","title":"Mutators Section","text":"Dihedral Mutator\nCrankshaft Mutator\nRigid Body Mutators\nCompound Mutator","category":"page"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/","page":"Steepest Descent","title":"Steepest Descent","text":"CurrentModule = ProtoSyn.Drivers","category":"page"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/#Steepest-Descent-Driver","page":"Steepest Descent","title":"Steepest Descent Driver","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/","page":"Steepest Descent","title":"Steepest Descent","text":"The Steepest Descent Driver introduces a simple gradient descent, calculating the forces acting on each atom and applying a relaxing translational movement, until convergence or end of simulation.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/","page":"Steepest Descent","title":"Steepest Descent","text":"SteepestDescent\nSteepestDescentState","category":"page"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/#ProtoSyn.Drivers.SteepestDescent","page":"Steepest Descent","title":"ProtoSyn.Drivers.SteepestDescent","text":"SteepestDescent(eval!::Union{Function, EnergyFunction}, callback::Opt{Callback}, max_steps::Int, force_tolerance::Float64, max_displacement::Float64)\n\nA SteepestDescent Driver instance. As such, this object is callable as a functor with the following signature:\n\n(driver::SteepestDescent)(pose::Pose)\n\nThis simulation employs the calculation of forces by an evaluating function or EnergyFunction instance (eval!) to relax and optimize a given Pose pose. This process will run for a maximum of max_steps iterations, or until the simulation has stalled or converged. Convergence is achieved when the maximum force felt on the system is bellow a given threshold force_tolerance, while a simulation is stalled when the current scaling factor is bellow the machine precision. In each step, the displacement is calculated as a factor of the force applied to an atom multiplied by a step size (or learning rate), up to a maximum max_displacement. As an heuristic for the definition of this step size, this value increases while when the system's energy is lowering, and rapidly decreases if an higher energy State is generated. This allows the simulation to traverse for some degree of energy barriers. Each step, a call to an optional Callback callback is performed. A companion SteepestDescentState DriverState instance is also updated each step and provided to the Callback callback.\n\nFields\n\neval!::Union{Function, EnergyFunction} - The evaluator EnergyFunction or custom function, receives two input arguments: a Pose pose and a calc_forces::Bool boolean;\ncallback::Opt{Callback} - An optional Callback instance, receives two input arguments: the current Pose pose and the current DriverState driver_state;\nmax_steps::Int - The total number of simulation steps to be performed;\nforce_tolerance::Float64 - The minimum force tolerated by the simulation, any State with a max force below this threshold will converge the simulation;\nmax_displacement::Float64 - The maximum displacement each step (a.u.).\n\nSee also\n\nSteepestDescentState\n\nExamples\n\njulia> sd = ProtoSyn.Drivers.SteepestDescent(energy_function, cb, 1000, 0.001, 0.1)\n⚒  Steepest Descent Driver:\n ├──  ●  Evaluator:\n |    └── 🗲  Energy Function (4 components):\n |        +----------------------------------------------------------------------+\n |        | Index | Component name                                | Weight (α)   |\n |        +----------------------------------------------------------------------+\n |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |        +----------------------------------------------------------------------+\n |   \n ├──  ● Callback:\n |    └── ✉  Callback:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                     | Value                            |\n |        +----------------------------------------------------------------------+\n |        | 1     | Event                     | energy_step_frame                |\n |        | 2     | Frequency                 | 10                               |\n |        +----------------------------------------------------------------------+\n |   \n └──  ● Settings:\n            Max steps: 1000\n      Force tolerance: 0.001\n     Max displacement: 0.1\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/#ProtoSyn.Drivers.SteepestDescentState","page":"Steepest Descent","title":"ProtoSyn.Drivers.SteepestDescentState","text":"SteepestDescentState{T <: AbstractFloat}(step::Int = 0, converged::Bool = false, completed::Bool = false, stalled::Bool = false, stepsize::T = T(1), max_force::Tuple{T,Int} = (T(-1),0))\nSteepestDescentState{T <: AbstractFloat}()\n\nA SteepestDescentState instance is a DriverState that keeps track of a SteepestDescent simulation status. Besides the default :step, :converged, :completed and :stalled fields, a SteepestDescentState instance adds the following tracking fields specific for SteepestDescent simulations:\n\nstepsize::T - The current learning rate of the simulation;\nmax_force::Tuple{T,Int} - The maximum force felt by the system and the atom index where the force is felt.\n\nSee also\n\nSteepestDescent\n\nExamples\n\njulia> ProtoSyn.Drivers.SteepestDescentState{Float64}()\nProtoSyn.Drivers.SteepestDescentState{Float64}(0, false, false, false, 1.0, (-1.0, 0))\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/","page":"Steepest Descent","title":"Steepest Descent","text":"(Image: ProtoSyn steepest-descent-driver)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-steepest-descent/","page":"Steepest Descent","title":"Steepest Descent","text":"Figure 1 | A schematic overview of the different stages in a SteepestDescent Driver: (1) - Calculate the forces being felt on the system; (2) - Apply the forces, multiplied by the current stepsize; (3) - Adjust the stepsize, based on the new system's energy.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"CurrentModule = ProtoSyn.Mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/#Crankshaft-Mutator","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"A CrankshaftMutator instance changes a Pose State by introducing one or more crankshaft movements: a concerted rotation, by a given axis, around a virtual axis between two Atom instances.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"CrankshaftMutator","category":"page"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/#ProtoSyn.Mutators.CrankshaftMutator","page":"Crankshaft Mutator","title":"ProtoSyn.Mutators.CrankshaftMutator","text":"CrankshaftMutator(angle_sampler::Function, p_mut::AbstractFloat, step_size::AbstractFloat, selection::Opt{AbstractSelection}, inc_last_res::Opt{AbstractSelection})\n\nReturn a CrankshaftMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(crankshaft_mutator::CrankshaftMutator)(pose::Pose)\n\nThe CrankshaftMutator AbstractMutator loops through all pairs of two atoms possible, in the given Pose. For each pair, if a random number (rand()) is bellow a given probability of mutation p_mut, both atoms are selected for a crankshaft movement (therefore a higher p_mut value applies a larger number of crankshaft movements per call). A crankshaft movement is a concerted rotation around a virtual axis formed between the two selected atoms, by a certain angle given by the angle_sampler function and multiplied by the step_size value. The rotation is applied to the region between the two atoms, by travelling the Pose Graph (See travel_graph), by calculating and applying a rotation matrix (See rotation_matrix_from_axis_angle). Note that a new angle for the crankshaft movement is sampled for each selected pair of Atom instances. If an AbstractSelection selection is provided, only the selected Atom instances are looped over. If an AbstractSelection selection is provided, only the selected Atom instances are looped over. If the given AbstractSelection selection is not of selection type Atom, it will be promoted to this type (using promote with default aggregator any). If an AbstractSelection inc_last_res is provided, all atoms in this AbstractSelection and in the last residue considered for the crankshaft movement will be included in the rotation. As an example, for a correct crankshaft movement in peptidic structures, the sidechain of the last residue should also be included in the rotation. In this example, inc_last_res should be !(an\"^CA$|^N$|^C$|^H$|^O$\"r). Note that the CrankshaftMutator syncs any pending internal to cartesian coordinate conversion (using the i2c! method). Requests cartesian to internal coordinates conversion (using request_c2i! method). Does not sync! the given Pose afterwards.\n\nThe CrankshaftMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(crankshaft_mutator::CrankshaftMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\nangle_sampler::Function - Should return a Float angle value (in radians). Is called with no input arguments;\np_mut::AbtractFloat - Compared against a rand() call, applies this Mutator to Atom instance pairs where rand() < p_mut;\nstep_size::AbstractFloat - Multiplies the sampled angle by this value;\nselection::Opt{AbstractSelection} - If given, this Mutator will only loop over the selected Atom instances;\ninc_last_res::Opt{AbstractSelection} - If given, all atoms in this Mutator and in the last residue considered for the crankshaft movement will be included in the rotation.\n\nSee also\n\nDihedralMutator\n\nExamples\n\njulia> ProtoSyn.Mutators.CrankshaftMutator(randn, 1.0, 1.0, nothing, nothing)\n⚯  Crankshaft Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | angle_sampler               | Function randn                 |\n| 2     | p_mut                       | 1.0000                         |\n| 3     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ○  Selection: Not Set\n ○  Include on last residue: Not Set\n\njulia> ProtoSyn.Mutators.CrankshaftMutator(randn, 0.01, 1.0, an\"CA\", !(an\"^CA$|^N$|^C$|^H$|^O$\"r))\n⚯  Crankshaft Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | angle_sampler               | Function randn                 |\n| 2     | p_mut                       | 0.0100                         |\n| 3     | step_size                   | 1.0000                         |\n+----------------------------------------------------------------------+\n ● Selection: Set\n └── FieldSelection › Atom.name = CA\n ● Include on last residue: Set\n └── UnarySelection ❯ ! \"not\" (Atom)\n      └── FieldSelection › Atom.name = r\"^CA$|^N$|^C$|^H$|^O$\"\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"(Image: ProtoSyn Crankshaft Mutator)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-crankshaft/","page":"Crankshaft Mutator","title":"Crankshaft Mutator","text":"Figure 1 | A schematic representation of a CrankshaftMutator instance. In this example, the selection an\"CA\" selects only pairs of carbon alpha Atom instances. For each pair of Atom instances possible, a random number (obtained by calling rand()) is compared against the CrankshaftMutator.p_mut field. If the random number is lower, the current Atom instance pair is selected for a crankshaft movement. A high value for p_mut therefore translates into a higher number of crankshaft rotations in a single call to the CrankshaftMutator. As a general rule, using a p_mut value of 2/N(N-1) will result in 1 rotation per call of the CrankshaftMutator, on average (where N is the number of atoms in the Pose or number of selected atoms by selection). A crankshaft movement is a concerted rotation of all Atom instances in the Graph between the two selected Atom instances, around an axis formed between the two selected Atom instances. The angle of the rotation is calculates from the CrankshaftMutator.angle_sampler call (with no input arguments), multiplied by CrankshaftMutator.step_size.","category":"page"},{"location":"protosyn-api/peptides/methods/graph/","page":"Graph","title":"Graph","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/methods/graph/#peptides-graph-methods","page":"Graph","title":"Graph","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/graph/","page":"Graph","title":"Graph","text":"This section lists functions that work on the system Graph, expanding on the Core methods (See Graph methods). These are subdivided by topics, for organization purposes:","category":"page"},{"location":"protosyn-api/peptides/methods/graph/","page":"Graph","title":"Graph","text":"sequence\nunbond!","category":"page"},{"location":"protosyn-api/peptides/methods/graph/#ProtoSyn.Peptides.sequence","page":"Graph","title":"ProtoSyn.Peptides.sequence","text":"sequence(container::ProtoSyn.AbstractContainer)::String\nsequence(pose::Pose)::String\n\nReturn the sequence of aminoacids (in 1 letter mode) of the given container/pose as a string.\n\nExamples\n\njulia> ProtoSyn.Peptides.sequence(pose)\n\"SESEAEFKQRLAAIKTRLQAL\"\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/graph/#ProtoSyn.Peptides.unbond!","page":"Graph","title":"ProtoSyn.Peptides.unbond!","text":"unbond!(pose::Pose, residue_1::Residue, residue_2::Residue; [keep_downstream_position::Bool = true])\n\nUnbond the two provided residues by severing the peptidic bond between the C atom of residue_1 and the N atom of residue_2. In order to do this, perform the following steps: unset parent/children, unbond neighbours, remove from Graph, remove from State, update the containers itemsbyname field. If keep_downstream_position is set to true (is, by default), the downstream Residue position is maintained (by calling request_c2i! and sync! methods).\n\nExamples\n\njulia> ProtoSyn.Peptides.unbond!(pose, pose.graph[1][2], pose.graph[1][3]; keep_downstream_position = true)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/methods/state/#core-state-methods","page":"State","title":"State","text":"","category":"section"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"This section lists functions that work on the system State. These methods are subdivided by topics, for organization purposes:","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Cartesian and internal coordinates conversion\nDihedral rotations\nMeasuring distances, angles and dihedrals\nIndexation","category":"page"},{"location":"protosyn-api/core/methods/state/#Cartesian-and-internal-coordinates-conversion","page":"State","title":"Cartesian and internal coordinates conversion","text":"","category":"section"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"The following functions deal with the conversion from internal to cartesian coordinates and vice-versa.","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"ukw: Note:\nInternal to cartesian conversion functions (and vice-versa) only apply to AtomState instances that have been modified (and therefore have the :changed field set to true). In the case of internal to cartesian coordinates conversion, updating any AtomState automatically forces downstream AtomState instances to be changed, and therefore updated. Note that the :changed flag is automatically set to true when modifying any AtomState field (including when changing the paired state.x StateMatrix), but the container state.i2c flag is not altered until explicitly request by request_i2c! or request_c2i! methods.","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"request_c2i!\nrequest_i2c!\nc2i!\ni2c!\nsync!","category":"page"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.request_c2i!","page":"State","title":"ProtoSyn.request_c2i!","text":"request_c2i!(state::State; [all::Bool = false])\n\nSets state.c2i to true. If all is set to true (false, by default), update all AtomState instances in the given State state to have :changed field set to true. Return the altered State state.\n\nSee also\n\nrequest_i2c! c2i!\n\nExamples\n\njulia> ProtoSyn.request_c2i!(pose.state)\nState{Float64}:\n Size: 343\n i2c: false | c2i: true\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.request_i2c!","page":"State","title":"ProtoSyn.request_i2c!","text":"request_i2c!(state::State; [all::Bool = false])\n\nSets state.i2c to true. If all is set to true (false, by default), update the first AtomState instance in the given State state (in the Root) to have :changed field set to true. Return the altered State state.\n\nSee also\n\nrequest_c2i! i2c!\n\nExamples\n\njulia> ProtoSyn.request_i2c!(pose.state)\nState{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.c2i!","page":"State","title":"ProtoSyn.c2i!","text":"c2i!(state::State{T}, top::Topology)\n\nUpdate the internal coordinates to match the measured cartesian coordinates, in the given State state. Note that only the AtomState instances with :changed field set to true will be updated, and the flag is therefore changed to false. Return the altered State state instance. If state.c2i is not set to true, return the original State state instance, without changes.\n\nSee also\n\ni2c! request_c2i!\n\nExamples\n\njulia> ProtoSyn.c2i!(pose.state, pose.graph)\nState{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.i2c!","page":"State","title":"ProtoSyn.i2c!","text":"i2c!(state::State{T}, top::Topology)\n\nUpdate the cartesian coordinates to match the measured internal coordinates, in the given State state. Note that only the AtomState instances with :changed field set to true will be updated, and the flag is therefore changed to false. Return the altered State state instance. If state.c2i is not set to true, return the original State state instance, without changes.\n\nukw: Note:\nAny AtomState that requires an update (has :changed flag set to true) will cause all downstream residues to be updated as well (in the same Graph).\n\nSee also\n\nc2i! request_i2c!\n\nExamples\n\njulia> ProtoSyn.i2c!(pose.state, pose.graph)\nState{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.sync!","page":"State","title":"ProtoSyn.sync!","text":"sync!(state::State, topology::Topology)\n\nCheck whether the given State state instance has either i2c or c2i flag set to true and if so update the cartesian/internal coordinates accordingly. Return the altered State instance. \n\nsync!(pose::Pose)\n\nCheck whether the given Pose instance has either i2c or c2i flag set to true in its pose.state field and if so update the cartesian/internal coordinates accordingly. Return the altered Pose instance. \n\nukw: Note:\nRequesting both i2c and c2i conversions simultaneously is not possible and will result in an error. Consider calling i2c! or c2i! to choose one of the coordinate systems to be synched. \n\nSee also\n\ni2c! c2i!\n\nExamples\n\njulia> sync!(pose.state, pose.graph)\nState{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"(Image: ProtoSyn c&i)","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Figure 1 | A diagram depicting the differences between the cartesian and internal coordinate systems. In the case of cartesian coordinates, each AtomState position is described by 3 numbers, the X, Y and Z coordinates. A StateMatrix compiles all cartesian coordinates and is useful when applying certain types of conformation changes. Employing the c2i! function allows for the synchronization of cartesian coordinates to internal coordinates. In this coordinate system, the position of each atom is still described by 3 numbers, but these are now the distance (b), angle (θ) and dihedral angle (ϕ) values relative to the parent/grand-parents. As an example, the position of the highlighted atom 12 is described by the distance to atom 11, the angle between atoms 9, 11 and itself, and finally by the dihedral angle of the atoms 8, 9, 11 and itself. Since a set of ascendents is necessary to establish the position of an AtomState, a set of 3 pseudoatoms (know as root) is necessary at the beggining of a Topology. Using this type of coordinates, it becomes extremly simple and efficient to perform large scale rotations of dihedral angles, since all positions are calculated based on the relative position to the ascendents. Employing the i2c! function allows for the synchronization from internal coordinates to cartesian coordinates.","category":"page"},{"location":"protosyn-api/core/methods/state/#Dihedral-rotations","page":"State","title":"Dihedral rotations","text":"","category":"section"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"The next functions deal with setting and rotating dihedral angles.","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"getdihedral\nsetdihedral!\nrotate_dihedral!\nsetoffset!","category":"page"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.getdihedral","page":"State","title":"ProtoSyn.getdihedral","text":"getdihedral(state::State, atom::Atom)\n\nGet the current dihedral value for Atom atom of State state (in radians, based on the internal coordinates). This value is the sum of the intrisic dihedral angle ϕ and the second ascendent Δϕ.\n\nSee also\n\nascendents setdihedral! dihedral\n\nExamples\n\njulia> getdihedral(pose.state, pose.graph[1][2][\"N\"])\n3.141592653589793\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.setdihedral!","page":"State","title":"ProtoSyn.setdihedral!","text":"setdihedral!(state::State, atom::Atom, value::T) where {T <: AbstractFloat}\n\nSet the dihedral in Atom atom of State state to be exactly value (in radians). Automatically requests internal to cartesian coordinate conversion (by setting state.i2c as true). Return the altered State state.\n\nSee also\n\nascendents request_i2c! getdihedral rotate_dihedral!\n\nExamples\n\njulia> setdihedral!(pose.state, pose.graph[1][1][end], Float64(π))\nState{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.rotate_dihedral!","page":"State","title":"ProtoSyn.rotate_dihedral!","text":"rotate_dihedral!(state::State, atom::Atom, value::T) where {T <: AbstractFloat}\n\nRotate the dihedral in Atom atom of State state by value (in radians, adds to the current dihedral angle). Automatically requests internal to cartesian coordinate conversion (by setting state.i2c as true). Return the altered State state.\n\nSee also\n\nascendents request_i2c! getdihedral setdihedral!\n\nExamples\n\njulia> rotate_dihedral!(pose.state, pose.graph[1][1][end], Float64(π))\nState{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.setoffset!","page":"State","title":"ProtoSyn.setoffset!","text":"setoffset!(state::State{T}, at::Atom, default::Number) where {T <: AbstractFloat}\n\nRotate all sibling dihedrals of Atom atom in the given State state so that the dihedral angle identified by atom is equal to default. Set the i2c flag to true and return the altered State state.\n\nSee also\n\nLGrammar\n\nExamples\n\njulia> ProtoSyn.setoffset!(pose.state, pose.graph[1][2][\"CA\"], 3.14)\nState{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"(Image: ProtoSyn c&i)","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Figure 2 | An illustration of rotate_dihedral! method in action. This method (as well as setdihedral!) rotate a dihedral by altering the :Δφ field in the correct AtomState instance. For this example, the rotate_dihedral! was applied to atom C. The position of this atom, according to the internal coordinates system, is dictated by 3 numbers: the distance, angle and dihedral angle to its ascendents. This last value, the dihedral angle, can be further decomposed in 2 contributions: the AtomState intrinsic dihedral field (:φ) plus the parent AtomState :Δφ field. Since this logic applies to all AtomState instances, both atoms CB and HA of this example also have their position dictated by its parent AtomState :Δφ field, which, in this case, is CA. This means that altering :Δφ in CA will affect the position of C, CB and HA by the same measure, in a concerted manner. This, in essence, means rotating the C-N-CA-C dihedral (or Phi dihedral of the aminoacid, in this example). Note that since we are using internal coordinates, this rotation is also applied to all children AtomState instances, since their position is relative to the parent.","category":"page"},{"location":"protosyn-api/core/methods/state/#Measuring-distances,-angles-and-dihedrals","page":"State","title":"Measuring distances, angles and dihedrals","text":"","category":"section"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"distance\nangle\ndihedral","category":"page"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.distance","page":"State","title":"ProtoSyn.distance","text":"distance(at1::AtomState, at2::AtomState)\n\nCalculates the distance between the two AtomState instances (at1 and at2), based on the cartesian coordinates. Note: Make sure the corresponding Pose instance has been synched (using the sync! method). Returns result in Angstrom (Å).\n\nSee also\n\nangle dihedral\n\nExamples\n\njulia> d = ProtoSyn.distance(pose.state[1], pose.state[2])\n1.0093879999999997\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.angle","page":"State","title":"ProtoSyn.angle","text":"angle(at1::AtomState, at2::AtomState, at3::AtomState)\n\nCalculates the angle between the three AtomState instances (at1, at2 and at3), based on the cartesian coordinates. Note: Make sure the corresponding Pose instance has been synched (using the sync! method). Returns result in radians.\n\nSee also\n\ndistance dihedral\n\nExamples\n\njulia> a = ProtoSyn.angle(pose.state[1], pose.state[2], pose.state[3])\n0.6444967663659441\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.dihedral","page":"State","title":"ProtoSyn.dihedral","text":"dihedral(at1::AtomState, at2::AtomState, at3::AtomState, at4::AtomState)\n\nCalculates the dihedral angle between the four AtomState instances (at1, at2, at3 and at4), based on the cartesian coordinates. Note: Make sure the corresponding Pose instance has been synched (using the sync! method). Returns result in radians.\n\nExamples\n\njulia> a = ProtoSyn.dihedral(pose.state[1], pose.state[2], pose.state[3], pose.state[4])\n-1.2318251145557122\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/state/#core-state-methods-indexation","page":"State","title":"Indexation","text":"","category":"section"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"In order to access an AtomState instance in a State, ProtoSyn makes available, essentially, three methods:","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Using the regular syntax;","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"pose.state.items[4]","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"ukw: Note:\nIn the items field, AtomState instances are indexed including the Root (which occupies the first three positions). Atom 1 is therefore at index 4. This is taken into account when using the short syntax (recommended).","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Using the short syntax with index;","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"pose.state[1]","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Using the short syntax with an Atom instance;","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"atom = pose.graph[1, 1, 1]\npose.state[atom]","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"Indexation methods make sure the Pose State structure remains coherent with the Graph structure, in terms of order.","category":"page"},{"location":"protosyn-api/core/methods/state/","page":"State","title":"State","text":"reindex(::State)","category":"page"},{"location":"protosyn-api/core/methods/state/#ProtoSyn.reindex-Tuple{State}","page":"State","title":"ProtoSyn.reindex","text":"reindex(state::State)\n\nRe-indexes the whole State state (excluding the Root), setting the :index field of AtomState instances. Return the altered State state.\n\nukw: Note:\nSince we are altering a field of AtomState structs, the :changed field will automatically be set to true and therefore be updated in a future sync! call (if either :i2c or :c2i flag in the corresponding state is set to true).\n\nSee also\n\nreindex(::Topology, ::Bool)\n\nExamples\n\njulia> reindex(pose.state)\nState{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/methods/io/#core-io","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"","category":"section"},{"location":"protosyn-api/core/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"The following methods allow the user to load and export models and data from and to files.","category":"page"},{"location":"protosyn-api/core/methods/io/","page":"Input and Output (IO)","title":"Input and Output (IO)","text":"load\nwrite\nappend","category":"page"},{"location":"protosyn-api/core/methods/io/#ProtoSyn.load","page":"Input and Output (IO)","title":"ProtoSyn.load","text":"load([::Type{T}], filename::AbstractString, [bonds_by_distance::Bool = false]) where {T <: AbstractFloat}\n\nLoad the given filename into a pose, parametrized by T. If this is not provided, the default ProtoSyn.Units.defaultFloat is used. The file format is infered from the extension (Supported: .pdb, .yml). If bonds_by_distance is set to true (false, by default), the CONECT records will be complemented with bonds infered by distance. The distances for each pair of atoms is defined in ProtoSyn.Units.bond_lengths (in Angstrom Å, with a standard deviation threshold of 0.1 Å). Return the resulting Pose instance.\n\nSee also\n\ndistance\n\nukw: Note:\nThis function tries to infer information of the parenthood and ascendents of each atom, using the CONECT records of infered bonds_by_distance. The parents are arbitrarily defined as the first bond found, by order, and any atom without parent is connected to the root. All Residue instances have the root.container as parent. Note that this infered information may need to be manually corrected.\n\nExamples\n\njulia> ProtoSyn.load(\"2a3d.pdb\")\nPose{Topology}(Topology{/2a3d:6263}, State{Float64}:\n Size: 1140\n i2c: false | c2i: true\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/io/#ProtoSyn.write","page":"Input and Output (IO)","title":"ProtoSyn.write","text":"ProtoSyn.write(pose::Pose, filename::String)\n\nWrite to file the given Pose pose. The file format is infered from the filename extension (Supported: .pdb, .yml). The Pose pose structure is automatically synched (using thesync! method) when writting to file, as only the cartesian coordinates are used.\n\nSee also\n\nappend\n\nExamples\n\njulia> ProtoSyn.write(pose, \"new_file.pdb\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/io/#ProtoSyn.append","page":"Input and Output (IO)","title":"ProtoSyn.append","text":"ProtoSyn.append(pose::Pose, filename::String, [model::Int = 1])\n\nAppend to file the given Pose pose (as a new frame, identified by the model number model: default is 1). The file format is infered from the filename extension (Supported: .pdb, .yml). The Pose pose structure is automatically synched (using thesync! method) when writting to file, as only the cartesian coordinates are used.\n\nSee also\n\nwrite\n\nExamples\n\njulia> ProtoSyn.append(pose, \"new_file.pdb\")\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/","page":"Bond distance Restraint","title":"Bond distance Restraint","text":"CurrentModule = ProtoSyn.Calculators.Restraints","category":"page"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/#Bond-Distance-Restraint","page":"Bond distance Restraint","title":"Bond Distance Restraint","text":"","category":"section"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/","page":"Bond distance Restraint","title":"Bond distance Restraint","text":"The Bond Distance Restraint is a potential restraint. However, in contrast with other Potential Restraints in ProtoSyn, a distance_matrix is not calculated. Instead, the Pose's Graph is iterated (See Counters and Iterators), and all bonds of an Atom are measured and evaluated according to a given potential.","category":"page"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/","page":"Bond distance Restraint","title":"Bond distance Restraint","text":"calc_bond_distance_restraint\nget_default_bond_distance_restraint","category":"page"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/#ProtoSyn.Calculators.Restraints.calc_bond_distance_restraint","page":"Bond distance Restraint","title":"ProtoSyn.Calculators.Restraints.calc_bond_distance_restraint","text":"calc_bond_distance_restraint([::Type{A}], pose::Pose, update_forces::Bool = false; x0::T = 2.0) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat}\n\nCalculate the Pose pose bond distance restraint energy according to a quadratic potential, based on the cartesian coordinates (make sure the Pose pose is synched, see sync!). This potential defines a maximum distance for the bond, based on the elements involved in the bond (See ProtoSyn.max_bond_lengths). If the pair of elements is not found, a default x0 value is used instead. This function iterates over all Atom instances in the provided Pose pose (See Counters and Iterators) and checks all bonds in each Atom. This means that bonds energy and forces are usually checked twice, as both Atom instances involved in a bond have records on one another. This is usually not a problem, as the energy value is compared between frames in a simulation environment and therefore the scale of the value is not important. If the update_forces flag is set to true (false, by default), also return the calculated forces based on this potential. Note that this function assumes Atom.id entries are synched between the Graph and State (See Indexation). An optional parameter Type{<: AbstractAccelerationType} can be provided, stating the acceleration type used to calculate this energetic contribution (See ProtoSyn acceleration types).\n\nukw: Note:\nAs of ProtoSyn 1.0, this function's acceleration type defaults to SIMD_0 regardless of the requested acceleration type. This may be changed in future iterations.\n\nSee also\n\nget_default_bond_distance_restraint\n\nExamples\n\njulia> ProtoSyn.Calculators.Restraints.calc_bond_distance_restraint(pose)\n(0.0, nothing)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/#ProtoSyn.Calculators.Restraints.get_default_bond_distance_restraint","page":"Bond distance Restraint","title":"ProtoSyn.Calculators.Restraints.get_default_bond_distance_restraint","text":"   get_default_bond_distance_restraint(;α::T = 1.0) where {T <: AbstractFloat}\n\nReturn the default bond distance restraint    EnergyFunctionComponent. α sets the component weight (on an    EnergyFunction instance, 1.0    by default). This function employs    calc_bond_distance_restraint    as the :calc function.\n\nSettings\n\nx0::Float64 - The maximum allowed bond distance. Any bond with a longer distance will be subjected to a quadratic energy penalty. This value is normally extracted from ProtoSyn.Units.max_bond_lengths. If the pair of Atom instances identified in a bond is not found in this table, use this default x0 value (Default: 2.0).\n\nSee also\n\ncalc_bond_distance_restraint\n\nExamples\n\njldoctest    julia> ProtoSyn.Calculators.Restraints.get_default_bond_distance_restraint()    Name : Bond_Distance_Restraint    Weight (α) : 1.0 Update forces : true       Setings :            :x0 => 2.0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/","page":"Bond distance Restraint","title":"Bond distance Restraint","text":"(Image: ProtoSyn Bond Distance Restraint)","category":"page"},{"location":"protosyn-api/core/calculators/bond-distance-restraint/","page":"Bond distance Restraint","title":"Bond distance Restraint","text":"Figure 1 | A diagram representation of the Bond Distance Restraint EnergyFunctionComponent. The applied potential is a quadratic function, with domain between [x0, +∞]. The x0 setting is parametrized based on observed distances between paits of Atom instances, according to the provided table (saved in ProtoSyn.Units.max_bond_lengths). If any given pair of atoms is not found in this table, the default x0 value of the EnergyFunctionComponent is used instead (2.0 Å, by default).","category":"page"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"CurrentModule = ProtoSyn.Peptides.Mutators","category":"page"},{"location":"protosyn-api/peptides/mutators/design/#Design-Mutator","page":"Design Mutator","title":"Design Mutator","text":"","category":"section"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"One of the AbstractMutator types made available by the ProtoSyn.Peptides module is the DesignMutator, whose objective is to select one or more random Residue instances (optionally, in a selection) for design, changing the aminoacid nature (and, consequentially, the sidechain Atom instances). ","category":"page"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"DesignMutator","category":"page"},{"location":"protosyn-api/peptides/mutators/design/#ProtoSyn.Peptides.Mutators.DesignMutator","page":"Design Mutator","title":"ProtoSyn.Peptides.Mutators.DesignMutator","text":"DesignMutator(p_mut::AbstractFloat, grammar::LGrammar, selection::Opt{AbstractSelection}; [searchable_aminoacids::Dict{Char, Bool} = Peptides.available_aminoacids])\n\nReturn a DesignMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(design_mutator::DesignMutator)(pose::Pose)\n\nThe DesignMutator AbstractMutator loops through all Atom instances in the given Pose and applies a mutation (using the mutate! method) if a random number (rand()) is bellow a given probability of mutation p_mut. A different mutation is attempted for each Atom instance looped over (therefore, for a single attempt at a mutation per Residue, unique Atom names should be selected, as an\"CA\", for example). If an AbstractSelection selection is provided, only Atom instances marked as true in this selection are considered for mutation. The applied mutation is sampled from the given searchable_aminoacids dictionary (only for entries marked as true), and uses the given LGrammar grammar to perform the mutation. If no searchable_aminoacids dictionary is provided, will use the default Peptides.available_aminoacids dictionary (contains all aminoacids set as true). Note that the DesignMutator syncs any pending cartesian to internal coordinate conversion (using the c2i! method). Requests internal to cartesian coordinates conversion (using the request_i2c! method). Does not sync! the given Pose afterwards.\n\nThe DesignMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator.\n\n(design_mutator::DesignMutator)(pose::Pose, atoms::Vector{Atom})\n\nFields\n\np_mut::AbtractFloat - Compared against a rand() call, applies this Mutator to Atom instances where rand() < p_mut;\ngrammar::LGrammar - The LGrammar instance with the aminoacid templates;\nselection::Opt{AbstractSelection} - If given, this Mutator will only loop over the selected Atom instances;\nsearchable_aminoacids::Dict{Char, Bool} - The dictionary of available aminoacids, where each entry sets the availability of that aminoacid type to be the result of the mutation.\n\nSee also\n\nRotamerMutator\n\nExamples\n\njulia> dm = ProtoSyn.Peptides.Mutators.DesignMutator(1.0, res_lib, an\"CA\")\n⚯  Design Mutator:\n+----------------------------------------------------------------------+\n| Index | Field                       | Value                          |\n+----------------------------------------------------------------------+\n| 1     | grammar                     | Set ✓                          |\n| 2     | p_mut                       | 1.000                          |\n+----------------------------------------------------------------------+\n ● Searchable aminoacids: M 🗹 | K 🗹 | P 🗹 | N 🗹 | I 🗹 | H 🗹 | E 🗹 | W 🗹 | S 🗹 | T 🗹 | C 🗹 | D 🗹 | A 🗹 | L 🗹 | Y 🗹 | V 🗹 | R 🗹 | G 🗹 | Q 🗹 | F 🗹 \n ● Selection: Set\n └── FieldSelection › Atom.name = CA\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"(Image: ProtoSyn Design Mutator Card)","category":"page"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"Figure 1 | Schematic description of the DesignMutator. ","category":"page"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"(Image: ProtoSyn Design Mutator)","category":"page"},{"location":"protosyn-api/peptides/mutators/design/","page":"Design Mutator","title":"Design Mutator","text":"Figure 2 | Example of the application of DesignMutator to simulateously mutate of all Residue instances. ","category":"page"},{"location":"getting-started/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"A major focus of ProtoSyn was the compilation of an extensive list of tutorials and examples. The main list of example notebook files can be found at the Examples folder, in the GitHub repository. In the next section, a quick description and link to each individual example can be found.","category":"page"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"1 - Getting started\n2 - Selections\n3 - Molecular manipulation\n4 - Energy calculation\n5 - Monte Carlo\n6 - Steepest Descent\n7 - ILS\n8 - Design\n9 - Sidechain packaging\n10 - Rigid body docking\n11 - Distributed computing\n12 - Materials & Sugars","category":"page"},{"location":"getting-started/examples/#examples-getting-started","page":"Examples","title":"1 - Getting started","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. In this first example script, we will explore how ProtoSyn.jl is organized and what are the available data structures. The example script is divided in 4 parts: loading a PDB file, exploring the graph structure, exploring the state structure and exporting a Pose into a PDB file. For more details, check the Core Types section of this manual.","category":"page"},{"location":"getting-started/examples/#Selections","page":"Examples","title":"2 - Selections","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. ProtoSyn comes equipped with a powerful selecting syntax, useful for highlighting and specifying targets for the several manipulation tools of ProtoSyn. In this example, we will take a closer look at the different type of selections and how to apply them. For more information, check the Selections section of this manual.","category":"page"},{"location":"getting-started/examples/#Molecular-manipulation","page":"Examples","title":"3 - Molecular manipulation","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. One of the main applications of ProtoSyn is the easy manipulation of molecular structures: add and remove residues and whole loops, mutate aminoacids, bond and unbond atoms or completly remove them from the structure, and even create completly new sequences of aminoacids from scratch. These are just some examples of the manipulations possible with the ProtoSyn framework. In the next examples we will explore a few of these tasks. For more details, check the Core Pose methods and the Peptides Pose methods sections.","category":"page"},{"location":"getting-started/examples/#Energy-calculation","page":"Examples","title":"4 - Energy calculation","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. One of the main applications of ProtoSyn is the easy manipulation of molecular structures: add and remove residues and whole loops, mutate aminoacids, bond and unbond atoms or completly remove them from the structure, and even create completly new sequences of aminoacids from scratch. These are just some examples of the manipulations possible with the ProtoSyn framework. In the next examples we will explore a few of these tasks. For more details, check the Core Pose methods and the Peptides Pose methods sections.","category":"page"},{"location":"getting-started/examples/#Monte-Carlo","page":"Examples","title":"5 - Monte Carlo","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. Besides the possibility to create custom simulation algorithms, ProtoSyn already provides several of these algorithms by default. A common simulation type is the Monte Carlo sampling. In this type of simulation, the conformational space is explored (or sampled) and the resulting candidate structure is evaluated and compared to the previous state. If the new energy is lower than the previous value (or accepted by an heuristic criterium, such as the Metropolis criterium), the new structure is saved for the continuation of the simulation. Otherwise, recover the previous structure and attempt a diferent change. This loop continues for N steps until the completion of the simulation. In this example, we will build a Monte Carlo simulation driver, while taking a first look at some important ProtoSyn components: the Mutators, Drivers and Callback instances. For more information, check the following sections of the manual: the Mutators section, the Monte Carlo Driver section and Callbacks section.","category":"page"},{"location":"getting-started/examples/#Steepest-Descent","page":"Examples","title":"6 - Steepest Descent","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. ProtoSyn makes available the Steepest Descent Driver, whose simulation algorithm calculates the forces being felt on each atom of a molecular structure (via an Energy Function instance) and updates the atoms position in accordance, as to relax the structure. for more information check the Steepest Descent Driver section.","category":"page"},{"location":"getting-started/examples/#ILS","page":"Examples","title":"7 - ILS","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. ILS stands for \"Iterated Local Search\" and it's a conformational search algorithm. In short, this algorithm is divided in two main components, the inner and outer loop. The inner loop can be, for example, a Monte Carlo simulation, and should explore and sample the local minimum, while the outer loop performs a \"jump\": a large conformational change, taking the system to a whole different local minimum for the next inner loop iteration. In this way, the conformational space can be efficiantly sampled, with a higher certainty of exploring the global minimum during the simulation. In ProtoSyn, this algorithm is employed as a Driver, and will be briefly explored in this example. For more details, check the ILS Driver of this manual.","category":"page"},{"location":"getting-started/examples/#Design","page":"Examples","title":"8 - Design","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. One of the main goals of ProtoSyn is to provide an easy interface for the design of small peptides. This is achieved by mutating residues (more often than not in a specific region, i.e.: an active site) in order to stabilize certain interactions. In this example we will explore the DesignMutator (which provides random mutations in a selection). More more details, check the Design Mutator section of the manual.","category":"page"},{"location":"getting-started/examples/#Sidechain-packaging","page":"Examples","title":"9 - Sidechain packaging","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. A sub-problem of protein design is the correct packaging of aminoacid sidechains, that is, to find the correct rotamer (i.e.: set of sidechain chi dihedral angles) that minimizes clashes and augments stabilizing interactions with other sidechains in the 3D space. The conformational space to explore is, therefore, enormous. Several rotamer libraries have been proposed in the past to minimize this space by impossing certain restrictions. By default, ProtoSyn employs the Dunbrack Rotamer Library 2011, which reduces the rotamers to the most observed combination in natural databases, as well as imposing backbone dependency (i.e.: certain rotamers are only present for a given combination of backbone phi and phi dihedral angles). This greatly reduces the conformational space to search, while improving the likelihood of acceptance of a new rotamer. With this mind, in ProtoSyn, we can load a rotamer library and sample new rotamers, in a Monte Carlo simulation, in order to improve the sidechain packaging of a peptide. For more details, check the Rotamer Mutator section of this manual.","category":"page"},{"location":"getting-started/examples/#Rigid-body-docking","page":"Examples","title":"10 - Rigid body docking","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. ProtoSyn makes available two Rigid Body Mutators: translational and rotational. These allow the translation and rotation of blocks of residues (such as a ligand or a second molecule). With these, users are able to create custom Rigid Body Docking algorithms (for example, by moving a ligand to a grid of starting positions). In this quick example, we will take a look at a simplistic approach to rigid body docking, using a Monte Carlo simulation. In each step, short rotation and translation movements are attempted and, after evaluation by an energy function, accepted or rejected based on the Metropolis Criterium. For more information, consider reading the Rigid Body Mutators section of this manual.","category":"page"},{"location":"getting-started/examples/#Distributed-computing","page":"Examples","title":"11 - Distributed computing","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. By being developed in Julia, ProtoSyn enjoys some of the features naturally provided by the language, such as easy SIMD and GPU acceleration, a rich package environment and, among others, access to high level parallel and distributed computing routines. In this example we will take a look on how to launch and gather several decoys of the same Monte Carlo simulation. By having multiple decoys in parallel, given the random nature of the algorithm, we can have a greater confidence in the complete sampling of the conformational space, and that the obtained result is real. For more information, reffer to the Julia's Distributed Computing manual section.","category":"page"},{"location":"getting-started/examples/#Materials-and-Sugars","page":"Examples","title":"12 - Materials & Sugars","text":"","category":"section"},{"location":"getting-started/examples/","page":"Examples","title":"Examples","text":"You can find the example file here. Besides the Core and Peptides modules, ProtoSyn includes extra modules, such as the Materials and the Sugars modules. In this example, we will briefly explore the goals of each of these two modules. Note that these modules are not the focus of ProtoSyn, in its current version, and may be improved in future iterations. For more details, check the Materials and Sugars sections of this manual.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/","page":"Monte Carlo","title":"Monte Carlo","text":"CurrentModule = ProtoSyn.Drivers","category":"page"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/#Monte-Carlo-Driver","page":"Monte Carlo","title":"Monte Carlo Driver","text":"","category":"section"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/","page":"Monte Carlo","title":"Monte Carlo","text":"The Monte Carlo Driver uses a sampling AbstractMutator to generate a conformational change, evaluating it accoridng to a given EnergyFunction or custom evaluating function, and deciding wether to keep the new Pose or return to the previous State according to the Metropolis Criterion.","category":"page"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/","page":"Monte Carlo","title":"Monte Carlo","text":"MonteCarlo\nMonteCarloState","category":"page"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/#ProtoSyn.Drivers.MonteCarlo","page":"Monte Carlo","title":"ProtoSyn.Drivers.MonteCarlo","text":"MonteCarlo(eval!::Union{Function, EnergyFunction}, sample!::Union{Function, AbstractMutator, Driver}, callback::Opt{Callback}, max_steps::Int, temperature::Function)\n\nA MonteCarlo Driver instance. As such, this object is callable as a functor with the following signature:\n\n(driver::MonteCarlo)(pose::Pose)\n\nThis simulation performs a Markov Chain Monte Carlo algorithm (MCMC), more especifically, the Metropolis-Hastings method. Starting from an initial Pose pose conformation, new changes are imposed by calling the given sample! method (this is an AbstractMutator, Driver or a custom sampling function). Note that the Pose is synched (using the sync! method) after each sample! call. The two Pose instances are evaluated by calling the eval! method (an EnergyFunction or custom evaluator function). Following the Metropolis Criterion, the new Pose is accepted if the evaluated energy is lower than the previous Pose, or, otherwise, with a given probability based on the temperature of the simulation:\n\n rand()e^-fracE_n+1-E_nT \n\nWhere E_n+1 is the energy of new Pose, E_n is the current Pose energy and T is current temperature of the simulation. As such, higher temperature values correlate with a higher chance to accept higher energy Pose instances (in order to overcome energy barriers). If rejected, the previous Pose is recovered for a new attempt. This simulation loop (sample! -> eval! -> metropolis criterion) continues for a total of max_steps. Each step, a call to an optional Callback callback is performed. A companion MonteCarloState DriverState instance is also updated each step and provided to the Callback callback.\n\nFields\n\neval!::Union{Function, EnergyFunction} - The evaluator EnergyFunction or custom function, receives two input arguments: a Pose pose and a calc_forces::Bool boolean;\nsample!::Union{Function, AbstractMutator, Driver} - The sampler method, receives a Pose pose as the single input argument;\ncallback::Opt{Callback} - An optional Callback instance, receives two input arguments: the current Pose pose and the current DriverState driver_state;\nmax_steps::Int - The total number of simulation steps to be performed;\ntemperature::Function - The temperature function thermostat (see Available thermostats), receives the current step (as an Int) as the single input argument.\n\nSee also\n\nMonteCarloState\n\nExamples\n\njulia> monte_carlo = ProtoSyn.Drivers.MonteCarlo(\n                  energy_function,\n                  dihedral_mutator,\n                  ProtoSyn.Common.default_energy_step_callback(1),\n                  10,\n                  ProtoSyn.Drivers.get_linear_quench(1.0, 10))\n⚒  Monte Carlo Driver:\n ├──  ●  Evaluator:\n |    └── 🗲  Energy Function (4 components):\n |        +----------------------------------------------------------------------+\n |        | Index | Component name                                | Weight (α)   |\n |        +----------------------------------------------------------------------+\n |        | 1     | TorchANI_ML_Model                             |      1.000   |\n |        | 2     | Caterpillar_Solvation                         |      0.010   |\n |        | 3     | Bond_Distance_Restraint                       |      1.000   |\n |        | 4     | Cα-Cα_Clash_Restraint                         |    100.000   |\n |        +----------------------------------------------------------------------+\n |   \n ├──  ● Sampler:\n |    └── ⚯  Dihedral Mutator:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                       | Value                          |\n |        +----------------------------------------------------------------------+\n |        | 1     | angle_sampler               | Function randn                 |\n |        | 2     | p_mut                       | 0.0100                         |\n |        | 3     | step_size                   | 0.5000                         |\n |        +----------------------------------------------------------------------+\n |         ● Selection: Set\n |         └── FieldSelection › Atom.name = r\"C|N\"\n |   \n ├──  ● Callback:\n |    └── ✉  Callback:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                     | Value                            |\n |        +----------------------------------------------------------------------+\n |        | 1     | Event                     | energy_step                      |\n |        | 2     | Frequency                 | 1                                |\n |        +----------------------------------------------------------------------+\n |   \n └──  ● Settings:\n       Max steps: 10\n     Temperature: linear_quench\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/#ProtoSyn.Drivers.MonteCarloState","page":"Monte Carlo","title":"ProtoSyn.Drivers.MonteCarloState","text":"MonteCarloState{T <: AbstractFloat}(step::Int = 0, converged::Bool = false, completed::Bool = false, stalled::Bool = false, acceptance_count = 0, temperature::T = T(0.0))\nMonteCarloState{T <: AbstractFloat}()\n\nA MonteCarloState instance is a DriverState that keeps track of a MonteCarlo simulation status. Besides the default :step, :converged, :completed and :stalled fields, a MonteCarloState instance adds the following tracking fields specific for MonteCarlo simulations:\n\nacceptance_count::Int - The number of accepted Pose changes by the Metropolis criterion;\ntemperature::T - The current temperature of the simulation.\n\nSee also\n\nMonteCarlo\n\nExamples\n\njulia> ProtoSyn.Drivers.MonteCarloState{Float64}()\nProtoSyn.Drivers.MonteCarloState{Float64}(0, false, false, false, 0, 0.0)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/","page":"Monte Carlo","title":"Monte Carlo","text":"(Image: ProtoSyn monte-carlo-driver)","category":"page"},{"location":"protosyn-api/core/drivers/drivers-monte-carlo/","page":"Monte Carlo","title":"Monte Carlo","text":"Figure 1 | A schematic overview of the different stages in a MonteCarlo Driver: (1) - Sampling a new conformation; (2) - Evaluating the new Pose; (3) - Metropolis Criterion, the new Pose conformation is either accepted (in which case it is saved as a reference for further steps in the simulation) or rejected (where the current state is recovered from a saved Pose to the previous step).","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"protosyn-api/core/methods/pose/#pose-methods","page":"Pose","title":"Pose","text":"","category":"section"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"As previously stated, a Pose is the main object of ProtoSyn and brings together both the Graph and the State. The following methods directly operate on Pose structs. These methods are subdivided by topics, for organization purposes:","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"Creating, appending and inserting Fragments\nAppending, inserting and removing Atom and Residue instances\nCopying and merging\nAligning poses","category":"page"},{"location":"protosyn-api/core/methods/pose/#Creating,-appending-and-inserting-Fragments","page":"Pose","title":"Creating, appending and inserting Fragments","text":"","category":"section"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"The next methods allow a user to create a new Fragment from a Pose instance and append or insert in in an existing structure. Note: creation of a new Fragment from a sequence of Residue codes is available at the Builder submodule.","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"fragment(::Pose{Topology})\nfragment!\nisfragment\nappend_fragment_as_new_segment!(::Pose{Topology}, ::Fragment)\nappend_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Pose{Segment}; ::Any)\ninsert_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Pose{Segment}; ::Any, ::Bool)","category":"page"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.fragment-Tuple{Pose{Topology}}","page":"Pose","title":"ProtoSyn.fragment","text":"fragment(pose::Pose{Topology})\n\nReturn a Fragment from a given Pose pose. The pose must have a single Segment.\n\nfragment(pose::Pose{Topology}, selection::ProtoSyn.AbstractSelection)\n\nReturn a Fragment from a list of residues retrieved from the given selection when applied to the provided Pose pose. If not yet of selection type Residue, the selection will be promoted to Residue selection type (with the default any aggregating function). The resulting list of residues must be contiguous (a connected graph of Residue instances parenthoods). These will constitute the unique Segment of the resulting Fragment.\n\nukw: Note:\nA Fragment is a Pose{Segment}, without a root/origin. These are usually used as temporary carriers of information, without the ability to be directly incorporated in simulations.\n\nExamples\n\njulia> frag = fragment(pose)\nFragment(Segment{/UNK:9547}, State{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> frag = fragment(pose, rid\"1:10\")\nFragment(Segment{/UNK:58266}, State{Float64}:\n Size: 160\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.fragment!","page":"Pose","title":"ProtoSyn.fragment!","text":"fragment!(pose::Pose{Topology}, selection::ProtoSyn.AbstractSelection; [keep_downstream_position::Bool = true])\n\nReturn a Fragment from a list of residues retrieved from the given AbstractSelection selection when applied to the provided Pose pose. If not yet of selection type Residue, the selection will be promoted to Residue selection type (with the default any aggregating function). The resulting list of residues must be contiguous (a connected graph of Residue instances parenthoods). These will constitute the unique Segment of the resulting Fragment. In opposition to the fragment method, this function will remove the fragmented Residue instances from the original Pose (using the pop_residue! method). If keep_downstream_position is set to true (is, by default), the downstream Residue position is maintained (by calling request_c2i! and sync! methods).\n\nukw: Note:\nA Fragment is a Pose{Segment}, without a root/origin. These are usually used as temporary carriers of information, without the ability to be directly incorporated in simulations.\n\nExamples\n\njulia> frag = fragment!(pose, rid\"19:26\")\nFragment(Segment{/UNK:9547}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.isfragment","page":"Pose","title":"ProtoSyn.isfragment","text":"isfragment(pose::Pose)\n\nReturn true if the given pose Graph is a single non-empty Segment (with no container).\n\nSee also\n\nfragment\n\nExamples\n\njulia> isfragment(frag)\ntrue\n\njulia> isfragment(pose)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.append_fragment_as_new_segment!-Tuple{Pose{Topology}, Fragment}","page":"Pose","title":"ProtoSyn.append_fragment_as_new_segment!","text":"append_fragment_as_new_segment!(pose::Pose{Topology}, frag::Fragment)\n\nAppend a Fragment frag as a new Segment to the given Pose pose. This function overwrites pose.\n\nSee also\n\nisfragment fragment\n\nExamples\n\njulia> ProtoSyn.append_fragment_as_new_segment!(pose, frag)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.append_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Fragment}","page":"Pose","title":"ProtoSyn.append_fragment!","text":"append_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, frag::Pose{Segment}; op = \"α\")\n\nAdd the Fragment frag to the given Pose pose, appending it after the given Residue residue. This residue and the new Fragment frag will be connected using operation op (\"α\" by default) of the given LGrammar grammar. Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nSee also\n\ninsert_fragment!\n\nExamples\n\njulia> ProtoSyn.append_fragment!(pose, pose.graph[1][end], res_lib, frag)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.insert_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Fragment}","page":"Pose","title":"ProtoSyn.insert_fragment!","text":"insert_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, frag::Pose{Segment}; op = \"α\")\n\nInsert the Fragment frag in the given pose, on the position of the provided Residue instance residue (the residue gets shifted downstream). This first downstream Residue and the new Fragment will be connected using operation op (\"α\" by default) from [LGrammar] grammar. Also connects to the upstream Residue instance, using the same operation. Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nukw: Note:\nConsider using more specific versions of this function, see Peptides.insert_fragment!\n\nSee also\n\nappend_fragment!\n\nExamples\n\njulia> ProtoSyn.insert_fragment!(pose, pose.graph[1][1], res_lib, frag)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/pose/#Appending,-inserting-and-removing-Atom-and-Residue-instances","page":"Pose","title":"Appending, inserting and removing Atom and Residue instances","text":"","category":"section"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"In this section the methods responsible to manipulating the molecular structure of a Pose are explored.","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"insert_atom_as_children!\npop_atom!\npop_residue!","category":"page"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.insert_atom_as_children!","page":"Pose","title":"ProtoSyn.insert_atom_as_children!","text":"insert_atom_as_children!(pose::Pose, parent_atom::Atom, atom::Atom, [atomstate::Opt{AtomState} = nothing])\n\nAdd the given Atom atom to the Pose pose graph, as a child of parent_atom. Correctly sets atom.container, container.size, container.items_by_name, parenthood relationships, bonds, indexes and ascedents. If an optional AtomState atomstate is provided, the inserted atom's State is set, otherwise, insert an empty State (with all internal and cartesian coordinates set to zero). Return the modified (in-place) Pose pose.\n\nExamples\n\njulia> ProtoSyn.insert_atom_as_children!(pose, pose.graph[1][1][1], Atom(\"N\", 1, 1, \"N\"))\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 344\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.pop_atom!","page":"Pose","title":"ProtoSyn.pop_atom!","text":"pop_atom!(pose::Pose{Topology}, atom::Atom; [keep_downstream_position::Bool = true])\n\nPop and return the given Atom atom from the given Pose pose. In order to do this, perform the following actions:\n\nUnset parenthood relationships (On Atom level only);\nUnbond neighbouring Atom instances;\nRemove from Graph;\nRemove from State;\nSet new ascendents;\nUpdate the container.itemsbyname.\n\nIf keep_downstream_position is set to true (is, by default), the downstream Residue position is maintained (by calling request_c2i! and sync! methods). In either case, this method requests internal to cartesian coordinates conversion at the end (using the request_i2c! method).\n\nSee also\n\npop_residue!\n\nExamples\n\njulia> ProtoSyn.pop_atom!(pose, pose.graph[1][1][2])\nPose{Atom}(Atom{/H:6299}, State{Float64}:\n Size: 1\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.pop_residue!","page":"Pose","title":"ProtoSyn.pop_residue!","text":"pop_residue!(pose::Pose{Topology}, residue::Residue; [keep_downstream_position::Bool = false])\n\nPop and return the desired Residue residue from the given Pose pose. This is peformed by popping each Atom of the Residue residue individually. If keep_downstream_position is set to true (is, by default), the downstream Residue position is maintained (by calling request_c2i! and sync! methods). In either case, this method requests internal to cartesian coordinates conversion at the end (using the request_i2c! method).\n\nukw: Note:\nThe resulting Pose is re-indexed, therefore Residue N + 1 becomes Residue N. When removing multiple Residue instances, consider performing a reversed loop.\n\nSee also\n\npop_atom!\n\nExamples\n\njulia> r = ProtoSyn.pop_residue!(pose, pose.graph[1][5])\nPose{Residue}(Residue{/ALA:51397}, State{Float64}:\n Size: 10\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#Copying-and-merging","page":"Pose","title":"Copying and merging","text":"","category":"section"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"The following methods allow a user to save or replicate an existing Pose (for example, for simulations with multiple molecules).","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"Base.copy(::Pose)\nmerge\nmerge!\nsymexp\nsymexp!","category":"page"},{"location":"protosyn-api/core/methods/pose/#Base.copy-Tuple{Pose}","page":"Pose","title":"Base.copy","text":"copy(pose::Pose)\n\nReturn a copied Pose of the provided pose. The resulting Pose will have different :id fields for the Graph Topology and State.\n\nThis function is a Base module overload.\n\nExamples\n\njulia> copy(pose)\nPose{Topology}(Topology{/UNK:9547}, State{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.merge","page":"Pose","title":"ProtoSyn.merge","text":"merge(pose1::Pose, pose2::Pose)\n\nMerge the two given poses, creating a new Pose in the process.\n\nExamples\n\njulia> ProtoSyn.merge(pose, pose_mod)\nPose{Topology}(Topology{/merged:32083}, State{Float64}:\n Size: 686\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.merge!","page":"Pose","title":"ProtoSyn.merge!","text":"merge!(pose1::Pose, pose2::Pose)\n\nMerge the two given poses, updating/overwritting the given pose1.\n\nExamples\n\njulia> ProtoSyn.merge!(pose, pose_mod)\nPose{Topology}(Topology{/merged:10313}, State{Float64}:\n Size: 748\n i2c: false | c2i: true\n Energy: Dict(:Total => Inf)\n)\n...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.symexp","page":"Pose","title":"ProtoSyn.symexp","text":"symexp(pose::Pose, reps::Vector{Int}, unit_cell_dims::Vector{T}) where {T <: AbstractFloat}\n\nReturn a symmetry expanded Pose. Create N copies of the given pose in all 3 symmetry axis of a cubic lattice, where reps is the number of copies in each of the dimensions X, Y and Z (N is, therefore, reps[1]reps[2]reps[3]). Length of reps must be 3. unit_cell_dims sets the distance in each of dimension to translate the copies, in Angstrom Å. Length of unit_cell_dims must be 3. Copies the given pose, returning a new struct.\n\nSee also\n\nsymexp! merge\n\nExamples\n\njulia> ProtoSyn.symexp(pose, [2, 2, 2], [50.0, 50.0, 50.0])\nPose{Topology}(Topology{/UNK:59312}, State{Float64}:\n Size: 9261\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.symexp!","page":"Pose","title":"ProtoSyn.symexp!","text":"symexp!(pose::Pose, reps::Vector{Int}, unit_cell_dims::Vector{T}) where {T <: AbstractFloat}\n\nReturn a symmetry expanded Pose. Create N copies of the given pose in all 3 symmetry axis of a cubic lattice, where reps is the number of copies in each of the dimensions X, Y and Z (N is, therefore, reps[1]reps[2]reps[3]). Length of reps must be 3. unit_cell_dims sets the distance in each of dimension to translate the copies, in Angstrom Å. Length of unit_cell_dims must be 3. Copies the given pose, returning a new struct. Updates/overwrites the given pose.\n\nSee also\n\nsymexp merge\n\nExamples\n\njulia> ProtoSyn.symexp!(pose, [2, 2, 2], [50.0, 50.0, 50.0])\nPose{Topology}(Topology{/merged:10313}, State{Float64}:\n Size: 748\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn symexp)","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"Figure 1 | An example of the output of symexp with just one symmetry dimension. The second Pose is a copy of the original, translated in 1 dimension by the defined value.","category":"page"},{"location":"protosyn-api/core/methods/pose/#Aligning-poses","page":"Pose","title":"Aligning poses","text":"","category":"section"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"The following methods allow a user to juxtapose two Pose instances and measure the RMSD distance between them.","category":"page"},{"location":"protosyn-api/core/methods/pose/","page":"Pose","title":"Pose","text":"align!\ncenter_of_mass\nrmsd","category":"page"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.align!","page":"Pose","title":"ProtoSyn.align!","text":"align!(mobile::Pose, target::Pose)\nalign!(mobile::Pose, target::Pose, selection::ProtoSyn.AbstractSelection)\nalign!(mobile::Pose, target::Pose, mobile_selection::ProtoSyn.AbstractSelection, target_selection::ProtoSyn.AbstractSelection)\n\nApplication of the Kabsch algorithm. Applies a rotation + translation movement on the mobile Pose instance in order to align to the target Pose instance. If a selection is provided, only the subset of selected Atom instances (on both Pose structures) will be considered to calculate the necessary rotation + translation movement (minimizing the RMSD). If two AbstractSelection instances are provided (mobile_selection and target_selection), each is applied to the respective Pose instances (mobile and target, respectively) in order to calculate the necessary rotation + translation movement. Sets mobile.state.c2i to true and returns the altered mobile Pose instance.\n\nukw: Note:\nThis function can also align Fragment instances.\n\nSee also\n\nrmsd\n\nExamples\n\njulia> ProtoSyn.align!(pose, pose_mod)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.align!(pose, pose_mod, an\"CA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.align!(pose, pose_mod, an\"CA\", an\"CB\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.center_of_mass","page":"Pose","title":"ProtoSyn.center_of_mass","text":"center_of_mass(pose::Pose)\n\nReturn the center of mass X, Y and Z cartesian coordinates of the given Pose pose (based on the current cartesian coordinates - make sure the Pose pose is synched, using the sync! method).\n\ncenter_of_mass(pose::Pose, selection::AbstractSelection)\n\nReturn the center of mass X, Y and Z cartesian coordinates of the given Pose pose, taking into consideration only the subset of selected Atom instances in the AbstractSelection selection (based on the current cartesian coordinates - make sure the Pose pose is synched, using the sync! method).\n\ncenter_of_mass(pose::Pose, idxs::Vector{Int})\n\nReturn the center of mass X, Y and Z cartesian coordinates of the given Pose pose, taking into consideration only the subset of  Atom instances in the vector idxs (by Atom index, based on the current cartesian coordinates - make sure the Pose pose is synched, using the sync! method).\n\nExamples\n\njulia> ProtoSyn.center_of_mass(pose)\n3×1 Matrix{Float64}:\n 39.85855147920603\n 14.995282315671613\n -0.016516024315774907\n\njulia> ProtoSyn.center_of_mass(pose, an\"CA\")\n3×1 Matrix{Float64}:\n 37.56949530961898\n 14.249844760318357\n -5.4078476622375185e-16\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/methods/pose/#ProtoSyn.rmsd","page":"Pose","title":"ProtoSyn.rmsd","text":"rmsd(pose1::Pose, pose2::Pose)\nrmsd(pose1::Pose, pose2::Pose, selection::AbstractSelection)\n\nCalculates the RMSD value between 2 Pose instances, based on the cartesian coordinates. Note: Make sure the poses have been synched beforehand (using the sync! method). If an AbstractSelection selection is provided, calculate the RMSD values of only the selected subset of Atom instances. Returns RMSD result in Angstrom (Å). \n\nSee also\n\nalign! getdihedral\n\nExamples\n\njulia> ProtoSyn.rmsd(pose, pose_mod)\n34.443215682826676\n\njulia> ProtoSyn.rmsd(pose, pose_mod, an\"CA\")\n32.5063913965703\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"CurrentModule = ProtoSyn.Calculators","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#calculators-potential-restraints","page":"Potential Restraints","title":"Potential restraints","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Potential restraints are a family of EnergyFunctionComponent instances that apply any given potential to a selection of Atom instances, optionally further masked or mapped. In other words, the application of a potential restraint to a Pose is characterized by a series of fully customizable steps to generate new and/or improved Potential restraints:","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"(Optional) Select a subset of Atom instances to apply the potential;\nDefine the potential function to be applied (See Available potentials);\nApply the potential mask to the selected Atom instances;\n(Optional) Multiply a mask/map to the calculated energy and forces matrices;\nSum the calculated energy and forces matrices.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"ukw: Note:\nAs of ProtoSyn 1.0, no Core potential restraint is available, as most of these EnergyFunctionComponent instances are specific for a certain type of molecules (such as Peptides). The following types and methods constitute the backbone for all Potential restraints. Specific applications can be found in other modules of ProtoSyn.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"(Image: ProtoSyn Potential Restraint)","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Figure 1 | A diagram representation of the application of a potential restraint, in ProtoSyn. A given potential function (See Available potentials) is applied to a distance matrix (See Distance matrix calculation) calculated from the distances between all selected Atom instances. The resulting 2D energy matrix includes the energy values for each pair of interacting Atom instances. An optional secondary output from the application of the potential function is a 3D forces matrix, with the forces felt on each atom from the interaction with its pair. Both these matrices can optionally suffer another step: the application of a mask or map. On one hand, a Mask, similarly to its application in AbstractSelections, turns on and off certain pairs of interacting atoms. As an example, a mask allows the user to ignore same-atom energy artifacts using a diagonal_mask or ignore interaction between atoms of the same residue using an intra_residue_mask. On the other hand, a map in a 2D matrix (with the same size as the 2D energy matrix) with weights and biases. When the two matrices are multiplied together, certain interaction strengths are increased while others are reduced. An example would be the application of a contact map, where each weight corresponds to the certainty factor for the distance between each of the considered Atom pairs. As a final step both the 2D energy matrix and the 3D forces matrix (optionally after the application of the mask/map) are summed (in both axis, in the case of energy calculation, and in one axis, in the case of forces calculation).","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"ukw: Note:\nThe above paradigm for application of potential restraints requires, for the correct calculation of forces, the full_distance_matrix to be considered. This causes the energy value calculated to be double the expected (not considering the application on any non diagonally symmetrical mask), as both the top and bottom triagonal matrices are considered. In most cases this is not an issue, as the energy values are compared between simulation frames in relation to eachother and therefore the scale of the value is not important. However, in specific applications, further adjustment of the potential and/or mask applied may be necessary.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Calculators.apply_potential\nCalculators.Restraints.calc_flat_bottom_restraint","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.apply_potential","page":"Potential Restraints","title":"ProtoSyn.Calculators.apply_potential","text":"apply_potential([::Type{A}], coords::Vector{T}, potential::Function) where {A <: ProtoSyn.AbstractAccelerationType, <: AbstractFloat}\napply_potential([::Type{A}], coords::Vector{T}, potential::Function, mask::Union{ProtoSyn.Mask{C}, Matrix{T}}) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat, C <: ProtoSyn.AbstractContainer}\n\nApply the given potential to the provided coords, return the total energy of the system and matrix of forces felt on each atom (forces are always calculated). If a mask is provided, the resulting energy and force matrix are multiplied by this mask (See Available masks for a list of default masks is provided in ProtoSyn.Calculators module). The potential function should receive a distance::T and return an energy value e::T. If it receives an optional tuple v::Tuple{T, T, T}, it should also return the forces f1::Tuple{T, T, T} and f2::Tuple{T, T, T} felt on both ends of the vector, based on the given distance::T (See Available potentials for a list of default potential functions available in ProtoSyn.Calculators module and Creating custom potential functions for the correct function signatures of new potentials). An optional parameter Type{<: AbstractAccelerationType} can be provided, stating the acceleration type used to calculate this energetic contribution (See ProtoSyn acceleration types). Note that this function is usually called by giving a full Pose pose, using the function signatures bellow:\n\nSelection | Mask\n\napply_potential([::Type{A}], pose::Pose, potential::Function, mask::Union{ProtoSyn.Mask{C}, Matrix{T}}, selection::AbstractSelection) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat, C <: ProtoSyn.AbstractContainer}\napply_potential([::Type{A}], pose::Pose, potential::Function, mask::Function, selection::AbstractSelection) where {A <: ProtoSyn.AbstractAccelerationType}\n\nSelection | No Mask\n\napply_potential([::Type{A}], pose::Pose, potential::Function, mask::Nothing, selection::AbstractSelection) where {A <: ProtoSyn.AbstractAccelerationType}\napply_potential([::Type{A}], pose::Pose, potential::Function, selection::AbstractSelection) where {A <: ProtoSyn.AbstractAccelerationType}\n\nApply the given potential to the selected atoms of Pose pose via the provided selection, return the total energy of the system and matrix of forces felt on each atom. Optionally, multiply the results by a mask (See Available masks). If given (and not equal to nothing), the mask size must match the N selected atoms. Alternatively, the given mask can be a Function, in which case it receives a Pose pose as input (For the correct signature of this Function mask, see Creating custom masks).\n\nNo Selection | Mask\n\napply_potential([::Type{A}], pose::Pose, potential::Function, mask::Union{ProtoSyn.Mask{C}, Matrix{T}}) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat, C <: ProtoSyn.AbstractContainer}\napply_potential([::Type{A}], pose::Pose, potential::Function, mask::Function) where {A <: ProtoSyn.AbstractAccelerationType}\napply_potential([::Type{A}], pose::Pose, potential::Function, selection::Nothing, mask::Union{ProtoSyn.Mask{C}, Matrix{T}}) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat, C <: ProtoSyn.AbstractContainer}\napply_potential([::Type{A}], pose::Pose, potential::Function, selection::Nothing, mask::Function) where {A <: ProtoSyn.AbstractAccelerationType}\n\nNo Selection | No Mask\n\napply_potential([::Type{A}], pose::Pose, potential::Function, mask::Nothing) where {A <: ProtoSyn.AbstractAccelerationType}\napply_potential([::Type{A}], pose::Pose, potential::Function) where {A <: ProtoSyn.AbstractAccelerationType}\napply_potential([::Type{A}], pose::Pose, potential::Function, selection::Nothing, mask::Nothing) where {A <: ProtoSyn.AbstractAccelerationType}\napply_potential([::Type{A}], pose::Pose, potential::Function, selection::Nothing) where {A <: ProtoSyn.AbstractAccelerationType}\n\nApply the given potential to the all atoms of Pose pose, return the total energy of the system and matrix of forces felt on each Atom. If given (and not equal to nothing), the mask size must match the total number of Atom instances in the pose. Alternatively, the given mask can be aFunction, in which case it receives a Pose pose as input (For the correct signature of this Function mask, see Creating custom masks).\n\nukw: Note:\nAs of ProtoSyn 1.0, this function's acceleration type must be CUDA_2. Providing any other acceleration type will result in an error. This may be changed in future iterations.\n\nExamples\n\njulia> fbr = ProtoSyn.Calculators.get_flat_bottom_potential(d1 = 2.0, d2 = 5.0)\n ...\n\njulia> sidechain = !an\"^CA$|^N$|^C$|^H$|^O$\"r\nUnarySelection ❯ ! \"not\" (Atom)\n └── FieldSelection › Atom.name = r\"^CA$|^N$|^C$|^H$|^O$\"\n\njulia> mask = ProtoSyn.Calculators.intra_residue_mask(pose, sidechain)\n ...\n\njulia> e, f = ProtoSyn.Calculators.apply_potential(ProtoSyn.CUDA_2, pose, fbr, mask, sidechain)\n(2.1792609341377363, [11.380 … -74.232])\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint","page":"Potential Restraints","title":"ProtoSyn.Calculators.Restraints.calc_flat_bottom_restraint","text":"calc_flat_bottom_restraint([::Type{A}], pose::Pose, update_forces::Bool; d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf, selection::Opt{AbstractSelection} = nothing, mask::MaskMap = nothing) where {A <: ProtoSyn.AbstractAccelerationType, T <: AbstractFloat}\n\nApply a flat bottom potential to a given Pose pose. The potential is iteratively obtained each call using the get_flat_bottom_potential method (See Available potentials), by providing the given d1::T (default: 0.0), d2::T (default = 0.0), d3::T (default = Inf) and d4::T (default = Inf) settings as the flat bottom potential distances. This potential then applied to the Pose pose (via the apply_potential method), optionally on a subset of Atom instances given by the AbstractSelection selection and optionally multiplied by a mask. This mask can be a Mask, a Matrix{T} or a Function, in which case it should be a functor (return a Function) (For the correct signature of this Function mask, see Creating custom masks). These 3 options are named MaskMap for a simplicity of organization only. Return the total energy of the system and matrix of forces felt on each atom. Note that the calculation acceleration type can be set by providing an option parameter Type{<: ProtoSyn.AbstractAccelerationType}. If not provided, the default ProtoSyn.acceleration.active will be used instead.\n\nukw: Note:\nAs of ProtoSyn 1.0, the apply_potential acceleration type defaults to CUDA_2 regardless of the requested acceleration type. This may be changed in future iterations.\n\nExamples\n\n```jldoctest julia> ProtoSyn.Calculators.Restraints.calcflatbottom_restraint(pose, true) (0.0, [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0])\n\njulia> ProtoSyn.Calculators.Restraints.calcflatbottom_restraint(pose, false, d1 = 10.0, d2 = 12.0) (556449.1936070402, [-711.7603616347209 -630.2662235401388 … 995.0284325254745 1153.572133762037; -419.1275359380875 -548.0506257124055 … 286.5285847489888 92.16862928705675; 6.007398880372552 8.2409631821887 … -99.38257889245355 -92.37110004070036])    ```\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#Available-potentials","page":"Potential Restraints","title":"Available potentials","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"A list of available potentials in ProtoSyn is described bellow. See Creating custom potential functions for the required signature of new potential functions.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"get_flat_bottom_potential","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"ukw: Note:\nAs of ProtoSyn 1.0, only the get_flat_bottom_potential method is available. In future iterations new potentials (such as linear or quadratic potentials) will be added. ","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Calculators.get_flat_bottom_potential","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_flat_bottom_potential","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_flat_bottom_potential","text":"get_flat_bottom_potential(;d1::T = 0.0, d2::T = 0.0, d3::T = Inf, d4::T = Inf) where {T <: AbstractFloat}\n\nReturn a flat-bottom potential function, using the specified distances. The potential is made up of 5 different sectors, each with the following functions:\n\nf_1)  e = m_1 cdot d + b_1  left  d  d_1 right \n\nf_2)  e = left (d-d_2  right )^2  left  d_1 leqslant d  d_2 right \n\nf_3)  e = 0  left  d_2 leqslant d leqslant d_3 right \n\nf_4)  e = left (d-d_3  right )^2  left  d_4  d leqslant d_4 right \n\nf_5)  e = m_2 cdot d + b_2   left  d  d_4 right \n\nWhere \n\nm_1 = 2 left ( d_1-d_2 right ) \n\nb_1 = f_2left ( d_1 right ) - m_1 cdot d_1 \n\nm_2 = 2left ( d_4 - d_3 right ) \n\nb_2 = f_4left ( d_4 right ) - m_2 cdot d_4 \n\nThe resulting function can be called with the following signature:\n\nflat_bottom_potential(d::T; v::Opt{Vector{T}} = nothing) where {T <: AbstractFloat}\n\nReturn an energy value based on the provided distance d. If a vector v is also provided (optional), the flat-bottom restraint will also return the forces f1 and f2 (the forces felt on both ends of the vector v). The vector v should have length = 3, corresponding to the 3 dimensions of the distance between the two Atom instances (X, Y and Z). For more information on the flat-bottom potential, please read: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4692055/. \n\nSee also\n\napply_potential calc_flat_bottom_restraint\n\nExamples\n\njulia> f = ProtoSyn.Calculators.get_flat_bottom_potential(d1 = 1.0, d2 = 2.0, d3 = 3.0, d4 = 4.0);\n\njulia> f(2.5)\n0.0\n\njulia> f(1.73, v = (1.0, 1.0, 1.0))\n(0.0729, (0.54, 0.54, 0.54), (-0.54, -0.54, -0.54))\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"(Image: ProtoSyn Flat Bottom Potential)","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Figure 1 | The flat bottom potential is continuous but divided in 5 sectors. At the extremes, this is a linear potential, becoming quadratic as it nears the central sector, which is flat at y = 0.0 between d2 and d3, allowing some wiggle room to the metric being measured and evaluated. This potential can be unidirectional: flat at y = 0.0 from [0, d3] if d1 = d2 = 0.0 or from [d3, +∞[ if d3 = d4 = +∞.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#Creating-custom-potential-functions","page":"Potential Restraints","title":"Creating custom potential functions","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Besides the currently Available potentials, users can freely create custom and/or improved potential functions. In order to incorporate these potentials in EnergyFunctionComponent instances (and therefore in EnergyFunction instances), the following signature must be followed.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"energy, force1, force2 = new_potential(d::T; v::Opt{Vector{T}} = nothing) where {T <: AbstractFloat}","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Any function must, therefore, receive a distance value d::T between two Atom instances and return the corresponding energy felt. Optionally, it may receive a vector v::Vector{T}, which is the difference vector between the two Atom positions, in which case the potential should also return the two forces felt on each atom from this energetic interaction.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"The newly defined method can then be used in the apply_potential function: for each pair of Atom instances in the full_distance_matrix this potential will be evaluated. The apply_potential (with the new potential) can then be used in a new :calc field of any new EnergyFunctionComponent (with the correct signature, see Creating a custom EnergyFunctionComponent). However, as a general rule of good practice, an extra step is usually included: as exemplified by the get_flat_bottom_potential method, the potential here is actually a functor, returned everytime the get_flat_bottom_potential function is called. A set of settings act as the input of this function (the settings of the encompassing EnergyFunctionComponent), parametrizing the returned potential. Using this approach, the user has complete access to the EnergyFunctionComponent.settings field, which will dictate the parametrization of the newly developed potential. This can be useful, for example, in efforts to correctly parametrize an energetic contribution based on a set of data, as the used potential settings can be changed and optimized each step of the simulation, as a new potential is generated everytime. However, this generation does not negatively impact performance in any meaningfull way. ","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#Available-masks","page":"Potential Restraints","title":"Available masks","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"A list of available masks/maps in ProtoSyn is described bellow. See Creating custom masks for the required signature of new potential function masks/maps.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Calculators.intra_residue_mask\nCalculators.get_intra_residue_mask\nCalculators.diagonal_mask\nCalculators.get_diagonal_mask\nCalculators.load_map","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.intra_residue_mask","page":"Potential Restraints","title":"ProtoSyn.Calculators.intra_residue_mask","text":"intra_residue_mask(pose::Pose, selection::AbstractSelection)\n\nFor all the atoms in the provided AbstractSelection selection (N), return a 2D N x N Mask with all the atoms of the given Pose pose not in the same residue selected. \n\nukw: Note:\nThis function is rather heavy and has low performance. If no design effort is being made (where the sequence changes), the resulting Mask from this function can and should be re-used (only calculated once). If, for a specific application, the AbstractSelection selection remains constant but the Mask needs to be re-calculated (for example, because there was a design/mutation step, use the functor resulting from get_intra_residue_mask).\n\nSee also\n\ndiagonal_mask get_intra_residue_mask\n\nExamples\n\njulia> ProtoSyn.Calculators.intra_residue_mask(pose, !an\"^CA$|^N$|^C$|^H$|^O$\"r)\nProtoSyn.Mask{Atom}(Bool[1 1 … 0 0; 1 1 … 0 0; … ; 0 0 … 1 1; 0 0 … 1 1])\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_intra_residue_mask","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_intra_residue_mask","text":"get_intra_residue_mask(selection::AbstractSelection)\n\nProvides the intra_residue_mask function as a functor, which will calculate the intra residue mask for the given AbstractSelection selection. (Only the Atom instances in the selection are considered, all other atoms are not included in the Mask). Useful when creating a new EnergyFunctionComponent or when the Mask should be updated each step/call.\n\nSee also\n\nintra_residue_mask\n\nExamples\n\njulia> ProtoSyn.Calculators.get_intra_residue_mask(!an\"^CA$|^N$|^C$|^H$|^O$\"r)\n(::ProtoSyn.Calculators.var\"#_intra_residue_mask#5\"{UnarySelection{ProtoSyn.Stateless}}) (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.diagonal_mask","page":"Potential Restraints","title":"ProtoSyn.Calculators.diagonal_mask","text":"diagonal_mask(pose::Pose, selection::AbstractSelection)\n\nFor all the atoms in the provided AbstractSelection selection (N), return a 2D N x N Mask with all the Atom instances of the given Pose pose not in the natural diagonal selected (i.e. ignores same atom interaction artifacts).\n\nukw: Note:\nWhen the selection is constant but the resulting Mask needs to be re-calculated every call/step (for example, due to a design or mutation step), consider using the functor from get_diagonal_mask.\n\nSee also\n\nintra_residue_mask get_diagonal_mask\n\nExamples\n\njulia> ProtoSyn.Calculators.diagonal_mask(pose, an\"CA\")\nProtoSyn.Mask{Atom}(3, 3)\n3×3 BitArray{2}:\n 0  1  1\n 1  0  1\n 1  1  0\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.get_diagonal_mask","page":"Potential Restraints","title":"ProtoSyn.Calculators.get_diagonal_mask","text":"get_diagonal_mask(selection::AbstractSelection)\n\nProvides the diagonal_mask as a functor, which will calculate the diagonal mask for the given AbstractSelection selection. Useful when creating a new EnergyFunctionComponent or when the Mask should be updated each step/call.\n\nSee also\n\ndiagonal_mask\n\nExamples\n\njulia> ProtoSyn.Calculators.get_diagonal_mask(an\"CA\")\n(::ProtoSyn.Calculators.var\"#_diagonal_mask#6\"{FieldSelection{ProtoSyn.Stateless,Atom}}) (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/#ProtoSyn.Calculators.load_map","page":"Potential Restraints","title":"ProtoSyn.Calculators.load_map","text":"load_map([::Type{T}], filename::String) where {T <: AbstractFloat}\n\nLoad the map in the filename file (i.e. Contact Map). The file should be in PFRMAT RR format (See: https://predictioncenter.org/casp13/index.cgi?page=format#RR). Returns an N x N map of the found weights, with pairs not identified in the file set to 0.0 (N is the maximum indentifier found on the file. As an example, it might be the case where a peptide has 74 residues, but no pair with residue 74 is found on the file, the maximum identifier found might be 72, for example. In this case, the resulting map will have size 72 x 72. In order to ensure the loaded map size matches the underlying peptide size, consider adding an entry of 0.0 on the map file, with the correct maximum identifier). Note: If no optional type T is provided, will use ProtoSyn.Units.defaultFloat.\n\nExamples\n\njulia> cmap = ProtoSyn.Calculators.load_map(\"contact_map_example.txt\")\n73×73 Array{Float64,2}:\n ...\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"(Image: ProtoSyn Available Masks)","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Figure 2 | Some of the available Mask instances in ProtoSyn. An intra_residue_mask de-selects all atoms that belong to the same Residue instance (only accounting for inter-Residue interactions). A diagonal_mask simply de-selects the same Atom instance in a 2D full_distance_matrix. Finally, a contact map is a loaded map (using the load_map method) that asserts a 2D Matrix of weights or biases to be multiplied by the resulting energy and forces matrices in apply_potential. As an example, this can be the likelihood of two Atom instances having a distance shorter can D Angstrom (Å).","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/#Creating-custom-masks","page":"Potential Restraints","title":"Creating custom masks","text":"","category":"section"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"In addition to the Available masks, users may wish to create and add custom Mask instances to employ in the apply_potential method. This method can receive a 2D Mask instance directly, as well as a Matrix{T} or a Function instance. Each case is discussed bellow:","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"2D Mask : A static mask, calculated only once. Energy and forces contributions will only be considered for the selected Atom instances (make sure the size of the Mask matches the number of selected Atom instances in the apply_potential call). As an example, see intra_residue_mask. The syntax to create a new ProtoSyn Mask is as follows. For more details, see the Masks section.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"2d_mask = Mask{Atom}(BitArray(falses(4, 4)))","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"MatrixT : A static map, calculated only once. Energy and forces contibutions will be multiplied by the Matrix{T} (make sure that the Matrix{T} size matches the number of selected Atom instances in the apply_potential call). As an example, see load_map. The syntax to create a new Matrix{T} is as follows (as an example of a random map).","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"2d_map = rand(4, 4)","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Function : A dynamic mask or map, calculated every step/call of apply_potential. This function should have the following simple signature, receiving a Pose pose as input and returning either a Mask or a Matrix{T}.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"mask_or_map(pose::Pose)","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"Altough potentially sacrificing the performance of the code, this allows for new Mask or a Matrix{T} instances to be calculated every step of a simulation, reflecting new changes, such as mutations or design efforts, for example.","category":"page"},{"location":"protosyn-api/core/calculators/potential-restraints/","page":"Potential Restraints","title":"Potential Restraints","text":"ukw: Note:\nA common practice in building new Function instances that return Mask or a Matrix{T} instances for application in the apply_potential method is to encompass this Function as a functor of another Function. As an example, see the get_intra_residue_mask method. In this cases, the encompassing Function receives the AbstractSelection selection, making sure that the returned Function selects Atom instances only within this selection.","category":"page"},{"location":"protosyn-api/peptides/methods/state/","page":"State","title":"State","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/methods/state/#peptides-state-methods","page":"State","title":"State","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/state/","page":"State","title":"State","text":"This section lists functions that work on the system State, as expansions to the Core methods (See State). These methods are subdivided by topics, for organization purposes:","category":"page"},{"location":"protosyn-api/peptides/methods/state/","page":"State","title":"State","text":"Applying a Secondary Structure","category":"page"},{"location":"protosyn-api/peptides/methods/state/#Applying-a-Secondary-Structure","page":"State","title":"Applying a Secondary Structure","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/state/","page":"State","title":"State","text":"Making use of the Secondary Structure types (in specific, the SecondaryStructureTemplate instance), the setss! method allows a user to quickly apply a given Secondary Structure to a Pose or a subset of selected Residue instances.","category":"page"},{"location":"protosyn-api/peptides/methods/state/","page":"State","title":"State","text":"setss!","category":"page"},{"location":"protosyn-api/peptides/methods/state/#ProtoSyn.Peptides.setss!","page":"State","title":"ProtoSyn.Peptides.setss!","text":"setss!(state::State, ss::SecondaryStructureTemplate, residues::Vector{Residue})\n\nSet the phi ϕ, psi ψ and omega ω backbone angles of all Residue instances in the given residues vector to match the provided SecondaryStructureTemplate. This function acts on the internal coordinates and does not update cartesian coordinates (using the sync! method), although a request for conversion is made (by calling the request_i2c!).\n\nsetss!(pose::Pose, ss::SecondaryStructureTemplate)\nsetss!(pose::Pose, ss::SecondaryStructureTemplate, sele::ProtoSyn.AbstractSelection)\nsetss!(pose::Pose, ss::SecondaryStructureTemplate, residue::Residue)\n\nSet the phi ϕ, psi ψ and omega ω backbone angles of all Residue instances in the given Pose pose to match the provided SecondaryStructureTemplate. If an optional AbstractSelection sele is provided, apply the transformation only to the selected Residue instances.\n\nSee also\n\nSecondaryStructure\n\nExamples\n\njulia> ProtoSyn.Peptides.setss!(pose, ProtoSyn.Peptides.SecondaryStructure[:helix])\nState{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#peptides-pose-methods","page":"Pose","title":"Pose","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Included in the Peptides are a set of methods who primarily act on a Pose instance, expanding on the list of availabe Core functions (See Pose methods). These are subdivided by topics, for organization purposes:","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Appending and inserting fragments\nMutating an aminoacid\nRemoving and adding sidechains\nRemoving and adding N- and C- terminal caps","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#Appending-and-inserting-fragments","page":"Pose","title":"Appending and inserting fragments","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Expanding on the homologous Core functions, the next methods allow the user to append and insert Fragment instances in Pose instances (from Fragment instances or from a derivation (for example, seq\"AAA\", a triplet of alanine aminoacids)). These expanded methods all add the possibility to set the Secondary Structure of the appendage (using the setss! method) and correct certain bond orientation artifacts introduced by the Core functions, specific to peptidic structures.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"append_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Pose{Segment}; ::Opt{SecondaryStructureTemplate}, ::Any)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.append_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Fragment}","page":"Pose","title":"ProtoSyn.Peptides.append_fragment!","text":"append_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, frag::Pose{Segment}; [ss::Opt{SecondaryStructureTemplate} = nothing], [op = \"α\"])\n\nAdd the Fragment frag to the given Pose pose, appending it after the given Residue residue. This residue and the new Fragment frag will be connected using operation op (\"α\" by default) of the given LGrammar grammar. If given, a SecondaryStructureTemplate ss can be applied to the new appendage (using the setss! method). In either case, the C=O bond position is re-calculated and set (in the first residue of the appendage). Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nukw: Note:\nThis function is an extension of ProtoSyn.append_fragment!.\n\nSee also\n\ninsert_fragment!\n\nExamples\n\njulia> ProtoSyn.Peptides.append_fragment!(pose, pose.graph[1][end], res_lib, frag)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn Peptides Append)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Figure 1 | Two example applications of the append_fragment! method. 1 - Appending a new Fragment (which can be one or more aminoacids) to the end of a peptidic structure (the Fragment is displayed in dark grey). The Residue instances are re-indexed (using the reindex! method) and inserted in the Pose graph (sharing the root). 2 - A Fragment can also be appended to a severed cut (using the unbond! method or the fragment! method, for example). In this case, naturally, the downstream Residue instances are connected to the Pose root. Note that the appended aminoacids are ordered in such a way as to continue numerate (on index) from the Residue instance appended to.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"insert_fragment!(::Pose{Topology}, ::Residue, ::LGrammar, ::Pose{Segment}; ::Opt{SecondaryStructureTemplate}, ::Any)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.insert_fragment!-Tuple{Pose{Topology}, Residue, LGrammar, Fragment}","page":"Pose","title":"ProtoSyn.Peptides.insert_fragment!","text":"insert_fragment!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, frag::Pose{Segment}; ss::Opt{SecondaryStructureTemplate} = nothing, op = \"α\")\n\nInsert the Fragment frag in the given pose, on the position of the provided Residue instance residue (the residue gets shifted downstream). This first downstream Residue and the new Fragment will be connected using operation op (\"α\" by default) from [LGrammar] grammar. Also connects to the upstream Residue instance, using the same operation. If given, a SecondaryStructureTemplate ss can be applied to the new appendage (using the setss! method). If the appendage is not being inserted at the root, the C=O bond position is re-calculated and set (in the anchor for the first residue of the appendage). If the appendage is being inserted at the root, perform a soft uncap of the terminal hydrogen atoms (removes \"H2\" and \"H3\", leaves \"H1\", renames it to \"H\") and recalculate the N-H bond position (at the first downstream Residue). Request internal to cartesian coordinate conversion and return the altered Pose pose.\n\nukw: Note:\nThis function is an extension of ProtoSyn.insert_fragment!.\n\nSee also\n\nappend_fragment!\n\nExamples\n\njulia> ProtoSyn.Peptides.insert_fragment!(pose, pose.graph[1][1], res_lib, frag)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 373\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn Peptides Insert)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Figure 2 | Two example applications of the insert_fragment! method. 1 - Inserting a new Fragment (which can be one or more aminoacids) to the middle of a peptidic structure (the Fragment is displayed in dark grey). The Residue instances are re-indexed (using the reindex! method) and inserted in the Pose graph (sharing the root), while being connected in both upstream and downstream ends. 2 - A Fragment can also be inserted at position 1 of the peptidic chain (in the beginning).","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#Mutating-an-aminoacid","page":"Pose","title":"Mutating an aminoacid","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"In a design effort, the objetive is to change the nature of an aminoacid (i.e.: change its sidechain), in order to stabilize a given interaction or conformation. Naturally, the main component necessary in such an algorithm is the ability to mutate an aminoacid, as explored in the next section.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"mutate!\nforce_mutate!","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.mutate!","page":"Pose","title":"ProtoSyn.Peptides.mutate!","text":"mutate!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation)\n\nMutate the given Pose pose at Residue residue, changing it's aminoacid to be derivation, as given by the template at grammar. This function changes the sidechain only (± 7x faster than force_mutate!). When mutating to Proline, falls back to force_mutate!. If ignore_existing_sidechain is set to true (false by default), existing sidechains are first removed and then re-added, regardless of being of the same type (which normally are ignored, if no mutation is required).\n\nukw: Note:\nSidechains are selected based on the Atom.name (backbone Atom instances must be named N, H, CA, C and O, exclusively. Non backbone Atom instances should have other names, such as H1, H2, etc.)\n\nSee also\n\nforce_mutate!\n\nExamples\n\njulia> ProtoSyn.Peptides.mutate!(pose, pose.graph[1][3], res_lib, seq\"K\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 354\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.force_mutate!","page":"Pose","title":"ProtoSyn.Peptides.force_mutate!","text":"force_mutate!(pose::Pose{Topology}, residue::Residue, grammar::LGrammar, derivation, op = \"α\")\n\nMutate the given Pose pose at Residue residue, changing it's aminoacid to be derivation, as given by the template at grammar. This function changes the whole residue (backbone included). By default, the user should use mutate! instead of this function, except for uncommon aminoacids.\n\nSee also mutate!\n\nExamples\n\njulia> ProtoSyn.Peptides.force_mutate!(pose, pose.graph[1][3], res_lib, seq\"K\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 354\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn Mutate)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Figure 3 | Example of an aminoacid mutation cycle.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#Removing-and-adding-sidechains","page":"Pose","title":"Removing and adding sidechains","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Certain coarse-grain EnergyFunctionComponent instances might not require an explicit sidechain. In certain algorithms, it might be, therefore, useful to remove the sidechains, lowering the degrees of freedom of a system and reducing the amount of particles simulated. In the next section, the methods used in ProtoSyn to remove and add sidechains in peptidic systems are explored.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"remove_sidechains!\nforce_remove_sidechains!\nadd_sidechains!","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.remove_sidechains!","page":"Pose","title":"ProtoSyn.Peptides.remove_sidechains!","text":"remove_sidechains!(pose::Pose{Topology}, res_lib::selection::LGrammar, Opt{AbstractSelection} = nothing)\n\nRemoves the sidechain atoms of the given Pose pose. If an AbstractSelection selection is provided, only the sidechain atoms belonging to the Residue instances of that selection are considered for possible removal. Essentially, the selected Residue instances are mutated to Glycine, based on the provided residue library res_lib, without changing the peptide sequence. Therefore, the original sequence can be recovered using the add_sidechains! method and energy components such as calc_solvation_energy can perform correctly.\n\nukw: Note:\nProline residues are ignored.\n\nukw: Note:\nCaping Atom instances (N-terminal -NH3 and C-terminal -CO2) are also removed by this function. See cap! to recover from this.\n\nSee also\n\nforce_remove_sidechains!\n\nExamples\n\njulia> ProtoSyn.Peptides.remove_sidechains!(pose, res_lib)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 147\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.Peptides.remove_sidechains!(pose, res_lib, rn\"ALA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 147\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.force_remove_sidechains!","page":"Pose","title":"ProtoSyn.Peptides.force_remove_sidechains!","text":"force_remove_sidechains!(pose::Pose{Topology}, selection::Opt{AbstractSelection} = nothing)\n\nRemoves the sidechain Atom instances of the given Pose pose. If an AbstractSelection selection is provided, only the sidechain Atom instances belonging to that selection are considered for possible removal. This function completly removes any atom other than backbone atoms (may break Cα coordination, consider using the remove_sidechains! method instead).\n\nukw: Note:\nProline residues are ignored.\n\nukw: Note:\nCaping Atom instances (N-terminal -NH3 and C-terminal -CO2) are also removed by this function. See cap! to recover from this.\n\nSee also\n\nremove_sidechains!\n\nExamples\n\njulia> ProtoSyn.Peptides.force_remove_sidechains!(pose)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 105\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.Peptides.force_remove_sidechains!(pose, rn\"ALA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 105\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.add_sidechains!","page":"Pose","title":"ProtoSyn.Peptides.add_sidechains!","text":"add_sidechains!(pose::Pose{Topology}, grammar::LGrammar, selection::Opt{AbstractSelection} = nothing)\n\nAdd the sidechain Atom instances to the given Pose pose, based on the templates of the provided grammar. If an AbstractSelection selection is given, only the residues of that selection (promoted to Residue instances, using the default aggregator function) are considered for sidechain addition. The addition is performed using the mutate! function, and follows the current Pose sequence.\n\nExamples\n\njulia> ProtoSyn.Peptides.add_sidechains!(pose, res_lib)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\njulia> ProtoSyn.Peptides.add_sidechains!(pose, res_lib, rn\"ALA\")\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 343\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn Remove Sidechains)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Figure 4 | Example of application of the remove_sidechains! and [add_sidechains!] methods. Note that, when re-adding the sidechains, the Rotamer conformation is set to be a default position, not recovering the initial conformation without further processing.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#Removing-and-adding-N-and-C-terminal-caps","page":"Pose","title":"Removing and adding N- and C- terminal caps","text":"","category":"section"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"When extending a peptide (by appending new Residue instances, for example), it might be useful to remove the N- and C-terminal caps, as well as add them back at a later point in the algorithm or design process. In this section, two methods for this task are explored.","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"is_N_terminal\nis_C_terminal\nuncap!\ncap!","category":"page"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.is_N_terminal","page":"Pose","title":"ProtoSyn.Peptides.is_N_terminal","text":"is_N_terminal(res::Residue)\n\nReturn true if the provided Residue residue is a child of the residue's container root.\n\nExamples\n\njulia> ProtoSyn.Peptides.is_N_terminal(pose.graph[1][1])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.is_C_terminal","page":"Pose","title":"ProtoSyn.Peptides.is_C_terminal","text":"is_C_terminal(res::Residue)\n\nReturn true if the provided Residue residue has no children.\n\nExamples\n\njulia> ProtoSyn.Peptides.is_C_terminal(pose.graph[1][end])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.uncap!","page":"Pose","title":"ProtoSyn.Peptides.uncap!","text":"uncap!(pose::Pose, selection::Opt{AbstractSelection} = nothing)\n\nRemove all bonded Atom instances to the N- and C-terminal (except Cα) of the provided Pose pose. If an AbstractSelections selection is provided, search for terminal residues only in the given selection. A terminal is identified based on the following criteria (see is_N_terminal and is_C_terminal methods):\n\nIs a child of the Pose pose root;\nHas no children;\n\nReturn the modified (in-place) Pose pose. Does not sync!.\n\nExamples\n\njulia> ProtoSyn.Peptides.uncap!(pose)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 341\n i2c: true | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/#ProtoSyn.Peptides.cap!","page":"Pose","title":"ProtoSyn.Peptides.cap!","text":"cap!(pose::Pose, selection::Opt{AbstractSelection} = nothing)\n\nAdd template terminals to the N- and C- terminals of the given Pose pose. If an AbstractSelection selection is provided, search for terminal residues only in the given selection. A terminal is identified based on the following criteria (see is_N_terminal and is_C_terminal methods):\n\nIs a child of the Pose pose root;\nHas no children;\n\nReturn the modified (in-place) Pose pose. Performs sync! operation.\n\nExamples\n\njulia> ProtoSyn.Peptides.cap!(pose)\nPose{Topology}(Topology{/UNK:1}, State{Float64}:\n Size: 346\n i2c: false | c2i: false\n Energy: Dict(:Total => Inf)\n)\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"(Image: ProtoSyn Remove Caps)","category":"page"},{"location":"protosyn-api/peptides/methods/pose/","page":"Pose","title":"Pose","text":"Figure 5 | Example of application of the uncap! and [cap!] methods. Uncapping a terminal end of a peptide is usefull when appending new Residue instances, extending or adding an appendage.","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"CurrentModule = ProtoSyn.Peptides","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#Rotamers","page":"Rotamers","title":"Rotamers","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"The Rotamers is a submodule of ProtoSyn.Peptides module. As such, the following section introduces both new types and methods that work together, in a generally independent way from the rest of the module, and require an unique exploratory section on their own.","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"A Rotamer is a collection of chi angles for a specific conformation for the sidechain of an aminoacid. Although virtually all dihedral angles are allowed, for each chi dihedral, certain conformations are energetically more favourable and therefore have a higher natural probability of observation. The allowed Rotamers can be further dependent on certain backbone dihedral angles (for the phi and psi dihedrals). All this information can be gathered in a Rotamer Library, a useful tool when trying to answer the question: \"What set of sidechain conformations stabilize the protein structure?\", sometimes also referred to as the sidechain packaging problem. Multiple such rotamer libraries have been proposed. ProtoSyn makes available a set of types and methods that allow the manipulation and application of rotamer libraries, while using, as a default, the 2011 Dunbrack library. This is further explored in the following section, sub-divided as follows for organizational purposes:","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"Organizing a Rotamer Library\nApplying a Rotamer Library\nLoading a Rotamer Library","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#Organizing-a-Rotamer-Library","page":"Rotamers","title":"Organizing a Rotamer Library","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"Rotamer\nRotamerStack\nBBD_RotamerLibrary","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.Rotamer","page":"Rotamers","title":"ProtoSyn.Peptides.Rotamer","text":"Rotamer{T <: AbstractFloat}(name::String, chis::Dict{DihedralType, Tuple{T, T}})\n\nA Rotamer holds information regarding a single conformation for all chi dihedral angles of a sidechain belonging to an aminoacid identified by the  given name. The chis list is, therefore, a dictionary, where the key is the DihedralType (chi1, chi2, chi3 or chi4) and the value is a Tuple{T, T}, where the first entry is the average dihedral angle and the second entry is the standard deviation expected for that dihedral angle.\n\nSee also\n\nget_rotamer apply!\n\nExamples\n\njulia> rot_lib[\"LYS\"][35°, -35°][1]\nRotamer{Float64}: LYS | Chi1:   -67.5° ±  6.9 | Chi2:  -179.6° ±  9.7 | Chi3:  -179.7° ± 11.8 | Chi4:   178.5° ± 12.0\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.RotamerStack","page":"Rotamers","title":"ProtoSyn.Peptides.RotamerStack","text":"RotamerStack{T <: AbstractFloat}(rotamers::Vector{Rotamer{T}}, weights::Weights{T, T, Array{T, 1}})\n\nA RotamerStack is a smart list of Rotamer instances, ordered based on the natural probability of occurrence, where each position in the rotamers list has a corresponding position in the weights list.\n\nSee also\n\nsample\n\nExamples\n\njulia> rot_lib[\"VAL\"][35°, -35°]\n\n+---------------------------------------------------------------------------------------------------------------------------+\n| Index | Probability | Rotamer description                                                                                 |\n+---------------------------------------------------------------------------------------------------------------------------+\n| 1     |      82.07% | VAL | Chi1:   175.8° ±  5.6 | Chi2: --              | Chi3: --              | Chi4: --              |\n| 2     |      13.74% | VAL | Chi1:    64.7° ±  7.5 | Chi2: --              | Chi3: --              | Chi4: --              |\n| 3     |       4.18% | VAL | Chi1:   -61.6° ±  6.4 | Chi2: --              | Chi3: --              | Chi4: --              |\n+---------------------------------------------------------------------------------------------------------------------------+\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.BBD_RotamerLibrary","page":"Rotamers","title":"ProtoSyn.Peptides.BBD_RotamerLibrary","text":"BBD_RotamerLibrary{T <: AbstractFloat}(name::String, phis::Vector{T}, psis::Vector{T}, rotamer_stacks::Matrix{RotamerStack}) where {T <: AbstractFloat}\n\nA BBD_RotamerLibrary is a 2D backbone dependent matrix of RotamerStack instances (rotamer_stacks), indexed by both the list of backbone phi dihedrals (phis) and the list of backbone psi dihedrals (psis). Each BBD_RotamerLibrary only hold information regarding one type of aminoacid, identified by the name. Each entry in the rotamer_stacks matrix only holds information of the list of rotamers available/plausible for a specific set of phi and psi backbone dihedrals.\n\nSee also\n\nload_dunbrack\n\nExamples\n\njulia> rot_lib[\"VAL\"]\nName: VAL | Shape: (37, 37)\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"(Image: ProtoSyn Rotamer Library)","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"Figure 1 | A diagram representation of a ProtoSyn Rotamer Library organization. For each entry in a dictionary (where the keys are the aminoacid names with a rotatable sidechain), a BBD_RotamerLibrary can be queried for with the backbone phi and psi dihedral angles, retrieving the backbone dependent RotamerStack. This object organizes all the plausible Rotamer conformations, based on the probability of natural occurrence, from where a specific Rotamer can be sampled. Finally, a Rotamer is simply a list of chi dihedral angles (and the corresponding standard deviation), and can be applied to a Pose (using the apply! method).","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#Applying-a-Rotamer-Library","page":"Rotamers","title":"Applying a Rotamer Library","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"apply!\nsample\nget_rotamer","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.apply!","page":"Rotamers","title":"ProtoSyn.Peptides.apply!","text":"apply!(state::State, rotamer::Rotamer, residue::Residue)\n\nApply the given Rotamer rotamer to the sidechain of Residue residue, on the provided State state. Return the applied Rotamer rotamer, without applying the sync! method to the State state.\n\nExamples\n\njulia> ProtoSyn.Peptides.apply!(pose.state, rot_lib[\"GLU\"][35°, -35°][1], pose.graph[1][2])\nRotamer{Float64}: GLU | Chi1:   -55.6° ±  0.0 | Chi2:   187.7° ±  0.0 | Chi3:    -2.6° ±  0.0 | Chi4: --   \n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.sample","page":"Rotamers","title":"ProtoSyn.Peptides.sample","text":"sample(rs::RotamerStack{T}, [n::Int = -1]) where {T <: AbstractFloat}\n\nSample a Rotamer instance from the given RotamerStack rs, taking the natural probability of occurrence into consideraction. If a n value is given, sample only from the n most likely Rotamer instances. If n is 0 or lower (-1, by default), sample from all Rotamer instances. Return the sampled Rotamer instance.\n\nExamples\n\njulia> ProtoSyn.Peptides.sample(rot_lib[\"GLU\"][35°, -35°])\nRotamer{Float64}: GLU | Chi1:   -66.8° ±  8.2 | Chi2:   179.1° ± 11.8 | Chi3:   -35.0° ±  8.5 | Chi4: --         \n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.get_rotamer","page":"Rotamers","title":"ProtoSyn.Peptides.get_rotamer","text":"get_rotamer(pose::Pose, residue::Residue)\n\nMeasure the existent chi dihedral angles in Residue residue on the given Pose pose, saving the information in a new Rotamer instance.\n\nExamples\n\njulia> ProtoSyn.Peptides.get_rotamer(pose, pose.graph[1][2])\nRotamer{Float64}: GLU | Chi1:   180.0° ±  0.0 | Chi2:  -180.0° ±  0.0 | Chi3:    90.0° ±  0.0 | Chi4: --     \n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/peptides/submodules/rotamers/#Loading-a-Rotamer-Library","page":"Rotamers","title":"Loading a Rotamer Library","text":"","category":"section"},{"location":"protosyn-api/peptides/submodules/rotamers/","page":"Rotamers","title":"Rotamers","text":"load_dunbrack","category":"page"},{"location":"protosyn-api/peptides/submodules/rotamers/#ProtoSyn.Peptides.load_dunbrack","page":"Rotamers","title":"ProtoSyn.Peptides.load_dunbrack","text":"load_dunbrack([::Type{T}], [filename::String]) where {T <: AbstractFloat}\n\nLoad a Dunbrack styled rotamer library from file filename (if no filename is given, will load the default rotamer library from the resources directory). If no type T is provided, will use ProtoSyn.Units.defaultFloat. Return a dictionary where each key is the name of an aminoacid type and the value is the corresponding loaded BBD_RotamerLibrary instance. Note that not all aminoacid types have sidechains, and therefore, have an associated  BBD_RotamerLibrary instance.\n\nExamples\n\njulia> rot_lib = ProtoSyn.Peptides.load_dunbrack(Float64)\nDict{String, ProtoSyn.Peptides.BBD_RotamerLibrary} with 19 entries:\n  \"GLN\" => Name: GLN | Shape: (37, 37)…\n  \"LYS\" => Name: LYS | Shape: (37, 37)…\n  \"ASN\" => Name: ASN | Shape: (37, 37)…\n  \"TRP\" => Name: TRP | Shape: (37, 37)…\n  \"THR\" => Name: THR | Shape: (37, 37)…\n  \"VAL\" => Name: VAL | Shape: (37, 37)…\n  \"HIS\" => Name: HIS | Shape: (37, 37)…\n  \"SER\" => Name: SER | Shape: (37, 37)…\n  \"PRO\" => Name: PRO | Shape: (37, 37)…\n  \"ASP\" => Name: ASP | Shape: (37, 37)…\n  \"PHE\" => Name: PHE | Shape: (37, 37)…\n  \"ILE\" => Name: ILE | Shape: (37, 37)…\n  \"TYR\" => Name: TYR | Shape: (37, 37)…\n  \"HIE\" => Name: HIS | Shape: (37, 37)…\n  \"ARG\" => Name: ARG | Shape: (37, 37)…\n  \"LEU\" => Name: LEU | Shape: (37, 37)…\n  \"MET\" => Name: MET | Shape: (37, 37)…\n  ⋮     => ⋮\n\n\n\n\n\n\n","category":"function"},{"location":"protosyn-api/core/mutators/mutators-compound/","page":"Compound Mutators","title":"Compound Mutators","text":"CurrentModule = ProtoSyn.Mutators","category":"page"},{"location":"protosyn-api/core/mutators/mutators-compound/#Compound-Mutator","page":"Compound Mutators","title":"Compound Mutator","text":"","category":"section"},{"location":"protosyn-api/core/mutators/mutators-compound/","page":"Compound Mutators","title":"Compound Mutators","text":"The Compound Mutator is an aggregating type of AbstractMutator. The sole function of this mutator is to apply multiple inner AbstractMutator instances in sequence. Optionally, if a selection is provided, all inner AbstractMutator instance's selection is merged with this common selection.","category":"page"},{"location":"protosyn-api/core/mutators/mutators-compound/","page":"Compound Mutators","title":"Compound Mutators","text":"CompoundMutator","category":"page"},{"location":"protosyn-api/core/mutators/mutators-compound/#ProtoSyn.Mutators.CompoundMutator","page":"Compound Mutators","title":"ProtoSyn.Mutators.CompoundMutator","text":"CompoundMutator(mutators::Vector{AbstractMutator}, selection::Union{AbstractSelection, Nothing})\n\nReturn a CompoundMutator instance. This AbstractMutator is a functor, called with the following signature:\n\n(compound_mutator::CompoundMutator)(pose::Pose)\n\nA CompoundMutator loops over a list of one or more AbstractMutator instances, applying them in the provided sequence to a Pose instance. If an AbstractSelection selection is provided, the same selection will be used when applying each AbstractMutator, merged with any possible inner selection specific for each mutator (using the & \"and\" operator). For example, a DihedralMutator may have an an\"CA\" selection attached. When called from a CompoundMutator with a rid\"1:10\" selection attached, only the CA Atom instances from the region between Residue 1 to Residue 10 will be considered for application of the DihedralMutator. Note that, when applying each mutator, any required sync! call and request for internal to cartesian coordinate conversion (or vice-versa) are handled by each AbstractMutator independently.\n\nThe CompoundMutator AbstractMutator can also be optionally called using the following signature, in which case only the provided list of Atom instances will be considered for the application of this AbstractMutator (i.e.: CompoundMutator of a CompoundMutator).\n\n(compound_mutator::CompoundMutator)(pose::Pose, atoms::Vector{Atom})\n\nukw: Note:\nThis AbstractMutator requires that the mutators provided in the list have a (compound_mutator::CompoundMutator)(pose::Pose, atoms::Vector{Atom}) signature. Check each AbstractMutator documentation entry and Creating custom mutators section for details. \n\nFields\n\nmutators::Vector{AbstractMutator} - The list of AbstractMutator instances this mutator will loop over and apply sequentially;\nselection::Union{AbstractSelection, Nothing} - If provided, all inner AbstractMutator instances will be applied to each individual selection (if present) merged with this common selection.\n\nSee also\n\nCompoundDriver\n\nExamples\n\njulia> m = ProtoSyn.Mutators.CompoundMutator([rrbm, trbm], an\"CBZ\")\n⚯  Compound Mutator:\n ├──  ● Inner Mutators (2 elements):\n |    ├── ⚯  Rotation Rigid Body Mutator:\n |    |   +----------------------------------------------------------------------+\n |    |   | Index | Field                       | Value                          |\n |    |   +----------------------------------------------------------------------+\n |    |   | 1     | axis_sampler                | Function rand_vector_in_sphere |\n |    |   | 2     | angle_sampler               | Function randn                 |\n |    |   | 3     | pivot_sampler               | Function center_of_mass        |\n |    |   | 4     | step_size                   | 0.4000                         |\n |    |   +----------------------------------------------------------------------+\n |    |    ● Selection: Set\n |    |    └── BinarySelection ❯  & \"and\" (Atom)\n |    |         ├── FieldSelection › Atom.name = CA\n |    |         └── FieldSelection › Atom.name = CB\n |    |   \n |    └── ⚯  Translation Rigid Body Mutator:\n |        +----------------------------------------------------------------------+\n |        | Index | Field                       | Value                          |\n |        +----------------------------------------------------------------------+\n |        | 1     | translation_vector_sampler  | Function rand_vector_in_sphere |\n |        | 2     | step_size                   | 1.0000                         |\n |        +----------------------------------------------------------------------+\n |         ○  Selection: Not Set\n |   \n └──  ● Selection: Set\n      └── FieldSelection › Atom.name = CBZ\n\n\n\n\n\n","category":"type"},{"location":"protosyn-api/core/mutators/mutators-compound/","page":"Compound Mutators","title":"Compound Mutators","text":"(Image: ProtoSyn Compound Mutator)","category":"page"},{"location":"protosyn-api/core/mutators/mutators-compound/","page":"Compound Mutators","title":"Compound Mutators","text":"Figure 1 | A diagram of an example CompoundMutator instance. In this example, the CompoundMutator.mutators list is comprised of a RotationRigidBodyMutator and a TranslationRigidBodyMutator, both without any internal selections. The CompoundMutator itlself, however, has a RandomSelectionFromFile AbstractSelection which will randomly select one of the two provided RangeSelection instances and apply both the rotation and translation rigid body mutators.","category":"page"}]
}
